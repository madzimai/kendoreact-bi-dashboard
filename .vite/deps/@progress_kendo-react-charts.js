"use client";
import {
  class_default,
  color_default,
  drawing_exports,
  geometry_exports,
  logToConsole,
  parseColor,
  support_default,
  throttle
} from "./chunk-FMZKDQ4H.js";
import {
  M,
  arrowLeftIcon,
  arrowRightIcon,
  e,
  h,
  homeIcon,
  i4 as i,
  i5 as i2,
  l,
  l2,
  n2 as n,
  p,
  require_prop_types,
  te,
  u2 as u,
  v3 as v,
  v5 as v2
} from "./chunk-ZRWBHFCZ.js";
import "./chunk-6IW3YP4A.js";
import {
  __toESM,
  require_react
} from "./chunk-N3BBKUNS.js";

// node_modules/@progress/kendo-react-charts/Chart.mjs
var t3 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/BaseChart.mjs
var l6 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/@progress/kendo-charts/dist/es/common/constants.js
var ARC = "arc";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var TAB = "Tab";
var ARIA_ACTIVE_DESCENDANT = "aria-activedescendant";
var AXIS_LABEL_CLICK = "axisLabelClick";
var BLACK = "#000";
var BOTTOM = "bottom";
var CENTER = "center";
var CIRCLE = "circle";
var COORD_PRECISION = 3;
var CROSS = "cross";
var DATE = "date";
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_HEIGHT = 400;
var DEFAULT_PRECISION = 10;
var DEFAULT_WIDTH = 600;
var END = "end";
var ENTER = "Enter";
var ESCAPE = "Escape";
var FORMAT_REGEX = /\{\d+:?/;
var HEIGHT = "height";
var HIGHLIGHT_ZINDEX = 100;
var INSIDE = "inside";
var INHERIT = "inherit";
var LEFT = "left";
var MAX_VALUE = Number.MAX_VALUE;
var MIN_VALUE = -Number.MAX_VALUE;
var NONE = "none";
var NOTE_CLICK = "noteClick";
var NOTE_HOVER = "noteHover";
var NOTE_LEAVE = "noteLeave";
var OBJECT = "object";
var OUTSIDE = "outside";
var RIGHT = "right";
var ROUNDED_RECT = "roundedRect";
var START = "start";
var STRING = "string";
var TOP = "top";
var TRIANGLE = "triangle";
var SQUARE = "square";
var RECT = "rect";
var VALUE = "value";
var WHITE = "#fff";
var WIDTH = "width";
var X = "x";
var Y = "y";
var DEFAULT_SERIES_OPACITY = 1;
var POINTER = "pointer";
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";

// node_modules/@progress/kendo-charts/dist/es/common/is-array.js
function isArray(value2) {
  return Array.isArray(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/add-class.js
function addClass(element, classes) {
  var classArray = isArray(classes) ? classes : [classes];
  for (var idx = 0; idx < classArray.length; idx++) {
    var className = classArray[idx];
    if (element.className.indexOf(className) === -1) {
      element.className += " " + className;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/remove-class.js
var SPACE_REGEX = /\s+/g;
function removeClass(element, className) {
  if (element && element.className) {
    element.className = element.className.replace(className, "").replace(SPACE_REGEX, " ");
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/align-path-to-pixel.js
function alignPathToPixel(path) {
  var offset = 0.5;
  if (path.options.stroke && drawing_exports.util.defined(path.options.stroke.width)) {
    if (path.options.stroke.width % 2 === 0) {
      offset = 0;
    }
  }
  for (var i36 = 0; i36 < path.segments.length; i36++) {
    path.segments[i36].anchor().round(0).translate(offset, offset);
  }
  return path;
}

// node_modules/@progress/kendo-charts/dist/es/common/clockwise.js
function clockwise(angle1, angle2) {
  return -angle1.x * angle2.y + angle1.y * angle2.x < 0;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-number.js
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-string.js
function isString(value2) {
  return typeof value2 === STRING;
}

// node_modules/@progress/kendo-charts/dist/es/common/convertable-to-number.js
function convertableToNumber(value2) {
  return isNumber(value2) || isString(value2) && isFinite(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleUp.js
function cycleUp(index, count) {
  return (index + 1) % count;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleDown.js
function cycleDown(index, count) {
  var result = index - 1;
  return result < 0 ? count - 1 : result;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleIndex.js
function cycleIndex(index, length) {
  if (length === 1 || index % length === 0) {
    return 0;
  }
  if (index < 0) {
    return length + index % length;
  } else if (index >= length) {
    return index % length;
  }
  return index;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-function.js
function isFunction(fn) {
  return typeof fn === "function";
}

// node_modules/@progress/kendo-charts/dist/es/common/deep-extend.js
var OBJECT2 = "object";
var UNDEFINED = "undefined";
function deepExtendOne(destination, source) {
  for (var property in source) {
    if (property === "__proto__" || property === "constructor") {
      continue;
    }
    var propValue = source[property];
    var propType = typeof propValue;
    var propInit = void 0;
    if (propType === OBJECT2 && propValue !== null) {
      propInit = propValue.constructor;
    } else {
      propInit = null;
    }
    if (propInit && propInit !== Array) {
      if (propValue instanceof Date) {
        destination[property] = new Date(propValue.getTime());
      } else if (isFunction(propValue.clone)) {
        destination[property] = propValue.clone();
      } else {
        var destProp = destination[property];
        if (typeof destProp === OBJECT2) {
          destination[property] = destProp || {};
        } else {
          destination[property] = {};
        }
        deepExtendOne(destination[property], propValue);
      }
    } else if (propType !== UNDEFINED) {
      destination[property] = propValue;
    }
  }
  return destination;
}
function deepExtend(destination) {
  var arguments$1 = arguments;
  var length = arguments.length;
  for (var i36 = 1; i36 < length; i36++) {
    deepExtendOne(destination, arguments$1[i36]);
  }
  return destination;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-object.js
function isObject(value2) {
  return typeof value2 === "object";
}

// node_modules/@progress/kendo-charts/dist/es/common/style-value.js
function styleValue(value2) {
  if (isNumber(value2)) {
    return value2 + "px";
  }
  return value2;
}

// node_modules/@progress/kendo-charts/dist/es/common/element-styles.js
var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;
function isSizeField(field) {
  return SIZE_STYLES_REGEX.test(field);
}
function elementStyles(element, styles) {
  var stylesArray = isString(styles) ? [styles] : styles;
  if (isArray(stylesArray)) {
    var result = {};
    var style = window.getComputedStyle(element);
    for (var idx = 0; idx < stylesArray.length; idx++) {
      var field = stylesArray[idx];
      result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];
    }
    return result;
  } else if (isObject(styles)) {
    for (var field$1 in styles) {
      element.style[field$1] = styleValue(styles[field$1]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-spacing.js
function getSpacing(value2, defaultSpacing) {
  if (defaultSpacing === void 0) defaultSpacing = 0;
  var spacing = { top: 0, right: 0, bottom: 0, left: 0 };
  if (typeof value2 === "number") {
    spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value2;
  } else {
    spacing[TOP] = value2[TOP] || defaultSpacing;
    spacing[RIGHT] = value2[RIGHT] || defaultSpacing;
    spacing[BOTTOM] = value2[BOTTOM] || defaultSpacing;
    spacing[LEFT] = value2[LEFT] || defaultSpacing;
  }
  return spacing;
}

// node_modules/@progress/kendo-charts/dist/es/services/template-service.js
var current = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = function TemplateService2() {
};
TemplateService.register = function register(userImplementation) {
  current = userImplementation;
};
TemplateService.compile = function compile(template, options) {
  return current.compile(template, options);
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-charts/dist/es/common/get-template.js
function getTemplate(options) {
  if (options === void 0) options = {};
  var template;
  if (options.template) {
    options.template = template = template_service_default.compile(options.template);
  } else if (isFunction(options.content)) {
    template = options.content;
  }
  return template;
}

// node_modules/@progress/kendo-charts/dist/es/common/get-aria-template.js
function getTemplate2(options) {
  if (options === void 0) options = {};
  var ariaTemplate;
  if (options.ariaTemplate) {
    options.ariaTemplate = ariaTemplate = template_service_default.compile(options.ariaTemplate);
  } else if (isFunction(options.ariaContent)) {
    ariaTemplate = options.ariaContent;
  }
  return ariaTemplate;
}

// node_modules/@progress/kendo-charts/dist/es/common/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
getterCache["undefined"] = function(obj) {
  return obj;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(drawing_exports.util.defined(index) ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-charts/dist/es/common/grep.js
function grep(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    if (callback(array[idx])) {
      result.push(array[idx]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/has-classes.js
function hasClasses(element, classNames) {
  if (element.className) {
    var names = classNames.split(" ");
    for (var idx = 0; idx < names.length; idx++) {
      if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/hash-map.js
var HashMap = function HashMap2() {
  this._map = /* @__PURE__ */ new Map();
};
HashMap.prototype.get = function get(key) {
  return this._map.get(key);
};
HashMap.prototype.set = function set(key, value2) {
  this._map.set(key, value2);
};
var hash_map_default = HashMap;

// node_modules/@progress/kendo-charts/dist/es/common/in-array.js
function inArray(value2, array) {
  if (array) {
    return array.indexOf(value2) !== -1;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/interpolate-value.js
function interpolateValue(start, end, progress) {
  return drawing_exports.util.round(start + (end - start) * progress, COORD_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/common/instance-observer.js
var TRIGGER = "trigger";
var InstanceObserver = function InstanceObserver2(observer, handlers) {
  this.observer = observer;
  this.handlerMap = deepExtend({}, this.handlerMap, handlers);
};
InstanceObserver.prototype.trigger = function trigger(name2, args) {
  var ref2 = this;
  var observer = ref2.observer;
  var handlerMap = ref2.handlerMap;
  var isDefaultPrevented2;
  if (handlerMap[name2]) {
    isDefaultPrevented2 = this.callObserver(handlerMap[name2], args);
  } else if (observer[TRIGGER]) {
    isDefaultPrevented2 = this.callObserver(TRIGGER, name2, args);
  }
  return isDefaultPrevented2;
};
InstanceObserver.prototype.callObserver = function callObserver(fnName) {
  var args = [], len = arguments.length - 1;
  while (len-- > 0) args[len] = arguments[len + 1];
  return this.observer[fnName].apply(this.observer, args);
};
InstanceObserver.prototype.requiresHandlers = function requiresHandlers(names) {
  var this$1 = this;
  if (this.observer.requiresHandlers) {
    return this.observer.requiresHandlers(names);
  }
  for (var idx = 0; idx < names.length; idx++) {
    if (this$1.handlerMap[names[idx]]) {
      return true;
    }
  }
};
var instance_observer_default = InstanceObserver;

// node_modules/@progress/kendo-charts/dist/es/common/is-plain-object.js
function isPlainObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}

// node_modules/@progress/kendo-charts/dist/es/common/map.js
function map(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    var value2 = callback(array[idx]);
    if (drawing_exports.util.defined(value2)) {
      result.push(value2);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/mousewheel-delta.js
var browser = support_default.browser || {};
function mousewheelDelta(e39) {
  var delta = 0;
  if (e39.wheelDelta) {
    delta = -e39.wheelDelta / 120;
    if (browser.webkit) {
      delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));
    }
  } else if (e39.detail) {
    delta = e39.detail / 3;
  }
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  return delta;
}

// node_modules/@progress/kendo-charts/dist/es/drawing-utils.js
var ref = drawing_exports.util;
var append = ref.append;
var bindEvents = ref.bindEvents;
var defined = ref.defined;
var deg = ref.deg;
var elementOffset = ref.elementOffset;
var elementSize = ref.elementSize;
var eventCoordinates = ref.eventCoordinates;
var eventElement = ref.eventElement;
var hashKey = ref.hashKey;
var last = ref.last;
var limitValue = ref.limitValue;
var objectKey = ref.objectKey;
var rad = ref.rad;
var round = ref.round;
var unbindEvents = ref.unbindEvents;
var valueOrDefault = ref.valueOrDefault;

// node_modules/@progress/kendo-charts/dist/es/common/font-loader.js
var FontLoader = function FontLoader2() {
};
FontLoader.fetchFonts = function fetchFonts(options, fonts, state) {
  if (state === void 0) state = { depth: 0 };
  var MAX_DEPTH = 5;
  if (!options || state.depth > MAX_DEPTH || !document.fonts) {
    return;
  }
  Object.keys(options).forEach(function(key) {
    var value2 = options[key];
    if (key === "dataSource" || key[0] === "$" || !value2) {
      return;
    }
    if (key === "font") {
      fonts.push(value2);
    } else if (typeof value2 === "object") {
      state.depth++;
      FontLoader.fetchFonts(value2, fonts, state);
      state.depth--;
    }
  });
};
FontLoader.loadFonts = function loadFonts(fonts, callback) {
  var promises = [];
  if (fonts.length > 0 && document.fonts) {
    try {
      promises = fonts.map(function(font) {
        return document.fonts.load(font);
      });
    } catch (e39) {
      logToConsole(e39);
    }
    Promise.all(promises).then(callback, callback);
  } else {
    callback();
  }
};
FontLoader.preloadFonts = function preloadFonts(options, callback) {
  var fonts = [];
  FontLoader.fetchFonts(options, fonts);
  FontLoader.loadFonts(fonts, callback);
};
var font_loader_default = FontLoader;

// node_modules/@progress/kendo-charts/dist/es/common/set-default-options.js
function setDefaultOptions(type, options) {
  var proto = type.prototype;
  if (proto.options) {
    proto.options = deepExtend({}, proto.options, options);
  } else {
    proto.options = options;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/render-icon.js
var KICON = "k-icon";
var KI_PREFFIX = "k-i-";
var KFONTICON = "k-font-icon";
var KSVGICON = "k-svg-icon";
var KSVG_PREFFIX = "k-svg-i-";
var HTMLBaseIcon = function HTMLBaseIcon2(element, options) {
  this.element = element;
  this.options = deepExtend({}, this.options, options);
  this.wrapper();
};
HTMLBaseIcon.prototype.wrapper = function wrapper() {
  this.addClasses();
};
HTMLBaseIcon.prototype.addClasses = function addClasses() {
};
HTMLBaseIcon.prototype.html = function html() {
  return this.element.outerHTML;
};
setDefaultOptions(HTMLBaseIcon, {
  name: "",
  size: "none",
  themeColor: "none",
  flip: "default",
  iconClass: "",
  stylingOptions: ["size", "themeColor", "fill"]
});
var HTMLFontIcon = function(HTMLBaseIcon3) {
  function HTMLFontIcon2(element, options) {
    HTMLBaseIcon3.call(this, element, options);
  }
  if (HTMLBaseIcon3) HTMLFontIcon2.__proto__ = HTMLBaseIcon3;
  HTMLFontIcon2.prototype = Object.create(HTMLBaseIcon3 && HTMLBaseIcon3.prototype);
  HTMLFontIcon2.prototype.constructor = HTMLFontIcon2;
  HTMLFontIcon2.prototype.wrapper = function wrapper2() {
    var currentIconClass = this.element.className.split(" ").find(function(x5) {
      return x5.startsWith(KI_PREFFIX);
    });
    var className = this.options.icon ? "" + (this.options.icon.startsWith(KI_PREFFIX) ? "" : KI_PREFFIX) + this.options.icon : "";
    this._className = className;
    addClass(this.element, KICON);
    addClass(this.element, KFONTICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, this.options.iconClass || "");
    HTMLBaseIcon3.prototype.wrapper.call(this);
  };
  return HTMLFontIcon2;
}(HTMLBaseIcon);
setDefaultOptions(HTMLFontIcon, {
  name: "HTMLFontIcon",
  icon: null
});
var HTMLSvgIcon = function(HTMLBaseIcon3) {
  function HTMLSvgIcon2(element, options) {
    element.innerHTML = "";
    HTMLBaseIcon3.call(this, element, options);
  }
  if (HTMLBaseIcon3) HTMLSvgIcon2.__proto__ = HTMLBaseIcon3;
  HTMLSvgIcon2.prototype = Object.create(HTMLBaseIcon3 && HTMLBaseIcon3.prototype);
  HTMLSvgIcon2.prototype.constructor = HTMLSvgIcon2;
  HTMLSvgIcon2.prototype.wrapper = function wrapper2() {
    var icon = this.options.icon;
    var iconClass = this.options.iconClass;
    var currentIconClass = this.element.className.split(" ").find(function(x5) {
      return x5.startsWith(KSVG_PREFFIX);
    });
    if (!icon && iconClass) {
      var regex = /k-i-(\w+(?:-\w+)*)/;
      var iconNameMatch = iconClass.match(regex);
      if (iconNameMatch) {
        icon = iconNameMatch[1];
        iconClass = iconClass.replace(iconNameMatch[0], "");
      }
    }
    if (isString(icon)) {
      icon = icon.replace("k-i-", "").replace(/-./g, function(x5) {
        return x5[1].toUpperCase();
      });
      icon = this.options.svgIcons[icon] || this.options.svgIcons[icon + "Icon"];
    }
    var className = icon && icon.name ? "" + KSVG_PREFFIX + icon.name : "";
    this._className = className;
    addClass(this.element, KSVGICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, iconClass || "");
    this.element.setAttribute("aria-hidden", "true");
    if (icon && isPlainObject(icon)) {
      var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgElement.setAttribute("viewBox", icon.viewBox || "");
      svgElement.setAttribute("focusable", "false");
      svgElement.innerHTML = icon.content || "";
      this.element.appendChild(svgElement);
    }
    HTMLBaseIcon3.prototype.wrapper.call(this);
  };
  return HTMLSvgIcon2;
}(HTMLBaseIcon);
setDefaultOptions(HTMLSvgIcon, {
  name: "HTMLSvgIcon",
  icon: null,
  svgIcons: {}
});
var ICON_TYPES = {
  "svg": HTMLSvgIcon,
  "font": HTMLFontIcon
};
function renderIcon(iconElement, iconOptions) {
  var element = iconElement;
  var options = iconOptions;
  if (!element || isObject(element) && !(element instanceof HTMLElement) || isString(element)) {
    options = element;
    element = document.createElement("span");
  }
  if (isString(options)) {
    options = {
      icon: options
    };
  }
  if (!options.type) {
    options.type = "svg";
  }
  if (!ICON_TYPES[options.type]) {
    return null;
  }
  return new ICON_TYPES[options.type](element, options).html();
}

// node_modules/@progress/kendo-charts/dist/es/common/sparse-array-limits.js
function sparseArrayLimits(arr) {
  var min4 = MAX_VALUE;
  var max3 = MIN_VALUE;
  for (var idx = 0, length = arr.length; idx < length; idx++) {
    var value2 = arr[idx];
    if (value2 !== null && isFinite(value2)) {
      min4 = Math.min(min4, value2);
      max3 = Math.max(max3, value2);
    }
  }
  return {
    min: min4 === MAX_VALUE ? void 0 : min4,
    max: max3 === MIN_VALUE ? void 0 : max3
  };
}

// node_modules/@progress/kendo-charts/dist/es/common/find.js
function find(array, predicate) {
  for (var i36 = 0; i36 < array.length; i36++) {
    var item = array[i36];
    if (predicate(item, i36, array)) {
      return item;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/element-scale.js
var Matrix = geometry_exports.Matrix;
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  var match = matrixString.match(matrixRegexp);
  if (match === null || match.length !== 2) {
    return Matrix.unit();
  }
  var members = match[1].split(",").map(function(x5) {
    return parseFloat(x5);
  });
  return new (Function.prototype.bind.apply(Matrix, [null].concat(members)))();
}
function transformMatrix(element) {
  var transform = getComputedStyle(element).transform;
  if (transform === "none") {
    return Matrix.unit();
  }
  return parseMatrix(transform);
}
function elementScale(element) {
  if (!element) {
    return Matrix.unit();
  }
  var matrix = transformMatrix(element);
  var parent = element.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-charts/dist/es/common/auto-text-color.js
function autoTextColor(color) {
  var isDark = new color_default(color).isDark();
  if (isDark) {
    return WHITE;
  }
  return BLACK;
}
var auto_text_color_default = autoTextColor;

// node_modules/@progress/kendo-charts/dist/es/common/create-hash-set.js
var DELETED = {};
var LegacySet = function LegacySet2(values5) {
  var this$1 = this;
  this._index = {};
  this._values = values5 ? values5.slice(0) : [];
  for (var i36 = 0; i36 < this._values.length; i36++) {
    this$1._index[this$1._values[i36]] = i36;
  }
};
var prototypeAccessors = { size: { configurable: true } };
LegacySet.prototype.values = function values() {
  return this._values.filter(function(item) {
    return item !== DELETED;
  });
};
LegacySet.prototype.has = function has(value2) {
  return this._index[value2] !== void 0;
};
LegacySet.prototype.add = function add(value2) {
  if (!this.has(value2)) {
    this._index[value2] = this._values.length;
    this._values.push(value2);
  }
};
LegacySet.prototype.delete = function delete$1(value2) {
  var index = this._index[value2];
  if (index !== void 0) {
    this._values[index] = DELETED;
    delete this._index[value2];
  }
};
LegacySet.prototype.clear = function clear() {
  this._index = {};
  this._values = [];
};
prototypeAccessors.size.get = function() {
  return this._values.length;
};
Object.defineProperties(LegacySet.prototype, prototypeAccessors);
var SetWrapper = function SetWrapper2(values5) {
  this._set = new Set(values5);
};
var prototypeAccessors$1 = { size: { configurable: true } };
SetWrapper.prototype.values = function values2() {
  return Array.from(this._set);
};
SetWrapper.prototype.has = function has2(value2) {
  return this._set.has(value2);
};
SetWrapper.prototype.add = function add2(value2) {
  this._set.add(value2);
};
SetWrapper.prototype.delete = function delete$2(value2) {
  this._set.delete(value2);
};
SetWrapper.prototype.clear = function clear2() {
  this._set.clear();
};
prototypeAccessors$1.size.get = function() {
  return this._set.size;
};
Object.defineProperties(SetWrapper.prototype, prototypeAccessors$1);
var supportsSet = function() {
  var supported = false;
  if (typeof Set === "function") {
    var set3 = /* @__PURE__ */ new Set([1]);
    supported = set3.has(1);
  }
  return supported;
};
function createHashSet(values5) {
  if (supportsSet()) {
    return new SetWrapper(values5);
  }
  return new LegacySet(values5);
}

// node_modules/@progress/kendo-charts/dist/es/common/default-error-handler.js
function defaultErrorHandler(error) {
  throw error;
}

// node_modules/@progress/kendo-charts/dist/es/common/keys.js
var keys = {
  INSERT: 45,
  DELETE: 46,
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  END: 35,
  HOME: 36,
  SPACEBAR: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  F2: 113,
  F10: 121,
  F12: 123,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_DOT: 110
};
var keys_default = keys;

// node_modules/@progress/kendo-charts/dist/es/common/has-own-property.js
function hasOwnProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}

// node_modules/@progress/kendo-charts/dist/es/common/matrix.js
var Matrix2 = function Matrix3() {
  this.height = 0;
  this.width = 0;
  this.data = [];
};
Matrix2.prototype.clone = function clone() {
  var m11 = new Matrix2();
  m11.height = this.height;
  m11.width = this.width;
  m11.data = this.data.map(function(row) {
    return row.slice();
  });
  return m11;
};
Matrix2.prototype.get = function get2(row, col) {
  var line = this.data[row];
  var val = line ? line[col] : null;
  return val;
};
Matrix2.prototype.set = function set2(row, col, data) {
  var line = this.data[row];
  if (line == null) {
    line = this.data[row] = [];
  }
  line[col] = data;
  if (row >= this.height) {
    this.height = row + 1;
  }
  if (col >= this.width) {
    this.width = col + 1;
  }
};
Matrix2.prototype.each = function each(f4, includeEmpty) {
  var this$1 = this;
  for (var row = 0; row < this.height; ++row) {
    for (var col = 0; col < this.width; ++col) {
      var val = this$1.get(row, col);
      if (includeEmpty || val != null) {
        val = f4(val, row, col);
        if (val !== void 0) {
          return val;
        }
      }
    }
  }
};
Matrix2.prototype.map = function map2(f4, includeEmpty) {
  var m11 = new Matrix2();
  this.each(function(el, row, col) {
    m11.set(row, col, f4(el, row, col));
  }, includeEmpty);
  return m11;
};
Matrix2.prototype.transpose = function transpose() {
  var m11 = new Matrix2();
  this.each(function(el, row, col) {
    m11.set(col, row, el);
  });
  return m11;
};
Matrix2.prototype.unit = function unit(n20) {
  this.width = this.height = n20;
  var a38 = this.data = new Array(n20);
  for (var i36 = n20; --i36 >= 0; ) {
    var row = a38[i36] = new Array(n20);
    for (var j2 = n20; --j2 >= 0; ) {
      row[j2] = i36 === j2 ? 1 : 0;
    }
  }
  return this;
};
Matrix2.prototype.multiply = function multiply(b2) {
  var a38 = this;
  var m11 = new Matrix2();
  for (var row = 0; row < a38.height; ++row) {
    for (var col = 0; col < b2.width; ++col) {
      var s10 = 0;
      for (var i36 = 0; i36 < a38.width; ++i36) {
        var va = a38.get(row, i36);
        var vb = b2.get(i36, col);
        if (typeof va === "number" && typeof vb === "number") {
          s10 += va * vb;
        }
      }
      m11.set(row, col, s10);
    }
  }
  return m11;
};
Matrix2.prototype.inverse = function inverse() {
  var n20 = this.width;
  var m11 = this.augment(new Matrix2().unit(n20));
  var a38 = m11.data;
  var loop = function(k2) {
    var imax = argmax(k2, n20, function(i37) {
      return a38[i37][k2];
    });
    if (!a38[imax][k2]) {
      return { v: null };
    }
    if (k2 !== imax) {
      var tmp = a38[k2];
      a38[k2] = a38[imax];
      a38[imax] = tmp;
    }
    for (var i36 = k2 + 1; i36 < n20; ++i36) {
      for (var j2 = k2 + 1; j2 < 2 * n20; ++j2) {
        a38[i36][j2] -= a38[k2][j2] * a38[i36][k2] / a38[k2][k2];
      }
      a38[i36][k2] = 0;
    }
  };
  for (var k = 0; k < n20; ++k) {
    var returned = loop(k);
    if (returned) return returned.v;
  }
  for (var i$1 = 0; i$1 < n20; ++i$1) {
    for (var f4 = a38[i$1][i$1], j$1 = 0; j$1 < 2 * n20; ++j$1) {
      a38[i$1][j$1] /= f4;
    }
  }
  for (var k$1 = n20; --k$1 >= 0; ) {
    for (var i$2 = k$1; --i$2 >= 0; ) {
      if (a38[i$2][k$1]) {
        for (var j$2 = 2 * n20; --j$2 >= n20; ) {
          a38[i$2][j$2] -= a38[k$1][j$2] * a38[i$2][k$1];
        }
      }
    }
  }
  return m11.slice(0, n20, n20, n20);
};
Matrix2.prototype.augment = function augment(m11) {
  var ret = this.clone();
  var n20 = ret.width;
  m11.each(function(val, row, col) {
    ret.set(row, col + n20, val);
  });
  return ret;
};
Matrix2.prototype.slice = function slice(row, col, height, width) {
  var this$1 = this;
  var m11 = new Matrix2();
  for (var i36 = 0; i36 < height; ++i36) {
    for (var j2 = 0; j2 < width; ++j2) {
      m11.set(i36, j2, this$1.get(row + i36, col + j2));
    }
  }
  return m11;
};
function argmax(start, end, f4) {
  var max3 = f4(start), pos = start;
  for (var i36 = start + 1; i36 < end; i36++) {
    var v5 = f4(start);
    if (v5 > max3) {
      max3 = v5;
      pos = start;
    }
  }
  return pos;
}
var matrix_default = Matrix2;

// node_modules/@progress/kendo-charts/dist/es/common/event-map.js
var eventMap = {
  down: "pointerdown",
  move: "pointermove",
  up: "pointerup",
  cancel: "pointercancel pointerleave"
};
function queryEventMap(e39) {
  return eventMap[e39] || e39;
}
var applyEventMap = function(events) {
  var eventRegEx = /([^ ]+)/g;
  var appliedEvents = events.replace(eventRegEx, queryEventMap);
  return appliedEvents;
};

// node_modules/@progress/kendo-charts/dist/es/core/utils/guid.js
function guid() {
  var id = "";
  var i36;
  var random;
  for (i36 = 0; i36 < 32; i36++) {
    random = Math.random() * 16 | 0;
    if (i36 === 8 || i36 === 12 || i36 === 16 || i36 === 20) {
      id += "-";
    }
    id += (i36 === 12 ? 4 : i36 === 16 ? random & 3 | 8 : random).toString(16);
  }
  return id;
}

// node_modules/@progress/kendo-charts/dist/es/common/event-utils.js
var elementEventHandlers = /* @__PURE__ */ new WeakMap();
var ID = Symbol("id");
function on(element, events, filter, handler, useCapture) {
  addEventListeners(element, events, filter, handler, useCapture);
}
function off(element, events, filter, handler, useCapture) {
  removeEventListeners(element, events, filter, handler, useCapture);
}
function isString2(value2) {
  return typeof value2 === "string";
}
function addEventListeners(element, events, filter, handler, useCapture) {
  var eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    addEventListener(element, eventName, filter, handler, useCapture);
  });
}
function addEventListener(element, event, filter, handler, useCapture) {
  var eventHandler = handler;
  var eventFilter;
  if (filter && isFunction(filter) && !handler) {
    eventHandler = filter;
  } else if (filter && isString2(filter) && isFunction(eventHandler)) {
    eventFilter = filter;
  }
  var attachedHandler = function(e39) {
    var closestMatchingTarget = e39.target ? e39.target.closest(eventFilter) : null;
    if (!eventFilter || eventFilter && e39.target && closestMatchingTarget) {
      var currentTarget = eventFilter ? closestMatchingTarget : e39.currentTarget;
      Object.defineProperty(e39, "currentTarget", { value: currentTarget });
      Object.defineProperty(e39, "delegateTarget", { value: element });
      eventHandler(e39);
    }
  };
  eventHandler[ID] = guid();
  var eventHandlers = elementEventHandlers.get(element);
  if (!eventHandlers) {
    eventHandlers = /* @__PURE__ */ new Map();
    elementEventHandlers.set(element, eventHandlers);
  }
  eventHandlers.set(eventHandler[ID], attachedHandler);
  element.addEventListener(event, attachedHandler, Boolean(useCapture));
}
function removeEventListeners(element, events, handler, useCapture) {
  var eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    removeEventListener(element, eventName, handler, useCapture);
  });
}
function removeEventListener(element, event, handler, useCapture) {
  var eventHandlers = elementEventHandlers.get(element);
  if (eventHandlers && handler && handler[ID]) {
    var handlerId = handler[ID];
    var attachedHandler = eventHandlers.get(handlerId);
    eventHandlers.delete(handlerId);
    if (attachedHandler) {
      element.removeEventListener(event, attachedHandler, Boolean(useCapture));
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-supported-features.js
function getSupportedFeatures() {
  var os = detectOS(navigator.userAgent);
  var support = {};
  support.mobileOS = os;
  return support;
}
function detectOS(ua) {
  var os = false;
  var agentRxs = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.?(\d+(\.\d+)?)?/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i
  }, osRxs = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i
  };
  for (var agent in agentRxs) {
    var match = ua.match(agentRxs[agent]);
    if (match) {
      if (agent === "windows" && "plugins" in navigator) {
        return false;
      }
      os = {};
      os.device = agent;
      os.name = testRegex(agent, osRxs);
      os[os.name] = true;
      break;
    }
  }
  return os;
}
function testRegex(agent, regexes, dflt) {
  for (var regex in regexes) {
    if (regexes[regex].test(agent)) {
      return regex;
    }
  }
  return dflt !== void 0 ? dflt : agent;
}

// node_modules/@progress/kendo-charts/dist/es/common/noop.js
function noop() {
}

// node_modules/@progress/kendo-charts/dist/es/common/now.js
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}

// node_modules/@progress/kendo-charts/dist/es/common/observable.js
var STRING2 = "string";
var FUNCTION = "function";
var preventDefault = function() {
  this._defaultPrevented = true;
};
var isDefaultPrevented = function() {
  return this._defaultPrevented === true;
};
var Observable = function(Class) {
  function Observable2() {
    Class.call(this);
    this._events = {};
  }
  if (Class) Observable2.__proto__ = Class;
  Observable2.prototype = Object.create(Class && Class.prototype);
  Observable2.prototype.constructor = Observable2;
  Observable2.prototype.destroy = function destroy() {
    this.unbind();
  };
  Observable2.prototype.bind = function bind(event, handlers, one) {
    var that = this, idx, eventNames = typeof event === STRING2 ? [event] : event || [], length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    if (handlers === void 0) {
      for (idx in event) {
        that.bind(idx, event[idx]);
      }
      return that;
    }
    var loop = function() {
      var eventName = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName];
      if (handler) {
        if (one) {
          original = handler;
          handler = function() {
            that.unbind(eventName, handler);
            original.apply(that, arguments);
          };
          handler.original = original;
        }
        events = that._events[eventName] = that._events[eventName] || [];
        events.push(handler);
      }
    };
    for (idx = 0, length = eventNames.length; idx < length; idx++) loop();
    return that;
  };
  Observable2.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable2.prototype.first = function first(eventName, handlers) {
    var that = this, idx, eventNames = typeof eventName === STRING2 ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        events = that._events[eventName$1] = that._events[eventName$1] || [];
        events.unshift(handler);
      }
    }
    return that;
  };
  Observable2.prototype.trigger = function trigger2(eventName, eventArgs) {
    var that = this, events = that._events[eventName], idx, length;
    if (events) {
      var e39 = eventArgs || {};
      e39.sender = that;
      e39._defaultPrevented = false;
      e39.preventDefault = preventDefault;
      e39.isDefaultPrevented = isDefaultPrevented;
      events = events.slice();
      for (idx = 0, length = events.length; idx < length; idx++) {
        events[idx].call(that, e39);
      }
      return e39._defaultPrevented === true;
    }
    return false;
  };
  Observable2.prototype.unbind = function unbind(eventName, handler) {
    var that = this, events = that._events[eventName], idx;
    if (eventName === void 0) {
      that._events = {};
    } else if (events) {
      if (handler) {
        for (idx = events.length - 1; idx >= 0; idx--) {
          if (events[idx] === handler || events[idx].original === handler) {
            events.splice(idx, 1);
          }
        }
      } else {
        that._events[eventName] = [];
      }
    }
    return that;
  };
  Observable2.prototype._setEvents = function _setEvents(options) {
    var this$1 = this;
    var length = (this.events || []).length;
    for (var idx = 0; idx < length; idx++) {
      var e39 = this$1.events[idx];
      if (this$1.options[e39] && options[e39]) {
        this$1.unbind(e39, this$1.options[e39]);
        if (this$1._events && this$1._events[e39]) {
          delete this$1._events[e39];
        }
      }
    }
    this.bind(this.events, options);
  };
  return Observable2;
}(class_default);
var observable_default = Observable;

// node_modules/@progress/kendo-charts/dist/es/common/user-events.js
var extend = Object.assign;
var preventDefault2 = function(e39) {
  e39.preventDefault();
};
var DEFAULT_MIN_HOLD = 800;
var CLICK_DELAY = 300;
var DEFAULT_THRESHOLD = 0;
var PRESS = "press";
var HOLD = "hold";
var SELECT = "select";
var START2 = "start";
var MOVE = "move";
var END2 = "end";
var CANCEL = "cancel";
var TAP = "tap";
var DOUBLETAP = "doubleTap";
var RELEASE = "release";
var GESTURESTART = "gesturestart";
var GESTURECHANGE = "gesturechange";
var GESTUREEND = "gestureend";
var GESTURETAP = "gesturetap";
var THRESHOLD = {
  "api": 0,
  "touch": 0,
  "mouse": 9,
  "pointer": 9
};
function touchDelta(touch1, touch2) {
  var x1 = touch1.x.location, y1 = touch1.y.location, x22 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x22, dy = y1 - y2;
  return {
    center: {
      x: (x1 + x22) / 2,
      y: (y1 + y2) / 2
    },
    distance: Math.sqrt(dx * dx + dy * dy)
  };
}
function getTouches(e39) {
  var touches = [], originalEvent = e39.originalEvent || e39, currentTarget = e39.currentTarget;
  if (e39.api) {
    touches.push({
      id: 2,
      // hardcoded ID for API call
      event: e39,
      target: e39.target,
      currentTarget: e39.target,
      location: e39,
      type: "api"
    });
  } else {
    touches.push({
      location: originalEvent,
      event: e39,
      target: e39.target,
      currentTarget,
      id: originalEvent.pointerId,
      type: "pointer"
    });
  }
  return touches;
}
var TouchAxis = function(Class) {
  function TouchAxis2(axis, location) {
    Class.call(this);
    var that = this;
    that.support = getSupportedFeatures();
    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;
    that.axis = axis;
    that._updateLocationData(location);
    that.startLocation = that.location;
    that.velocity = that.delta = 0;
    that.timeStamp = now();
  }
  if (Class) TouchAxis2.__proto__ = Class;
  TouchAxis2.prototype = Object.create(Class && Class.prototype);
  TouchAxis2.prototype.constructor = TouchAxis2;
  TouchAxis2.prototype.move = function move(location) {
    var that = this, offset = location["page" + that.axis], timeStamp = now(), timeDelta = timeStamp - that.timeStamp || 1;
    if (!offset && this.invalidZeroEvents) {
      return;
    }
    that.delta = offset - that.location;
    that._updateLocationData(location);
    that.initialDelta = offset - that.startLocation;
    that.velocity = that.delta / timeDelta;
    that.timeStamp = timeStamp;
  };
  TouchAxis2.prototype._updateLocationData = function _updateLocationData(location) {
    var that = this, axis = that.axis;
    that.location = location["page" + axis];
    that.client = location["client" + axis];
    that.screen = location["screen" + axis];
  };
  return TouchAxis2;
}(class_default);
var Touch = function(Class) {
  function Touch2(userEvents, target, touchInfo) {
    Class.call(this);
    extend(this, {
      x: new TouchAxis("X", touchInfo.location),
      y: new TouchAxis("Y", touchInfo.location),
      type: touchInfo.type,
      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
      userEvents,
      target,
      currentTarget: touchInfo.currentTarget,
      initialTouch: touchInfo.target,
      id: touchInfo.id,
      pressEvent: touchInfo,
      _clicks: userEvents._clicks,
      supportDoubleTap: userEvents.supportDoubleTap,
      _moved: false,
      _finished: false
    });
  }
  if (Class) Touch2.__proto__ = Class;
  Touch2.prototype = Object.create(Class && Class.prototype);
  Touch2.prototype.constructor = Touch2;
  Touch2.prototype.press = function press() {
    var this$1 = this;
    this._holdTimeout = setTimeout(function() {
      return this$1._hold();
    }, this.userEvents.minHold);
    this._trigger(PRESS, this.pressEvent);
  };
  Touch2.prototype._tap = function _tap(touchInfo) {
    var that = this;
    that.userEvents._clicks++;
    if (that.userEvents._clicks === 1) {
      that._clickTimeout = setTimeout(function() {
        if (that.userEvents._clicks === 1) {
          that._trigger(TAP, touchInfo);
        } else {
          that._trigger(DOUBLETAP, touchInfo);
        }
        that.userEvents._clicks = 0;
      }, CLICK_DELAY);
    }
  };
  Touch2.prototype._hold = function _hold() {
    this._trigger(HOLD, this.pressEvent);
  };
  Touch2.prototype.move = function move(touchInfo) {
    var that = this;
    var preventMove = touchInfo.type !== "api" && that.userEvents._shouldNotMove;
    if (that._finished || preventMove) {
      return;
    }
    that.x.move(touchInfo.location);
    that.y.move(touchInfo.location);
    if (!that._moved) {
      if (that._withinIgnoreThreshold()) {
        return;
      }
      if (!UserEvents.current || UserEvents.current === that.userEvents) {
        that._start(touchInfo);
      } else {
        return that.dispose();
      }
    }
    if (!that._finished) {
      that._trigger(MOVE, touchInfo);
    }
  };
  Touch2.prototype.end = function end(touchInfo) {
    this.endTime = now();
    if (this._finished) {
      return;
    }
    this._finished = true;
    this._trigger(RELEASE, touchInfo);
    if (this._moved) {
      this._trigger(END2, touchInfo);
    } else {
      if (this.supportDoubleTap) {
        this._tap(touchInfo);
      } else {
        this._trigger(TAP, touchInfo);
      }
    }
    clearTimeout(this._holdTimeout);
    this.dispose();
  };
  Touch2.prototype.dispose = function dispose() {
    var userEvents = this.userEvents, activeTouches = userEvents.touches || [];
    this._finished = true;
    this.pressEvent = null;
    clearTimeout(this._holdTimeout);
    var activeTouchIndex = activeTouches.indexOf(this);
    activeTouches.splice(activeTouchIndex, 1);
  };
  Touch2.prototype.skip = function skip() {
    this.dispose();
  };
  Touch2.prototype.cancel = function cancel() {
    this.dispose();
  };
  Touch2.prototype.isMoved = function isMoved() {
    return this._moved;
  };
  Touch2.prototype._start = function _start(touchInfo) {
    clearTimeout(this._holdTimeout);
    this.startTime = now();
    this._moved = true;
    this._trigger(START2, touchInfo);
  };
  Touch2.prototype._trigger = function _trigger(name2, touchInfo) {
    var e39 = touchInfo.event;
    var data = {
      touch: this,
      x: this.x,
      y: this.y,
      target: this.target,
      event: e39
    };
    if (this.userEvents.notify(name2, data)) {
      e39.preventDefault();
    }
  };
  Touch2.prototype._withinIgnoreThreshold = function _withinIgnoreThreshold() {
    var xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
  };
  return Touch2;
}(class_default);
function withEachUpEvent(callback) {
  var downEvents = eventMap.up.split(" "), idx = 0, length = downEvents.length;
  for (; idx < length; idx++) {
    callback(downEvents[idx]);
  }
}
var UserEvents = function(Observable2) {
  function UserEvents2(element, options) {
    Observable2.call(this);
    var that = this;
    var filter;
    var support = getSupportedFeatures();
    this.support = support;
    options = options || {};
    this.options = options;
    filter = that.filter = options.filter;
    that.threshold = options.threshold || DEFAULT_THRESHOLD;
    that.minHold = options.minHold || DEFAULT_MIN_HOLD;
    that.touches = [];
    that._maxTouches = options.multiTouch ? 2 : 1;
    that.allowSelection = options.allowSelection;
    that.captureUpIfMoved = options.captureUpIfMoved;
    that._clicks = 0;
    that.supportDoubleTap = options.supportDoubleTap;
    extend(that, {
      element,
      surface: options.surface || element,
      stopPropagation: options.stopPropagation,
      pressed: false
    });
    this._surfaceMoveHandler = this._move.bind(this);
    on(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    this._surfaceEndHandler = this._end.bind(this);
    on(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    this._elementStartHandler = this._start.bind(this);
    on(element, applyEventMap("down"), filter, this._elementStartHandler);
    element.style["touch-action"] = options.touchAction || "none";
    if (options.preventDragEvent) {
      this._elementDragStartHandler = preventDefault2;
      on(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    this._elementSelectHandler = this._select.bind(this);
    on(element, applyEventMap("mousedown"), filter, this._elementSelectHandler);
    if (that.captureUpIfMoved) {
      var surfaceElement = that.surface, preventIfMovingProxy = that.preventIfMoving.bind(that);
      withEachUpEvent(function(eventName) {
        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);
      });
    }
    that.bind([
      PRESS,
      HOLD,
      TAP,
      DOUBLETAP,
      START2,
      MOVE,
      END2,
      RELEASE,
      CANCEL,
      GESTURESTART,
      GESTURECHANGE,
      GESTUREEND,
      GESTURETAP,
      SELECT
    ], options);
  }
  if (Observable2) UserEvents2.__proto__ = Observable2;
  UserEvents2.prototype = Object.create(Observable2 && Observable2.prototype);
  UserEvents2.prototype.constructor = UserEvents2;
  UserEvents2.prototype.preventIfMoving = function preventIfMoving(e39) {
    if (this._isMoved()) {
      e39.preventDefault();
    }
  };
  UserEvents2.prototype.destroy = function destroy() {
    var that = this;
    var options = this.options;
    var element = this.element;
    if (that._destroyed) {
      return;
    }
    that._destroyed = true;
    if (that.captureUpIfMoved) {
      var surfaceElement = that.surface;
      withEachUpEvent(function(eventName) {
        surfaceElement.removeEventListener(eventName, that.preventIfMoving);
      });
    }
    off(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    off(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    off(element, applyEventMap("down"), this._elementStartHandler);
    if (options.preventDragEvent) {
      off(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    off(element, applyEventMap("mousedown"), this._elementSelectHandler);
    that._disposeAll();
    that.unbind();
    delete that.surface;
    delete that.element;
    delete that.currentTarget;
  };
  UserEvents2.prototype.capture = function capture() {
    UserEvents2.current = this;
  };
  UserEvents2.prototype.cancel = function cancel() {
    this._disposeAll();
    this.trigger(CANCEL);
  };
  UserEvents2.prototype.notify = function notify3(event, data) {
    var that = this, touches = that.touches;
    var eventName = event;
    if (this._isMultiTouch()) {
      switch (eventName) {
        case MOVE:
          eventName = GESTURECHANGE;
          break;
        case END2:
          eventName = GESTUREEND;
          break;
        case TAP:
          eventName = GESTURETAP;
          break;
        default:
          break;
      }
      extend(data, {
        touches
      }, touchDelta(touches[0], touches[1]));
    }
    return this.trigger(eventName, extend(data, {
      type: eventName
    }));
  };
  UserEvents2.prototype.press = function press(x5, y, target) {
    this._apiCall("_start", x5, y, target);
  };
  UserEvents2.prototype.move = function move(x5, y) {
    this._apiCall("_move", x5, y);
  };
  UserEvents2.prototype.end = function end(x5, y) {
    this._apiCall("_end", x5, y);
  };
  UserEvents2.prototype._isMultiTouch = function _isMultiTouch() {
    return this.touches.length > 1;
  };
  UserEvents2.prototype._maxTouchesReached = function _maxTouchesReached() {
    return this.touches.length >= this._maxTouches;
  };
  UserEvents2.prototype._disposeAll = function _disposeAll() {
    var touches = this.touches;
    while (touches.length > 0) {
      touches.pop().dispose();
    }
  };
  UserEvents2.prototype._isMoved = function _isMoved() {
    return grep(this.touches, function(touch) {
      return touch.isMoved();
    }).length;
  };
  UserEvents2.prototype._select = function _select(e39) {
    if (!this.allowSelection || this.trigger(SELECT, { event: e39 })) {
      e39.preventDefault();
    }
  };
  UserEvents2.prototype._start = function _start(e39) {
    var this$1 = this;
    if (e39.which && e39.which > 1 || this._maxTouchesReached()) {
      return;
    }
    UserEvents2.current = null;
    this.currentTarget = e39.currentTarget;
    if (this.stopPropagation) {
      e39.stopPropagation();
    }
    var target;
    var eventTouches = getTouches(e39);
    for (var idx = 0; idx < eventTouches.length; idx++) {
      if (this$1._maxTouchesReached()) {
        break;
      }
      var eventTouch = eventTouches[idx];
      if (this$1.filter) {
        target = eventTouch.currentTarget;
      } else {
        target = this$1.element;
      }
      if (target && target.length === 0) {
        continue;
      }
      var touch = new Touch(this$1, target, eventTouch);
      this$1.touches.push(touch);
      touch.press();
      if (this$1._isMultiTouch()) {
        this$1.notify("gesturestart", {});
      }
    }
  };
  UserEvents2.prototype._move = function _move(e39) {
    this._eachTouch("move", e39);
  };
  UserEvents2.prototype._end = function _end(e39) {
    this._eachTouch("end", e39);
  };
  UserEvents2.prototype._eachTouch = function _eachTouch(methodName, e39) {
    var this$1 = this;
    var that = this, dict = {}, touches = getTouches(e39), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
    for (idx = 0; idx < activeTouches.length; idx++) {
      touch = activeTouches[idx];
      dict[touch.id] = touch;
    }
    for (idx = 0; idx < touches.length; idx++) {
      touchInfo = touches[idx];
      matchingTouch = dict[touchInfo.id];
      if (matchingTouch) {
        var shouldCapture = methodName === "move" && touchInfo.type === "pointer" && !this$1.surface.hasPointerCapture(touchInfo.id);
        if (shouldCapture) {
          this$1.surface.setPointerCapture(touchInfo.id);
        }
        matchingTouch[methodName](touchInfo);
      }
    }
  };
  UserEvents2.prototype._apiCall = function _apiCall(type, x5, y, target) {
    this[type]({
      api: true,
      pageX: x5,
      pageY: y,
      clientX: x5,
      clientY: y,
      target: target || this.element,
      stopPropagation: noop,
      preventDefault: noop
    });
  };
  UserEvents2.defaultThreshold = function defaultThreshold(value2) {
    DEFAULT_THRESHOLD = value2;
  };
  UserEvents2.minHold = function minHold(value2) {
    DEFAULT_MIN_HOLD = value2;
  };
  return UserEvents2;
}(observable_default);
var user_events_default = UserEvents;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-major-unit.js
function autoMajorUnit(min4, max3) {
  var diff = round(max3 - min4, DEFAULT_PRECISION - 1);
  if (diff === 0) {
    if (max3 === 0) {
      return 0.1;
    }
    diff = Math.abs(max3);
  }
  var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));
  var relativeValue = round(diff / scale, DEFAULT_PRECISION);
  var scaleMultiplier = 1;
  if (relativeValue < 1.904762) {
    scaleMultiplier = 0.2;
  } else if (relativeValue < 4.761904) {
    scaleMultiplier = 0.5;
  } else if (relativeValue < 9.523809) {
    scaleMultiplier = 1;
  } else {
    scaleMultiplier = 2;
  }
  return round(scale * scaleMultiplier, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/point.js
var Point = function(Class) {
  function Point7(x5, y) {
    Class.call(this);
    this.x = x5 || 0;
    this.y = y || 0;
  }
  if (Class) Point7.__proto__ = Class;
  Point7.prototype = Object.create(Class && Class.prototype);
  Point7.prototype.constructor = Point7;
  Point7.prototype.clone = function clone3() {
    return new Point7(this.x, this.y);
  };
  Point7.prototype.equals = function equals(point) {
    return point && this.x === point.x && this.y === point.y;
  };
  Point7.prototype.rotate = function rotate(center, degrees) {
    var theta = rad(degrees);
    var cosT = Math.cos(theta);
    var sinT = Math.sin(theta);
    var cx = center.x;
    var cy = center.y;
    var ref2 = this;
    var x5 = ref2.x;
    var y = ref2.y;
    this.x = round(
      cx + (x5 - cx) * cosT + (y - cy) * sinT,
      COORD_PRECISION
    );
    this.y = round(
      cy + (y - cy) * cosT - (x5 - cx) * sinT,
      COORD_PRECISION
    );
    return this;
  };
  Point7.prototype.multiply = function multiply2(a38) {
    this.x *= a38;
    this.y *= a38;
    return this;
  };
  Point7.prototype.distanceTo = function distanceTo(point) {
    var dx = this.x - point.x;
    var dy = this.y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point7.onCircle = function onCircle(center, angle, radius) {
    var radians = rad(angle);
    return new Point7(
      center.x - radius * Math.cos(radians),
      center.y - radius * Math.sin(radians)
    );
  };
  return Point7;
}(class_default);
var point_default = Point;

// node_modules/@progress/kendo-charts/dist/es/core/box.js
var Box = function(Class) {
  function Box2(x1, y1, x22, y2) {
    Class.call(this);
    this.x1 = x1 || 0;
    this.y1 = y1 || 0;
    this.x2 = x22 || 0;
    this.y2 = y2 || 0;
  }
  if (Class) Box2.__proto__ = Class;
  Box2.prototype = Object.create(Class && Class.prototype);
  Box2.prototype.constructor = Box2;
  Box2.prototype.equals = function equals(box) {
    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;
  };
  Box2.prototype.width = function width() {
    return this.x2 - this.x1;
  };
  Box2.prototype.height = function height() {
    return this.y2 - this.y1;
  };
  Box2.prototype.translate = function translate2(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  };
  Box2.prototype.move = function move(x5, y) {
    var height = this.height();
    var width = this.width();
    if (defined(x5)) {
      this.x1 = x5;
      this.x2 = this.x1 + width;
    }
    if (defined(y)) {
      this.y1 = y;
      this.y2 = this.y1 + height;
    }
    return this;
  };
  Box2.prototype.wrap = function wrap(targetBox) {
    this.x1 = Math.min(this.x1, targetBox.x1);
    this.y1 = Math.min(this.y1, targetBox.y1);
    this.x2 = Math.max(this.x2, targetBox.x2);
    this.y2 = Math.max(this.y2, targetBox.y2);
    return this;
  };
  Box2.prototype.wrapPoint = function wrapPoint(point) {
    var arrayPoint = isArray(point);
    var x5 = arrayPoint ? point[0] : point.x;
    var y = arrayPoint ? point[1] : point.y;
    this.wrap(new Box2(x5, y, x5, y));
    return this;
  };
  Box2.prototype.snapTo = function snapTo(targetBox, axis) {
    if (axis === X || !axis) {
      this.x1 = targetBox.x1;
      this.x2 = targetBox.x2;
    }
    if (axis === Y || !axis) {
      this.y1 = targetBox.y1;
      this.y2 = targetBox.y2;
    }
    return this;
  };
  Box2.prototype.alignTo = function alignTo(targetBox, anchor) {
    var height = this.height();
    var width = this.width();
    var axis = anchor === TOP || anchor === BOTTOM ? Y : X;
    var offset = axis === Y ? height : width;
    if (anchor === CENTER) {
      var targetCenter = targetBox.center();
      var center = this.center();
      this.x1 += targetCenter.x - center.x;
      this.y1 += targetCenter.y - center.y;
    } else if (anchor === TOP || anchor === LEFT) {
      this[axis + 1] = targetBox[axis + 1] - offset;
    } else {
      this[axis + 1] = targetBox[axis + 2];
    }
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.shrink = function shrink(dw, dh) {
    this.x2 -= dw;
    this.y2 -= dh;
    return this;
  };
  Box2.prototype.expand = function expand(dw, dh) {
    this.shrink(-dw, -dh);
    return this;
  };
  Box2.prototype.pad = function pad2(padding) {
    var spacing = getSpacing(padding);
    this.x1 -= spacing.left;
    this.x2 += spacing.right;
    this.y1 -= spacing.top;
    this.y2 += spacing.bottom;
    return this;
  };
  Box2.prototype.unpad = function unpad2(padding) {
    var spacing = getSpacing(padding);
    spacing.left = -spacing.left;
    spacing.top = -spacing.top;
    spacing.right = -spacing.right;
    spacing.bottom = -spacing.bottom;
    return this.pad(spacing);
  };
  Box2.prototype.clone = function clone3() {
    return new Box2(this.x1, this.y1, this.x2, this.y2);
  };
  Box2.prototype.center = function center() {
    return new point_default(
      this.x1 + this.width() / 2,
      this.y1 + this.height() / 2
    );
  };
  Box2.prototype.containsPoint = function containsPoint(point) {
    return point.x >= this.x1 && point.x <= this.x2 && point.y >= this.y1 && point.y <= this.y2;
  };
  Box2.prototype.points = function points() {
    return [
      new point_default(this.x1, this.y1),
      new point_default(this.x2, this.y1),
      new point_default(this.x2, this.y2),
      new point_default(this.x1, this.y2)
    ];
  };
  Box2.prototype.getHash = function getHash() {
    return [this.x1, this.y1, this.x2, this.y2].join(",");
  };
  Box2.prototype.overlaps = function overlaps(box) {
    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);
  };
  Box2.prototype.rotate = function rotate(rotation) {
    var width = this.width();
    var height = this.height();
    var ref2 = this.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var r1 = rotatePoint(0, 0, cx, cy, rotation);
    var r27 = rotatePoint(width, 0, cx, cy, rotation);
    var r32 = rotatePoint(width, height, cx, cy, rotation);
    var r42 = rotatePoint(0, height, cx, cy, rotation);
    width = Math.max(r1.x, r27.x, r32.x, r42.x) - Math.min(r1.x, r27.x, r32.x, r42.x);
    height = Math.max(r1.y, r27.y, r32.y, r42.y) - Math.min(r1.y, r27.y, r32.y, r42.y);
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.toRect = function toRect() {
    return new geometry_exports.Rect([this.x1, this.y1], [this.width(), this.height()]);
  };
  Box2.prototype.hasSize = function hasSize() {
    return this.width() !== 0 && this.height() !== 0;
  };
  Box2.prototype.align = function align(targetBox, axis, alignment) {
    var c1 = axis + 1;
    var c22 = axis + 2;
    var sizeFunc = axis === X ? WIDTH : HEIGHT;
    var size = this[sizeFunc]();
    if (inArray(alignment, [LEFT, TOP])) {
      this[c1] = targetBox[c1];
      this[c22] = this[c1] + size;
    } else if (inArray(alignment, [RIGHT, BOTTOM])) {
      this[c22] = targetBox[c22];
      this[c1] = this[c22] - size;
    } else if (alignment === CENTER) {
      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;
      this[c22] = this[c1] + size;
    }
  };
  return Box2;
}(class_default);
function rotatePoint(x5, y, cx, cy, angle) {
  var theta = rad(angle);
  return new point_default(
    cx + (x5 - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),
    cy - (x5 - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)
  );
}
var box_default = Box;

// node_modules/@progress/kendo-charts/dist/es/core/ring.js
var Ring = function(Class) {
  function Ring2(center, innerRadius, radius, startAngle, angle) {
    Class.call(this);
    this.center = center;
    this.innerRadius = innerRadius;
    this.radius = radius;
    this.startAngle = startAngle;
    this.angle = angle;
  }
  if (Class) Ring2.__proto__ = Class;
  Ring2.prototype = Object.create(Class && Class.prototype);
  Ring2.prototype.constructor = Ring2;
  Ring2.prototype.clone = function clone3() {
    return new Ring2(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
  };
  Ring2.prototype.middle = function middle() {
    return this.startAngle + this.angle / 2;
  };
  Ring2.prototype.setRadius = function setRadius(newRadius, innerRadius) {
    if (innerRadius) {
      this.innerRadius = newRadius;
    } else {
      this.radius = newRadius;
    }
    return this;
  };
  Ring2.prototype.point = function point(angle, innerRadius) {
    var radianAngle = rad(angle);
    var ax = Math.cos(radianAngle);
    var ay = Math.sin(radianAngle);
    var radius = innerRadius ? this.innerRadius : this.radius;
    var x5 = round(this.center.x - ax * radius, COORD_PRECISION);
    var y = round(this.center.y - ay * radius, COORD_PRECISION);
    return new point_default(x5, y);
  };
  Ring2.prototype.adjacentBox = function adjacentBox(distance, width, height) {
    var sector = this.clone().expand(distance);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    var hw = width / 2;
    var hh = height / 2;
    var sa = Math.sin(rad(midAndle));
    var ca = Math.cos(rad(midAndle));
    var x5 = midPoint.x - hw;
    var y = midPoint.y - hh;
    if (Math.abs(sa) < 0.9) {
      x5 += hw * -ca / Math.abs(ca);
    }
    if (Math.abs(ca) < 0.9) {
      y += hh * -sa / Math.abs(sa);
    }
    return new box_default(x5, y, x5 + width, y + height);
  };
  Ring2.prototype.containsPoint = function containsPoint(p9) {
    var center = this.center;
    var innerRadius = this.innerRadius;
    var radius = this.radius;
    var startAngle = this.startAngle;
    var endAngle = this.startAngle + this.angle;
    var dx = p9.x - center.x;
    var dy = p9.y - center.y;
    var vector = new point_default(dx, dy);
    var startPoint = this.point(startAngle);
    var startVector = new point_default(startPoint.x - center.x, startPoint.y - center.y);
    var endPoint = this.point(endAngle);
    var endVector = new point_default(endPoint.x - center.x, endPoint.y - center.y);
    var dist = round(dx * dx + dy * dy, COORD_PRECISION);
    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
  };
  Ring2.prototype.getBBox = function getBBox() {
    var this$1 = this;
    var box = new box_default(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);
    var startAngle = round(this.startAngle % 360);
    var endAngle = round((startAngle + this.angle) % 360);
    var innerRadius = this.innerRadius;
    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
    var startAngleIndex = allAngles.indexOf(startAngle);
    var endAngleIndex = allAngles.indexOf(endAngle);
    var angles;
    if (startAngle === endAngle) {
      angles = allAngles;
    } else {
      if (startAngleIndex < endAngleIndex) {
        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
      } else {
        angles = [].concat(
          allAngles.slice(0, endAngleIndex + 1),
          allAngles.slice(startAngleIndex, allAngles.length)
        );
      }
    }
    for (var i36 = 0; i36 < angles.length; i36++) {
      var point = this$1.point(angles[i36]);
      box.wrapPoint(point);
      box.wrapPoint(point, innerRadius);
    }
    if (!innerRadius) {
      box.wrapPoint(this.center);
    }
    return box;
  };
  Ring2.prototype.expand = function expand(value2) {
    this.radius += value2;
    return this;
  };
  return Ring2;
}(class_default);
function numericComparer(a38, b2) {
  return a38 - b2;
}
var ring_default = Ring;

// node_modules/@progress/kendo-charts/dist/es/core/sector.js
var Sector = function(Ring2) {
  function Sector2(center, radius, startAngle, angle) {
    Ring2.call(this, center, 0, radius, startAngle, angle);
  }
  if (Ring2) Sector2.__proto__ = Ring2;
  Sector2.prototype = Object.create(Ring2 && Ring2.prototype);
  Sector2.prototype.constructor = Sector2;
  Sector2.prototype.expand = function expand(value2) {
    return Ring2.prototype.expand.call(this, value2);
  };
  Sector2.prototype.clone = function clone3() {
    return new Sector2(this.center, this.radius, this.startAngle, this.angle);
  };
  Sector2.prototype.setRadius = function setRadius(newRadius) {
    this.radius = newRadius;
    return this;
  };
  return Sector2;
}(ring_default);

// node_modules/@progress/kendo-charts/dist/es/core/shape-builder.js
var DIRECTION_ANGLE = 1e-3;
var ShapeBuilder = function(Class) {
  function ShapeBuilder2() {
    Class.apply(this, arguments);
  }
  if (Class) ShapeBuilder2.__proto__ = Class;
  ShapeBuilder2.prototype = Object.create(Class && Class.prototype);
  ShapeBuilder2.prototype.constructor = ShapeBuilder2;
  ShapeBuilder2.prototype.createRing = function createRing(sector, options) {
    var startAngle = sector.startAngle + 180;
    var endAngle = sector.angle + startAngle;
    if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {
      endAngle += DIRECTION_ANGLE;
    }
    var center = new geometry_exports.Point(sector.center.x, sector.center.y);
    var radius = Math.max(sector.radius, 0);
    var innerRadius = Math.max(sector.innerRadius, 0);
    var arc = new geometry_exports.Arc(center, {
      startAngle,
      endAngle,
      radiusX: radius,
      radiusY: radius
    });
    var path = drawing_exports.Path.fromArc(arc, options).close();
    if (innerRadius) {
      arc.radiusX = arc.radiusY = innerRadius;
      var innerEnd = arc.pointAt(endAngle);
      path.lineTo(innerEnd.x, innerEnd.y);
      path.arc(endAngle, startAngle, innerRadius, innerRadius, true);
    } else {
      path.lineTo(center.x, center.y);
    }
    return path;
  };
  return ShapeBuilder2;
}(class_default);
ShapeBuilder.current = new ShapeBuilder();
var shape_builder_default = ShapeBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/chart-element.js
var ChartElement = function(Class) {
  function ChartElement2(options) {
    Class.call(this);
    this.children = [];
    this.options = deepExtend({}, this.options, this.initUserOptions(options));
  }
  if (Class) ChartElement2.__proto__ = Class;
  ChartElement2.prototype = Object.create(Class && Class.prototype);
  ChartElement2.prototype.constructor = ChartElement2;
  ChartElement2.prototype.initUserOptions = function initUserOptions(options) {
    return options;
  };
  ChartElement2.prototype.reflow = function reflow(targetBox) {
    var children = this.children;
    var box;
    for (var i36 = 0; i36 < children.length; i36++) {
      var currentChild = children[i36];
      currentChild.reflow(targetBox);
      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
    }
    this.box = box || targetBox;
  };
  ChartElement2.prototype.destroy = function destroy() {
    var children = this.children;
    if (this.animation) {
      this.animation.destroy();
    }
    for (var i36 = 0; i36 < children.length; i36++) {
      children[i36].destroy();
    }
  };
  ChartElement2.prototype.getRoot = function getRoot() {
    var parent = this.parent;
    return parent ? parent.getRoot() : null;
  };
  ChartElement2.prototype.getSender = function getSender() {
    var service = this.getService();
    if (service) {
      return service.sender;
    }
  };
  ChartElement2.prototype.getService = function getService() {
    var element = this;
    while (element) {
      if (element.chartService) {
        return element.chartService;
      }
      element = element.parent;
    }
  };
  ChartElement2.prototype.translateChildren = function translateChildren(dx, dy) {
    var children = this.children;
    var childrenCount = children.length;
    for (var i36 = 0; i36 < childrenCount; i36++) {
      children[i36].box.translate(dx, dy);
    }
  };
  ChartElement2.prototype.append = function append2() {
    var arguments$1 = arguments;
    var this$1 = this;
    for (var i36 = 0; i36 < arguments.length; i36++) {
      var item = arguments$1[i36];
      this$1.children.push(item);
      item.parent = this$1;
    }
  };
  ChartElement2.prototype.renderVisual = function renderVisual() {
    if (this.options.visible === false) {
      return;
    }
    this.createVisual();
    this.addVisual();
    this.renderChildren();
    this.createAnimation();
    this.renderComplete();
  };
  ChartElement2.prototype.addVisual = function addVisual() {
    if (this.visual) {
      this.visual.chartElement = this;
      if (this.parent) {
        this.parent.appendVisual(this.visual);
      }
    }
  };
  ChartElement2.prototype.renderChildren = function renderChildren() {
    var children = this.children;
    var length = children.length;
    for (var i36 = 0; i36 < length; i36++) {
      children[i36].renderVisual();
    }
  };
  ChartElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: this.options.zIndex,
      visible: valueOrDefault(this.options.visible, true)
    });
  };
  ChartElement2.prototype.createAnimation = function createAnimation() {
    if (this.visual && this.options.animation) {
      this.animation = drawing_exports.Animation.create(
        this.visual,
        this.options.animation
      );
    }
  };
  ChartElement2.prototype.appendVisual = function appendVisual(childVisual) {
    if (!childVisual.chartElement) {
      childVisual.chartElement = this;
    }
    if (childVisual.options.noclip) {
      this.clipRoot().visual.append(childVisual);
    } else if (defined(childVisual.options.zIndex)) {
      this.stackRoot().stackVisual(childVisual);
    } else if (this.isStackRoot) {
      this.stackVisual(childVisual);
    } else if (this.visual) {
      this.visual.append(childVisual);
    } else {
      this.parent.appendVisual(childVisual);
    }
  };
  ChartElement2.prototype.clipRoot = function clipRoot() {
    if (this.parent) {
      return this.parent.clipRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackRoot = function stackRoot() {
    if (this.parent) {
      return this.parent.stackRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackVisual = function stackVisual(childVisual) {
    var zIndex = childVisual.options.zIndex || 0;
    var visuals = this.visual.children;
    var length = visuals.length;
    var pos;
    for (pos = 0; pos < length; pos++) {
      var sibling = visuals[pos];
      var here = valueOrDefault(sibling.options.zIndex, 0);
      if (here > zIndex) {
        break;
      }
    }
    this.visual.insert(pos, childVisual);
  };
  ChartElement2.prototype.traverse = function traverse(callback) {
    var children = this.children;
    var length = children.length;
    for (var i36 = 0; i36 < length; i36++) {
      var child = children[i36];
      callback(child);
      if (child.traverse) {
        child.traverse(callback);
      }
    }
  };
  ChartElement2.prototype.closest = function closest(match) {
    var element = this;
    var matched = false;
    while (element && !matched) {
      matched = match(element);
      if (!matched) {
        element = element.parent;
      }
    }
    if (matched) {
      return element;
    }
  };
  ChartElement2.prototype.renderComplete = function renderComplete() {
  };
  ChartElement2.prototype.hasHighlight = function hasHighlight() {
    var options = (this.options || {}).highlight;
    return !(!this.createHighlight || options && options.visible === false || this.visible === false);
  };
  ChartElement2.prototype.toggleHighlight = function toggleHighlight(show2, opacity) {
    var this$1 = this;
    var options = (this.options || {}).highlight || {};
    var customVisual = options.visual;
    var highlight = this._highlight;
    if (!highlight) {
      var highlightOptions2 = {
        fill: {
          color: WHITE,
          opacity: opacity || 0.2
        },
        stroke: {
          color: WHITE,
          width: 1,
          opacity: opacity || 0.2
        }
      };
      if (customVisual) {
        highlight = this._highlight = customVisual(
          Object.assign(this.highlightVisualArgs(), {
            createVisual: function() {
              return this$1.createHighlight(highlightOptions2);
            },
            sender: this.getSender(),
            series: this.series,
            dataItem: this.dataItem,
            category: this.category,
            value: this.value,
            percentage: this.percentage,
            runningTotal: this.runningTotal,
            total: this.total
          })
        );
        if (!highlight) {
          return;
        }
      } else {
        highlight = this._highlight = this.createHighlight(highlightOptions2);
      }
      if (!defined(highlight.options.zIndex)) {
        highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);
      }
      this.appendVisual(highlight);
    }
    highlight.visible(show2);
  };
  ChartElement2.prototype.toggleFocusHighlight = function toggleFocusHighlight(show2) {
    var options = (this.options || {}).focusHighlight || {};
    var focusHighlight = this._focusHighlight;
    if (!show2 && !focusHighlight) {
      return;
    }
    if (!focusHighlight) {
      var rootBackground = this.getRoot().options.background;
      var highlightColor = auto_text_color_default(rootBackground);
      var focusHighlightOptions = {
        fill: {
          opacity: options.opacity,
          color: options.color
        },
        stroke: Object.assign({}, { color: highlightColor }, options.border),
        zIndex: options.zIndex
      };
      focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);
      this.appendVisual(focusHighlight);
    }
    focusHighlight.visible(show2);
  };
  ChartElement2.prototype.createGradientOverlay = function createGradientOverlay(element, options, gradientOptions) {
    var overlay = new drawing_exports.Path(Object.assign({
      stroke: {
        color: "none"
      },
      fill: this.createGradient(gradientOptions),
      closed: element.options.closed
    }, options));
    overlay.segments.elements(element.segments.elements());
    return overlay;
  };
  ChartElement2.prototype.createGradient = function createGradient(options) {
    if (this.parent) {
      return this.parent.createGradient(options);
    }
  };
  ChartElement2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return true;
  };
  return ChartElement2;
}(class_default);
ChartElement.prototype.options = {};
var chart_element_default = ChartElement;

// node_modules/@progress/kendo-charts/dist/es/core/pattern.js
var dotsPattern = drawing_exports.dotsPattern;
var verticalStripesPattern = drawing_exports.verticalStripesPattern;
var crosshatchPattern = drawing_exports.crosshatchPattern;
var diagonalStripesPattern = drawing_exports.diagonalStripesPattern;
var gridPattern = drawing_exports.gridPattern;
var patternMap = {
  dots: dotsPattern,
  verticalStripes: verticalStripesPattern,
  crosshatch: crosshatchPattern,
  diagonalStripes: diagonalStripesPattern,
  grid: gridPattern
};
function evaluatePattern(options, point) {
  return isFunction(options) ? options(point) : options;
}
function createPatternFill(options, fill, point) {
  var patternOptions = evaluatePattern(options, point);
  var pattern = patternOptions && patternMap[patternOptions.type];
  return pattern ? pattern(Object.assign({}, fill, patternOptions)) : fill;
}

// node_modules/@progress/kendo-charts/dist/es/core/box-element.js
var BoxElement = function(ChartElement2) {
  function BoxElement2(options) {
    ChartElement2.call(this, options);
    this.options.margin = getSpacing(this.options.margin);
    this.options.padding = getSpacing(this.options.padding);
  }
  if (ChartElement2) BoxElement2.__proto__ = ChartElement2;
  BoxElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BoxElement2.prototype.constructor = BoxElement2;
  BoxElement2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options = this.options;
    var width = options.width;
    var height = options.height;
    var shrinkToFit = options.shrinkToFit;
    var hasSetSize = width && height;
    var margin = options.margin;
    var padding = options.padding;
    var borderWidth = options.border.width;
    var box;
    var reflowPaddingBox = function() {
      this$1.align(targetBox, X, options.align);
      this$1.align(targetBox, Y, options.vAlign);
      this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);
    };
    var contentBox = targetBox.clone();
    if (hasSetSize) {
      contentBox.x2 = contentBox.x1 + width;
      contentBox.y2 = contentBox.y1 + height;
    }
    if (shrinkToFit) {
      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);
    }
    ChartElement2.prototype.reflow.call(this, contentBox);
    if (hasSetSize) {
      box = this.box = new box_default(0, 0, width, height);
    } else {
      box = this.box;
    }
    if (shrinkToFit && hasSetSize) {
      reflowPaddingBox();
      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);
    } else {
      contentBox = this.contentBox = box.clone();
      box.pad(padding).pad(borderWidth).pad(margin);
      reflowPaddingBox();
    }
    this.translateChildren(
      box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,
      box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top
    );
    var children = this.children;
    for (var i36 = 0; i36 < children.length; i36++) {
      var item = children[i36];
      item.reflow(item.box);
    }
  };
  BoxElement2.prototype.align = function align(targetBox, axis, alignment) {
    this.box.align(targetBox, axis, alignment);
  };
  BoxElement2.prototype.hasBox = function hasBox() {
    var options = this.options;
    return options.border.width || options.background;
  };
  BoxElement2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options = this.options;
    if (options.visible && this.hasBox()) {
      this.visual.append(drawing_exports.Path.fromRect(
        this.paddingBox.toRect(),
        this.visualStyle()
      ));
    }
  };
  BoxElement2.prototype.visualStyle = function visualStyle() {
    var options = this.options;
    var border = options.border || {};
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: createPatternFill(options.pattern, {
        color: options.background,
        opacity: options.opacity
      }, void 0),
      cursor: options.cursor
    };
  };
  return BoxElement2;
}(chart_element_default);
setDefaultOptions(BoxElement, {
  align: LEFT,
  vAlign: TOP,
  margin: {},
  padding: {},
  border: {
    color: BLACK,
    width: 0
  },
  background: "",
  shrinkToFit: false,
  width: 0,
  height: 0,
  visible: true
});
var box_element_default = BoxElement;

// node_modules/@progress/kendo-charts/dist/es/core/utils/add-accessibility-attributes-to-visual.js
function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {
  if (accessibilityOptions) {
    visual.options.className = accessibilityOptions.className;
    visual.options.role = accessibilityOptions.role;
    visual.options.ariaLabel = accessibilityOptions.ariaLabel;
    visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;
    visual.options.ariaChecked = accessibilityOptions.ariaChecked;
  }
}

// node_modules/@progress/kendo-charts/dist/es/core/shape-element.js
var ShapeElement = function(BoxElement2) {
  function ShapeElement2(options, pointData) {
    BoxElement2.call(this, options);
    this.pointData = pointData;
  }
  if (BoxElement2) ShapeElement2.__proto__ = BoxElement2;
  ShapeElement2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  ShapeElement2.prototype.constructor = ShapeElement2;
  ShapeElement2.prototype.getElement = function getElement() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.paddingBox;
    var type = options.type;
    var rotation = options.rotation;
    var center = box.center();
    var halfWidth = box.width() / 2;
    var halfHeight = box.height() / 2;
    if (!options.visible || !this.hasBox()) {
      return null;
    }
    var style = this.visualStyle();
    var element;
    if (type === CIRCLE) {
      element = new drawing_exports.Circle(
        new geometry_exports.Circle([
          round(box.x1 + halfWidth, COORD_PRECISION),
          round(box.y1 + halfHeight, COORD_PRECISION)
        ], Math.min(halfWidth, halfHeight)),
        style
      );
    } else if (type === TRIANGLE) {
      element = drawing_exports.Path.fromPoints([
        [box.x1 + halfWidth, box.y1],
        [box.x1, box.y2],
        [box.x2, box.y2]
      ], style).close();
    } else if (type === CROSS) {
      element = new drawing_exports.MultiPath(style);
      element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);
      element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);
    } else {
      var rect = box.toRect();
      if (type === ROUNDED_RECT) {
        var borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);
        rect.setCornerRadius(borderRadius);
      }
      element = drawing_exports.Path.fromRect(rect, style);
    }
    if (rotation) {
      element.transform(
        geometry_exports.transform().rotate(-rotation, [center.x, center.y])
      );
    }
    element.options.zIndex = options.zIndex;
    return element;
  };
  ShapeElement2.prototype.createElement = function createElement93() {
    var this$1 = this;
    var customVisual = this.options.visual;
    var pointData = this.pointData || {};
    var visual;
    if (customVisual) {
      visual = customVisual({
        value: pointData.value,
        dataItem: pointData.dataItem,
        sender: this.getSender(),
        series: pointData.series,
        category: pointData.category,
        rect: this.paddingBox.toRect(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  ShapeElement2.prototype.visualOptions = function visualOptions() {
    var options = this.options;
    return {
      background: options.background,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      type: options.type,
      size: options.width,
      visible: options.visible
    };
  };
  ShapeElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
    addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);
  };
  return ShapeElement2;
}(box_element_default);
setDefaultOptions(ShapeElement, {
  type: CIRCLE,
  align: CENTER,
  vAlign: CENTER
});
var shape_element_default = ShapeElement;

// node_modules/@progress/kendo-charts/dist/es/core/gradients.js
var LINEAR = "linear";
var RADIAL = "radial";
var GRADIENTS = {
  glass: {
    type: LINEAR,
    rotation: 0,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.25,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 1,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpBevel: {
    type: RADIAL,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.55
    }, {
      offset: 0.65,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0.25
    }]
  },
  roundedBevel: {
    type: RADIAL,
    stops: [{
      offset: 0.33,
      color: WHITE,
      opacity: 0.06
    }, {
      offset: 0.83,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0
    }]
  },
  roundedGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.5,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.15,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.17,
      color: WHITE,
      opacity: 0.35
    }, {
      offset: 0.85,
      color: WHITE,
      opacity: 0.05
    }, {
      offset: 0.87,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  bubbleShadow: {
    type: RADIAL,
    center: [0.5, 0.5],
    radius: 0.5
  }
};
var gradients_default = GRADIENTS;

// node_modules/@progress/kendo-charts/dist/es/core/utils/box-diff.js
function boxDiff(r27, s10) {
  if (r27.x1 === s10.x1 && r27.y1 === s10.y1 && r27.x2 === s10.x2 && r27.y2 === s10.y2) {
    return s10;
  }
  var a38 = Math.min(r27.x1, s10.x1);
  var b2 = Math.max(r27.x1, s10.x1);
  var c10 = Math.min(r27.x2, s10.x2);
  var d6 = Math.max(r27.x2, s10.x2);
  var e39 = Math.min(r27.y1, s10.y1);
  var f4 = Math.max(r27.y1, s10.y1);
  var g2 = Math.min(r27.y2, s10.y2);
  var h5 = Math.max(r27.y2, s10.y2);
  var boxes = [];
  boxes[0] = new box_default(b2, e39, c10, f4);
  boxes[1] = new box_default(a38, f4, b2, g2);
  boxes[2] = new box_default(c10, f4, d6, g2);
  boxes[3] = new box_default(b2, g2, c10, h5);
  if (r27.x1 === a38 && r27.y1 === e39 || s10.x1 === a38 && s10.y1 === e39) {
    boxes[4] = new box_default(a38, e39, b2, f4);
    boxes[5] = new box_default(c10, g2, d6, h5);
  } else {
    boxes[4] = new box_default(c10, e39, d6, f4);
    boxes[5] = new box_default(a38, g2, b2, h5);
  }
  return grep(boxes, function(box) {
    return box.height() > 0 && box.width() > 0;
  })[0];
}

// node_modules/@progress/kendo-charts/dist/es/core/root-element.js
var RootElement = function(ChartElement2) {
  function RootElement2(options) {
    ChartElement2.call(this, options);
    var rootOptions = this.options;
    rootOptions.width = parseInt(rootOptions.width, 10);
    rootOptions.height = parseInt(rootOptions.height, 10);
    this.gradients = {};
  }
  if (ChartElement2) RootElement2.__proto__ = ChartElement2;
  RootElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RootElement2.prototype.constructor = RootElement2;
  RootElement2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var currentBox = new box_default(0, 0, options.width, options.height);
    this.box = currentBox.unpad(options.margin);
    for (var i36 = 0; i36 < children.length; i36++) {
      children[i36].reflow(currentBox);
      currentBox = boxDiff(currentBox, children[i36].box) || new box_default();
    }
  };
  RootElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group();
    this.createBackground();
  };
  RootElement2.prototype.createBackground = function createBackground() {
    var options = this.options;
    var border = options.border || {};
    var box = this.box.clone().pad(options.margin).unpad(border.width);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      zIndex: -10
    });
    this.visual.append(background);
  };
  RootElement2.prototype.getRoot = function getRoot() {
    return this;
  };
  RootElement2.prototype.createGradient = function createGradient(options) {
    var gradients = this.gradients;
    var hashCode = objectKey(options);
    var gradient = gradients_default[options.gradient];
    var drawingGradient;
    if (gradients[hashCode]) {
      drawingGradient = gradients[hashCode];
    } else {
      var gradientOptions = Object.assign({}, gradient, options);
      if (gradient.type === "linear") {
        drawingGradient = new drawing_exports.LinearGradient(gradientOptions);
      } else {
        if (options.innerRadius) {
          gradientOptions.stops = innerRadialStops(gradientOptions);
        }
        drawingGradient = new drawing_exports.RadialGradient(gradientOptions);
        drawingGradient.supportVML = gradient.supportVML !== false;
      }
      gradients[hashCode] = drawingGradient;
    }
    return drawingGradient;
  };
  RootElement2.prototype.cleanGradients = function cleanGradients() {
    var gradients = this.gradients;
    for (var hashCode in gradients) {
      gradients[hashCode]._observers = [];
    }
  };
  RootElement2.prototype.size = function size() {
    var options = this.options;
    return new box_default(0, 0, options.width, options.height);
  };
  return RootElement2;
}(chart_element_default);
setDefaultOptions(RootElement, {
  width: DEFAULT_WIDTH,
  height: DEFAULT_HEIGHT,
  background: WHITE,
  border: {
    color: BLACK,
    width: 0
  },
  margin: getSpacing(5),
  zIndex: -2
});
function innerRadialStops(options) {
  var stops = options.stops;
  var usedSpace = options.innerRadius / options.radius * 100;
  var length = stops.length;
  var currentStops = [];
  for (var i36 = 0; i36 < length; i36++) {
    var currentStop = Object.assign({}, stops[i36]);
    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;
    currentStops.push(currentStop);
  }
  return currentStops;
}
var root_element_default = RootElement;

// node_modules/@progress/kendo-charts/dist/es/core/float-element.js
var FloatElement = function(ChartElement2) {
  function FloatElement2(options) {
    ChartElement2.call(this, options);
    this._initDirection();
  }
  if (ChartElement2) FloatElement2.__proto__ = ChartElement2;
  FloatElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FloatElement2.prototype.constructor = FloatElement2;
  FloatElement2.prototype._initDirection = function _initDirection() {
    var options = this.options;
    if (options.vertical) {
      this.groupAxis = X;
      this.elementAxis = Y;
      this.groupSizeField = WIDTH;
      this.elementSizeField = HEIGHT;
      this.groupSpacing = options.spacing;
      this.elementSpacing = options.vSpacing;
    } else {
      this.groupAxis = Y;
      this.elementAxis = X;
      this.groupSizeField = HEIGHT;
      this.elementSizeField = WIDTH;
      this.groupSpacing = options.vSpacing;
      this.elementSpacing = options.spacing;
    }
  };
  FloatElement2.prototype.reflow = function reflow(targetBox) {
    this.box = targetBox.clone();
    this.reflowChildren();
  };
  FloatElement2.prototype.reflowChildren = function reflowChildren() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var elementAxis = ref2.elementAxis;
    var groupAxis = ref2.groupAxis;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var ref$1 = this.groupOptions();
    var groups = ref$1.groups;
    var groupsSize = ref$1.groupsSize;
    var maxGroupElementsSize = ref$1.maxGroupElementsSize;
    var groupsCount = groups.length;
    var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());
    if (groupsCount) {
      var groupStart = groupsStart;
      for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {
        var group = groups[groupIdx];
        var groupElements = group.groupElements;
        var elementStart = box[elementAxis + 1];
        var groupElementsCount = groupElements.length;
        for (var idx = 0; idx < groupElementsCount; idx++) {
          var element = groupElements[idx];
          var elementSize2 = this$1.elementSize(element);
          var groupElementStart = groupStart + this$1.alignStart(elementSize2[groupSizeField], group.groupSize);
          var elementBox = new box_default();
          elementBox[groupAxis + 1] = groupElementStart;
          elementBox[groupAxis + 2] = groupElementStart + elementSize2[groupSizeField];
          elementBox[elementAxis + 1] = elementStart;
          elementBox[elementAxis + 2] = elementStart + elementSize2[elementSizeField];
          element.reflow(elementBox);
          elementStart += elementSize2[elementSizeField] + this$1.elementSpacing;
        }
        groupStart += group.groupSize + this$1.groupSpacing;
      }
      box[groupAxis + 1] = groupsStart;
      box[groupAxis + 2] = groupsStart + groupsSize;
      box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;
    }
  };
  FloatElement2.prototype.alignStart = function alignStart(size, maxSize) {
    var start = 0;
    var align = this.options.align;
    if (align === RIGHT || align === BOTTOM) {
      start = maxSize - size;
    } else if (align === CENTER) {
      start = (maxSize - size) / 2;
    }
    return start;
  };
  FloatElement2.prototype.groupOptions = function groupOptions() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var children = ref2.children;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var elementSpacing = ref2.elementSpacing;
    var groupSpacing = ref2.groupSpacing;
    var maxSize = round(box[elementSizeField]());
    var childrenCount = children.length;
    var groups = [];
    var groupSize = 0;
    var groupElementsSize = 0;
    var groupsSize = 0;
    var maxGroupElementsSize = 0;
    var groupElements = [];
    for (var idx = 0; idx < childrenCount; idx++) {
      var element = children[idx];
      if (!element.box) {
        element.reflow(box);
      }
      var elementSize2 = this$1.elementSize(element);
      if (this$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize2[elementSizeField]) > maxSize) {
        groups.push({
          groupElements,
          groupSize,
          groupElementsSize
        });
        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
        groupsSize += groupSpacing + groupSize;
        groupSize = 0;
        groupElementsSize = 0;
        groupElements = [];
      }
      groupSize = Math.max(groupSize, elementSize2[groupSizeField]);
      if (groupElementsSize > 0) {
        groupElementsSize += elementSpacing;
      }
      groupElementsSize += elementSize2[elementSizeField];
      groupElements.push(element);
    }
    groups.push({
      groupElements,
      groupSize,
      groupElementsSize
    });
    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
    groupsSize += groupSize;
    return {
      groups,
      groupsSize,
      maxGroupElementsSize
    };
  };
  FloatElement2.prototype.elementSize = function elementSize2(element) {
    return {
      width: element.box.width(),
      height: element.box.height()
    };
  };
  FloatElement2.prototype.createVisual = function createVisual() {
  };
  return FloatElement2;
}(chart_element_default);
setDefaultOptions(FloatElement, {
  vertical: true,
  wrap: true,
  vSpacing: 0,
  spacing: 0
});
var float_element_default = FloatElement;

// node_modules/@progress/kendo-charts/dist/es/core/text.js
var DrawingText = drawing_exports.Text;
var Text = function(ChartElement2) {
  function Text3(content, options) {
    ChartElement2.call(this, options);
    this.content = content;
    this.reflow(new box_default());
  }
  if (ChartElement2) Text3.__proto__ = ChartElement2;
  Text3.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Text3.prototype.constructor = Text3;
  Text3.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var size = options.size = drawing_exports.util.measureText(this.content, { font: options.font });
    this.baseline = size.baseline;
    this.box = new box_default(
      targetBox.x1,
      targetBox.y1,
      targetBox.x1 + size.width,
      targetBox.y1 + size.height
    );
  };
  Text3.prototype.createVisual = function createVisual() {
    var ref2 = this.options;
    var font = ref2.font;
    var color = ref2.color;
    var opacity = ref2.opacity;
    var cursor = ref2.cursor;
    var stroke = ref2.stroke;
    var paintOrder = ref2.paintOrder;
    this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {
      font,
      fill: { color, opacity },
      cursor,
      stroke,
      paintOrder
    });
  };
  return Text3;
}(chart_element_default);
setDefaultOptions(Text, {
  font: DEFAULT_FONT,
  color: BLACK
});
var text_default = Text;

// node_modules/@progress/kendo-charts/dist/es/core/utils/rect-to-box.js
function rectToBox(rect) {
  var origin = rect.origin;
  var bottomRight = rect.bottomRight();
  return new box_default(origin.x, origin.y, bottomRight.x, bottomRight.y);
}

// node_modules/@progress/kendo-charts/dist/es/core/text-box.js
var ROWS_SPLIT_REGEX = /\n/m;
var TextBox = function(BoxElement2) {
  function TextBox2(content, options, data) {
    BoxElement2.call(this, options);
    this.content = content;
    this.data = data;
    this._initContainer();
    if (this.options._autoReflow !== false) {
      this.reflow(new box_default());
    }
  }
  if (BoxElement2) TextBox2.__proto__ = BoxElement2;
  TextBox2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  TextBox2.prototype.constructor = TextBox2;
  TextBox2.prototype._initContainer = function _initContainer() {
    var options = this.options;
    var rows = String(this.content).split(ROWS_SPLIT_REGEX);
    var floatElement = new float_element_default({ vertical: true, align: options.align, wrap: false });
    var textOptions = deepExtend({}, options, { opacity: 1, animation: null });
    this.container = floatElement;
    this.append(floatElement);
    for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
      var text = new text_default(rows[rowIdx].trim(), textOptions);
      floatElement.append(text);
    }
  };
  TextBox2.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var visualFn = options.visual;
    this.container.options.align = options.align;
    if (visualFn && !this._boxReflow) {
      var visualBox = targetBox;
      if (!visualBox.hasSize()) {
        this._boxReflow = true;
        this.reflow(visualBox);
        this._boxReflow = false;
        visualBox = this.box;
      }
      var visual = this.visual = visualFn(this.visualContext(visualBox));
      if (visual) {
        visualBox = rectToBox(visual.clippedBBox() || new geometry_exports.Rect());
        visual.options.zIndex = options.zIndex;
      }
      this.box = this.contentBox = this.paddingBox = visualBox;
    } else {
      BoxElement2.prototype.reflow.call(this, targetBox);
      if (options.rotation) {
        var margin = getSpacing(options.margin);
        var box = this.box.unpad(margin);
        this.targetBox = targetBox;
        this.normalBox = box.clone();
        box = this.rotate();
        box.translate(margin.left - margin.right, margin.top - margin.bottom);
        this.rotatedBox = box.clone();
        box.pad(margin);
      }
    }
  };
  TextBox2.prototype.createVisual = function createVisual() {
    var options = this.options;
    this.visual = new drawing_exports.Group({
      transform: this.rotationTransform(),
      zIndex: options.zIndex,
      noclip: options.noclip
    });
    if (this.hasBox()) {
      var box = drawing_exports.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());
      this.visual.append(box);
    }
  };
  TextBox2.prototype.renderVisual = function renderVisual() {
    if (!this.options.visible) {
      return;
    }
    if (this.options.visual) {
      var visual = this.visual;
      if (visual && !defined(visual.options.noclip)) {
        visual.options.noclip = this.options.noclip;
      }
      this.addVisual();
      this.createAnimation();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  TextBox2.prototype.visualContext = function visualContext(targetBox) {
    var this$1 = this;
    var context = {
      text: this.content,
      rect: targetBox.toRect(),
      sender: this.getSender(),
      options: this.options,
      createVisual: function() {
        this$1._boxReflow = true;
        this$1.reflow(targetBox);
        this$1._boxReflow = false;
        return this$1.getDefaultVisual();
      }
    };
    if (this.data) {
      Object.assign(context, this.data);
    }
    return context;
  };
  TextBox2.prototype.getDefaultVisual = function getDefaultVisual() {
    this.createVisual();
    this.renderChildren();
    var visual = this.visual;
    delete this.visual;
    return visual;
  };
  TextBox2.prototype.rotate = function rotate() {
    var options = this.options;
    this.box.rotate(options.rotation);
    this.align(this.targetBox, X, options.align);
    this.align(this.targetBox, Y, options.vAlign);
    return this.box;
  };
  TextBox2.prototype.rotationTransform = function rotationTransform() {
    var rotation = this.options.rotation;
    if (!rotation) {
      return null;
    }
    var ref2 = this.normalBox.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var boxCenter = this.rotatedBox.center();
    return geometry_exports.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);
  };
  return TextBox2;
}(box_element_default);
var text_box_default = TextBox;

// node_modules/@progress/kendo-charts/dist/es/core/title.js
var Title = function(ChartElement2) {
  function Title3(options) {
    ChartElement2.call(this, options);
    this._textBox = new text_box_default(this.options.text, Object.assign({}, this.options, {
      vAlign: this.options.position
    }));
    this.append(this._textBox);
  }
  if (ChartElement2) Title3.__proto__ = ChartElement2;
  Title3.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Title3.prototype.constructor = Title3;
  Title3.prototype.reflow = function reflow(targetBox) {
    ChartElement2.prototype.reflow.call(this, targetBox);
    this.box.snapTo(targetBox, X);
  };
  Title3.buildTitle = function buildTitle(options, defaultOptions) {
    var titleOptions = options;
    if (typeof options === "string") {
      titleOptions = { text: options };
    }
    titleOptions = Object.assign({ visible: true }, defaultOptions, titleOptions);
    var title3;
    if (titleOptions && titleOptions.visible && titleOptions.text) {
      title3 = new Title3(titleOptions);
    }
    return title3;
  };
  Title3.orderTitles = function orderTitles(titles) {
    var items = [].concat(titles);
    var top = items.filter(function(item) {
      return item && item.options.position !== BOTTOM;
    });
    var bottom = items.filter(function(item) {
      return item && item.options.position === BOTTOM;
    });
    collapseVerticalMargins(top);
    collapseVerticalMargins(bottom);
    bottom.reverse();
    return top.concat(bottom);
  };
  return Title3;
}(chart_element_default);
function collapseVerticalMargins(items) {
  for (var i36 = 1; i36 < items.length; i36++) {
    var box = items[i36]._textBox;
    var prevBox = items[i36 - 1]._textBox;
    prevBox.options.margin = Object.assign(getSpacing(prevBox.options.margin), { bottom: 0 });
    box.options.margin = Object.assign(getSpacing(box.options.margin), { top: 0 });
  }
}
setDefaultOptions(Title, {
  color: BLACK,
  position: TOP,
  align: CENTER,
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var title_default = Title;

// node_modules/@progress/kendo-charts/dist/es/core/axis-label.js
var AxisLabel = function(TextBox2) {
  function AxisLabel2(value2, text, index, dataItem, options) {
    TextBox2.call(this, text, options);
    this.text = text;
    this.value = value2;
    this.index = index;
    this.dataItem = dataItem;
    this.reflow(new box_default());
  }
  if (TextBox2) AxisLabel2.__proto__ = TextBox2;
  AxisLabel2.prototype = Object.create(TextBox2 && TextBox2.prototype);
  AxisLabel2.prototype.constructor = AxisLabel2;
  AxisLabel2.prototype.visualContext = function visualContext(targetBox) {
    var context = TextBox2.prototype.visualContext.call(this, targetBox);
    context.value = this.value;
    context.dataItem = this.dataItem;
    context.format = this.options.format;
    context.culture = this.options.culture;
    return context;
  };
  AxisLabel2.prototype.click = function click(widget, e39) {
    widget.trigger(AXIS_LABEL_CLICK, {
      element: eventElement(e39),
      value: this.value,
      text: this.text,
      index: this.index,
      dataItem: this.dataItem,
      axis: this.parent.options
    });
  };
  AxisLabel2.prototype.rotate = function rotate() {
    if (this.options.alignRotation !== CENTER) {
      var box = this.normalBox.toRect();
      var transform = this.rotationTransform();
      this.box = rectToBox(box.bbox(transform.matrix()));
    } else {
      TextBox2.prototype.rotate.call(this);
    }
    return this.box;
  };
  AxisLabel2.prototype.rotationTransform = function rotationTransform() {
    var options = this.options;
    var rotation = options.rotation;
    if (!rotation) {
      return null;
    }
    if (options.alignRotation === CENTER) {
      return TextBox2.prototype.rotationTransform.call(this);
    }
    var rotationMatrix = geometry_exports.transform().rotate(rotation).matrix();
    var box = this.normalBox.toRect();
    var rect = this.targetBox.toRect();
    var rotationOrigin = options.rotationOrigin || TOP;
    var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;
    var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;
    var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();
    var topLeft = box.topLeft().transformCopy(rotationMatrix);
    var topRight = box.topRight().transformCopy(rotationMatrix);
    var bottomRight = box.bottomRight().transformCopy(rotationMatrix);
    var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);
    var rotatedBox = geometry_exports.Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);
    var translate2 = {};
    translate2[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];
    var distanceLeft = Math.abs(topLeft[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var distanceRight = Math.abs(topRight[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var alignStart, alignEnd;
    if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {
      alignStart = topLeft;
      alignEnd = topRight;
    } else if (distanceRight < distanceLeft) {
      alignStart = topRight;
      alignEnd = bottomRight;
    } else {
      alignStart = topLeft;
      alignEnd = bottomLeft;
    }
    var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;
    translate2[alignAxis] = rect.center()[alignAxis] - alignCenter;
    return geometry_exports.transform().translate(translate2.x, translate2.y).rotate(rotation);
  };
  return AxisLabel2;
}(text_box_default);
setDefaultOptions(AxisLabel, {
  _autoReflow: false
});
var axis_label_default = AxisLabel;

// node_modules/@progress/kendo-charts/dist/es/core/note.js
var DEFAULT_ICON_SIZE = 7;
var DEFAULT_LABEL_COLOR = "#fff";
var Note = function(BoxElement2) {
  function Note2(fields, options, chartService) {
    BoxElement2.call(this, options);
    this.fields = fields;
    this.chartService = chartService;
    this.render();
  }
  if (BoxElement2) Note2.__proto__ = BoxElement2;
  Note2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Note2.prototype.constructor = Note2;
  Note2.prototype.hide = function hide2() {
    this.options.visible = false;
  };
  Note2.prototype.show = function show2() {
    this.options.visible = true;
  };
  Note2.prototype.render = function render() {
    var this$1 = this;
    var options = this.options;
    if (options.visible) {
      var label = options.label;
      var icon = options.icon;
      var box = new box_default();
      var childAlias = function() {
        return this$1;
      };
      var size = icon.size;
      var text = this.fields.text;
      var width, height;
      if (defined(label) && label.visible) {
        var noteTemplate = getTemplate(label);
        if (noteTemplate) {
          text = noteTemplate(this.fields);
        } else if (label.format) {
          text = this.chartService.format.auto(label.format, text);
        }
        if (!label.color) {
          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;
        }
        this.label = new text_box_default(text, deepExtend({}, label));
        this.label.aliasFor = childAlias;
        if (label.position === INSIDE && !defined(size)) {
          if (icon.type === CIRCLE) {
            size = Math.max(this.label.box.width(), this.label.box.height());
          } else {
            width = this.label.box.width();
            height = this.label.box.height();
          }
          box.wrap(this.label.box);
        }
      }
      icon.width = width || size || DEFAULT_ICON_SIZE;
      icon.height = height || size || DEFAULT_ICON_SIZE;
      var marker = new shape_element_default(deepExtend({}, icon));
      marker.aliasFor = childAlias;
      this.marker = marker;
      this.append(marker);
      if (this.label) {
        this.append(this.label);
      }
      marker.reflow(new box_default());
      this.wrapperBox = box.wrap(marker.box);
    }
  };
  Note2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var label = ref2.label;
    var marker = ref2.marker;
    var wrapperBox = ref2.wrapperBox;
    var center = targetBox.center();
    var length = options.line.length;
    var position = options.position;
    if (options.visible) {
      var lineStart, box, contentBox;
      if (inArray(position, [LEFT, RIGHT])) {
        if (position === LEFT) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x1, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x2, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x2, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x1, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      } else {
        if (position === BOTTOM) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y2];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y1]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y1];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y2]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      }
      if (marker) {
        marker.reflow(contentBox);
      }
      if (label) {
        label.reflow(contentBox);
        if (marker) {
          if (options.label.position === OUTSIDE) {
            label.box.alignTo(marker.box, position);
          }
          label.reflow(label.box);
        }
      }
      this.contentBox = contentBox;
      this.targetBox = targetBox;
      this.box = box || contentBox;
    }
  };
  Note2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    this.visual.options.noclip = this.options.noclip;
    if (this.options.visible) {
      this.createLine();
    }
  };
  Note2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options = this.options;
    var customVisual = options.visual;
    if (options.visible && customVisual) {
      this.visual = customVisual(Object.assign(this.fields, {
        sender: this.getSender(),
        rect: this.targetBox.toRect(),
        options: {
          background: options.background,
          border: options.background,
          icon: options.icon,
          label: options.label,
          line: options.line,
          position: options.position,
          visible: options.visible
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      }));
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  Note2.prototype.createLine = function createLine() {
    var options = this.options.line;
    if (this.linePoints) {
      var path = drawing_exports.Path.fromPoints(this.linePoints, {
        stroke: {
          color: options.color,
          width: options.width,
          dashType: options.dashType
        }
      });
      alignPathToPixel(path);
      this.visual.append(path);
    }
  };
  Note2.prototype.click = function click(widget, e39) {
    var args = this.eventArgs(e39);
    if (!widget.trigger(NOTE_CLICK, args)) {
      e39.preventDefault();
    }
  };
  Note2.prototype.over = function over(widget, e39) {
    var args = this.eventArgs(e39);
    if (!widget.trigger(NOTE_HOVER, args)) {
      e39.preventDefault();
    }
  };
  Note2.prototype.out = function out(widget, e39) {
    var args = this.eventArgs(e39);
    widget.trigger(NOTE_LEAVE, args);
  };
  Note2.prototype.eventArgs = function eventArgs(e39) {
    var options = this.options;
    return Object.assign(this.fields, {
      element: eventElement(e39),
      text: defined(options.label) ? options.label.text : "",
      visual: this.visual
    });
  };
  return Note2;
}(box_element_default);
setDefaultOptions(Note, {
  icon: {
    visible: true,
    type: CIRCLE
  },
  label: {
    position: INSIDE,
    visible: true,
    align: CENTER,
    vAlign: CENTER
  },
  line: {
    visible: true
  },
  visible: true,
  position: TOP,
  zIndex: 2
});
var note_default = Note;

// node_modules/@progress/kendo-charts/dist/es/services/intl-service.js
var defaultImplementation = {
  format: function(format, value2) {
    return value2;
  },
  toString: function(value2) {
    return value2;
  },
  parseDate: function(value2) {
    return new Date(value2);
  },
  firstDay: function() {
    return 0;
  }
};
var current2 = defaultImplementation;
var IntlService = function IntlService2() {
};
var staticAccessors = { implementation: { configurable: true } };
IntlService.register = function register2(userImplementation) {
  current2 = userImplementation;
};
staticAccessors.implementation.get = function() {
  return current2;
};
Object.defineProperties(IntlService, staticAccessors);
var intl_service_default = IntlService;

// node_modules/@progress/kendo-charts/dist/es/services/format-service.js
var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;
var FormatService = function FormatService2(intlService) {
  this._intlService = intlService;
};
var prototypeAccessors2 = { intl: { configurable: true } };
prototypeAccessors2.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors2.intl.set = function(value2) {
  this._intlService = value2;
};
FormatService.prototype.auto = function auto(formatString) {
  var values5 = [], len = arguments.length - 1;
  while (len-- > 0) values5[len] = arguments[len + 1];
  var intl = this.intl;
  if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
    return intl.format.apply(intl, [formatString].concat(values5));
  }
  return intl.toString(values5[0], formatString);
};
FormatService.prototype.localeAuto = function localeAuto(formatString, values5, locale) {
  var intl = this.intl;
  var result;
  if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
    result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {
      var value2 = values5[parseInt(index, 10)];
      return intl.toString(value2, placeholderFormat ? placeholderFormat.substring(1) : "", locale);
    });
  } else {
    result = intl.toString(values5[0], formatString, locale);
  }
  return result;
};
Object.defineProperties(FormatService.prototype, prototypeAccessors2);
var format_service_default = FormatService;

// node_modules/@progress/kendo-charts/dist/es/services/chart-service.js
var ChartService = function ChartService2(chart, context) {
  if (context === void 0) context = {};
  this._intlService = context.intlService;
  this.sender = context.sender || chart;
  this.format = new format_service_default(context.intlService);
  this.chart = chart;
  this.rtl = Boolean(context.rtl);
};
var prototypeAccessors3 = { intl: { configurable: true } };
prototypeAccessors3.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors3.intl.set = function(value2) {
  this._intlService = value2;
  this.format.intl = value2;
};
ChartService.prototype.notify = function notify(name2, args) {
  if (this.chart) {
    this.chart.trigger(name2, args);
  }
};
ChartService.prototype.isPannable = function isPannable(axis) {
  var pannable = ((this.chart || {}).options || {}).pannable;
  return pannable && pannable.lock !== axis;
};
Object.defineProperties(ChartService.prototype, prototypeAccessors3);
var chart_service_default = ChartService;

// node_modules/@progress/kendo-charts/dist/es/services/dom-events-builder.js
var current3;
var DomEventsBuilder = function DomEventsBuilder2() {
};
DomEventsBuilder.register = function register3(userImplementation) {
  current3 = userImplementation;
};
DomEventsBuilder.create = function create(element, events) {
  var builder;
  if (current3) {
    builder = current3.create(element, events);
  } else {
    builder = new user_events_default(element, Object.assign(
      {},
      { multiTouch: true },
      events
    ));
  }
  return builder;
};
var dom_events_builder_default = DomEventsBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-tick.js
function createAxisTick(options, tickOptions) {
  var tickX = options.tickX;
  var tickY = options.tickY;
  var position = options.position;
  var tick = new drawing_exports.Path({
    stroke: {
      width: tickOptions.width,
      color: tickOptions.color
    }
  });
  if (options.vertical) {
    tick.moveTo(tickX, position).lineTo(tickX + tickOptions.size, position);
  } else {
    tick.moveTo(position, tickY).lineTo(position, tickY + tickOptions.size);
  }
  alignPathToPixel(tick);
  return tick;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-grid-line.js
function createAxisGridLine(options, gridLine) {
  var lineStart = options.lineStart;
  var lineEnd = options.lineEnd;
  var position = options.position;
  var line = new drawing_exports.Path({
    stroke: {
      width: gridLine.width,
      color: gridLine.color,
      dashType: gridLine.dashType
    }
  });
  if (options.vertical) {
    line.moveTo(lineStart, position).lineTo(lineEnd, position);
  } else {
    line.moveTo(position, lineStart).lineTo(position, lineEnd);
  }
  alignPathToPixel(line);
  return line;
}

// node_modules/@progress/kendo-charts/dist/es/core/axis.js
var Axis = function(ChartElement2) {
  function Axis2(options, chartService) {
    if (chartService === void 0) chartService = new chart_service_default();
    ChartElement2.call(this, options);
    this.chartService = chartService;
    if (!this.options.visible) {
      this.options = deepExtend({}, this.options, {
        labels: {
          visible: false
        },
        line: {
          visible: false
        },
        margin: 0,
        majorTickSize: 0,
        minorTickSize: 0
      });
    }
    this.options.minorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.minorTickType !== NONE
    }, this.options.minorTicks, {
      size: this.options.minorTickSize,
      align: this.options.minorTickType
    });
    this.options.majorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.majorTickType !== NONE
    }, this.options.majorTicks, {
      size: this.options.majorTickSize,
      align: this.options.majorTickType
    });
    this.initFields();
    if (!this.options._deferLabels) {
      this.createLabels();
    }
    this.createTitle();
    this.createNotes();
  }
  if (ChartElement2) Axis2.__proto__ = ChartElement2;
  Axis2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Axis2.prototype.constructor = Axis2;
  Axis2.prototype.initFields = function initFields() {
  };
  Axis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.labelsCount()
    };
  };
  Axis2.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {
    var rotation = labelOptions.rotation;
    if (isObject(rotation)) {
      labelOptions.alignRotation = rotation.align;
      labelOptions.rotation = rotation.angle;
    }
  };
  Axis2.prototype.createLabels = function createLabels() {
    var this$1 = this;
    var options = this.options;
    var align = options.vertical ? RIGHT : CENTER;
    var labelOptions = deepExtend({}, options.labels, {
      align,
      zIndex: options.zIndex
    });
    var step = Math.max(1, labelOptions.step);
    this.clearLabels();
    if (labelOptions.visible) {
      this.normalizeLabelRotation(labelOptions);
      if (labelOptions.rotation === "auto") {
        labelOptions.rotation = 0;
        options.autoRotateLabels = true;
      }
      var range = this.labelsRange();
      for (var idx = range.min; idx < range.max; idx += step) {
        var labelContext = { index: idx, count: range.max };
        var label = this$1.createAxisLabel(idx, labelOptions, labelContext);
        if (label) {
          this$1.append(label);
          this$1.labels.push(label);
        }
      }
    }
  };
  Axis2.prototype.clearLabels = function clearLabels() {
    this.children = grep(this.children, function(child) {
      return !(child instanceof axis_label_default);
    });
    this.labels = [];
  };
  Axis2.prototype.clearTitle = function clearTitle() {
    var this$1 = this;
    if (this.title) {
      this.children = grep(this.children, function(child) {
        return child !== this$1.title;
      });
      this.title = void 0;
    }
  };
  Axis2.prototype.clear = function clear3() {
    this.clearLabels();
    this.clearTitle();
  };
  Axis2.prototype.lineBox = function lineBox() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var axisX = mirror ? box.x1 : box.x2;
    var axisY = mirror ? box.y2 : box.y1;
    var lineWidth = options.line.width || 0;
    return vertical ? new box_default(axisX, box.y1, axisX, box.y2 - lineWidth) : new box_default(box.x1, axisY, box.x2 - lineWidth, axisY);
  };
  Axis2.prototype.createTitle = function createTitle() {
    var options = this.options;
    var titleOptions = deepExtend({
      rotation: options.vertical ? -90 : 0,
      text: "",
      zIndex: 1,
      visualSize: true
    }, options.title);
    if (titleOptions.visible && titleOptions.text) {
      var title3 = new text_box_default(titleOptions.text, titleOptions);
      this.append(title3);
      this.title = title3;
    }
  };
  Axis2.prototype.createNotes = function createNotes() {
    var this$1 = this;
    var options = this.options;
    var notes3 = options.notes;
    var items = notes3.data || [];
    this.notes = [];
    for (var i36 = 0; i36 < items.length; i36++) {
      var item = deepExtend({}, notes3, items[i36]);
      item.value = this$1.parseNoteValue(item.value);
      var note = new note_default({
        value: item.value,
        text: item.label.text,
        dataItem: item
      }, item, this$1.chartService);
      if (note.options.visible) {
        if (defined(note.options.position)) {
          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        } else {
          if (options.vertical) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        }
        this$1.append(note);
        this$1.notes.push(note);
      }
    }
  };
  Axis2.prototype.parseNoteValue = function parseNoteValue(value2) {
    return value2;
  };
  Axis2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    this.createPlotBands();
  };
  Axis2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.createBackground();
    this.createLine();
  };
  Axis2.prototype.gridLinesVisual = function gridLinesVisual() {
    var gridLines = this._gridLines;
    if (!gridLines) {
      gridLines = this._gridLines = new drawing_exports.Group({
        zIndex: -2
      });
      this.appendVisual(this._gridLines);
    }
    return gridLines;
  };
  Axis2.prototype.createTicks = function createTicks(lineGroup) {
    var options = this.options;
    var lineBox = this.lineBox();
    var mirror = options.labels.mirror;
    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical: options.vertical
    };
    function render(tickPositions, tickOptions, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, tickOptions.step);
      if (tickOptions.visible) {
        for (var i36 = tickOptions.skip; i36 < count; i36 += step) {
          if (defined(skipUnit) && i36 % skipUnit === 0) {
            continue;
          }
          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
          tickLineOptions.position = tickPositions[i36];
          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
        }
      }
    }
    render(this.getMajorTickPositions(), options.majorTicks);
    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);
  };
  Axis2.prototype.createLine = function createLine() {
    var options = this.options;
    var line = options.line;
    var lineBox = this.lineBox();
    if (line.width > 0 && line.visible) {
      var path = new drawing_exports.Path({
        stroke: {
          width: line.width,
          color: line.color,
          dashType: line.dashType
        }
        /* TODO
        zIndex: line.zIndex,
        */
      });
      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      if (options._alignLines) {
        alignPathToPixel(path);
      }
      var group = this._lineGroup = new drawing_exports.Group();
      group.append(path);
      this.visual.append(group);
      this.createTicks(group);
    }
  };
  Axis2.prototype.getActualTickSize = function getActualTickSize() {
    var options = this.options;
    var tickSize = 0;
    if (options.majorTicks.visible && options.minorTicks.visible) {
      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);
    } else if (options.majorTicks.visible) {
      tickSize = options.majorTicks.size;
    } else if (options.minorTicks.visible) {
      tickSize = options.minorTicks.size;
    }
    return tickSize;
  };
  Axis2.prototype.createBackground = function createBackground() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var background = options.background;
    if (background) {
      this._backgroundPath = drawing_exports.Path.fromRect(box.toRect(), {
        fill: {
          color: background
        },
        stroke: null
      });
      this.visual.append(this._backgroundPath);
    }
  };
  Axis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var options = this.options;
    var plotBands = options.plotBands || [];
    var vertical = options.vertical;
    var plotArea = this.plotArea;
    if (plotBands.length === 0) {
      return;
    }
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    var altAxis = grep(this.pane.axes, function(axis) {
      return axis.options.vertical !== this$1.options.vertical;
    })[0];
    for (var idx = 0; idx < plotBands.length; idx++) {
      var item = plotBands[idx];
      var slotX = void 0, slotY = void 0;
      var labelOptions = item.label;
      var label = void 0;
      if (vertical) {
        slotX = (altAxis || plotArea.axisX).lineBox();
        slotY = this$1.getSlot(item.from, item.to, true);
      } else {
        slotX = this$1.getSlot(item.from, item.to, true);
        slotY = (altAxis || plotArea.axisY).lineBox();
      }
      if (labelOptions) {
        labelOptions.vAlign = labelOptions.position || LEFT;
        label = this$1.createPlotBandLabel(
          labelOptions,
          item,
          new box_default(
            slotX.x1,
            slotY.y1,
            slotX.x2,
            slotY.y2
          )
        );
      }
      if (slotX.width() !== 0 && slotY.height() !== 0) {
        var bandRect = new geometry_exports.Rect(
          [slotX.x1, slotY.y1],
          [slotX.width(), slotY.height()]
        );
        var path = drawing_exports.Path.fromRect(bandRect, {
          fill: {
            color: item.color,
            opacity: item.opacity
          },
          stroke: null
        });
        group.append(path);
        if (label) {
          group.append(label);
        }
      }
    }
    this.appendVisual(group);
  };
  Axis2.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {
    if (label.visible === false) {
      return null;
    }
    var text = label.text;
    var textbox;
    if (defined(label) && label.visible) {
      var labelTemplate = getTemplate(label);
      if (labelTemplate) {
        text = labelTemplate({ text, item });
      } else if (label.format) {
        text = this.chartService.format.auto(label.format, text);
      }
      if (!label.color) {
        label.color = this.options.labels.color;
      }
    }
    textbox = new text_box_default(text, label);
    textbox.reflow(box);
    textbox.renderVisual();
    return textbox.visual;
  };
  Axis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options = this.options;
    var minorGridLines = options.minorGridLines;
    var majorGridLines = options.majorGridLines;
    var minorUnit = options.minorUnit;
    var vertical = options.vertical;
    var axisLineVisible = altAxis.options.line.visible;
    var majorUnit = majorGridLines.visible ? options.majorUnit : 0;
    var lineBox = altAxis.lineBox();
    var linePos = lineBox[vertical ? "y1" : "x1"];
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPositions, gridLine, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, gridLine.step);
      if (gridLine.visible) {
        for (var i36 = gridLine.skip; i36 < count; i36 += step) {
          var pos = round(tickPositions[i36]);
          if (!inArray(pos, majorTicks)) {
            if (i36 % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
              lineOptions.position = pos;
              container.append(createAxisGridLine(lineOptions, gridLine));
              majorTicks.push(pos);
            }
          }
        }
      }
    }
    render(this.getMajorTickPositions(), majorGridLines);
    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);
    return container.children;
  };
  Axis2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var labels = ref2.labels;
    var title3 = ref2.title;
    var vertical = options.vertical;
    var count = labels.length;
    var sizeFn = vertical ? WIDTH : HEIGHT;
    var titleSize = title3 ? title3.box[sizeFn]() : 0;
    var space = this.getActualTickSize() + options.margin + titleSize;
    var rootBox = (this.getRoot() || {}).box || box;
    var boxSize = rootBox[sizeFn]();
    var maxLabelSize = 0;
    for (var i36 = 0; i36 < count; i36++) {
      var labelSize = labels[i36].box[sizeFn]();
      if (labelSize + space <= boxSize) {
        maxLabelSize = Math.max(maxLabelSize, labelSize);
      }
    }
    if (vertical) {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x1 + maxLabelSize + space,
        box.y2
      );
    } else {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x2,
        box.y1 + maxLabelSize + space
      );
    }
    this.arrangeTitle();
    this.arrangeLabels();
    this.arrangeNotes();
  };
  Axis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getMajorTickPositions();
  };
  Axis2.prototype.labelTickIndex = function labelTickIndex(label) {
    return label.index;
  };
  Axis2.prototype.arrangeLabels = function arrangeLabels() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var labels = ref2.labels;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var tickPositions = this.getLabelsTickPositions();
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var labelSize = vertical ? label.box.height() : label.box.width();
      var firstTickPosition = tickPositions[tickIx];
      var nextTickPosition = tickPositions[tickIx + 1];
      var positionStart = void 0, positionEnd = void 0;
      if (vertical) {
        if (labelsBetweenTicks) {
          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
          positionStart = middle - labelSize / 2;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
        }
        positionEnd = positionStart;
      } else {
        if (labelsBetweenTicks) {
          positionStart = firstTickPosition;
          positionEnd = nextTickPosition;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
          positionEnd = positionStart + labelSize;
        }
      }
      this$1.positionLabel(label, mirror, positionStart, positionEnd);
    }
  };
  Axis2.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {
    if (positionEnd === void 0) positionEnd = positionStart;
    var options = this.options;
    var vertical = options.vertical;
    var lineBox = this.lineBox();
    var labelOffset = this.getActualTickSize() + options.margin;
    var labelBox;
    if (vertical) {
      var labelX = lineBox.x2;
      if (mirror) {
        labelX += labelOffset;
        label.options.rotationOrigin = LEFT;
      } else {
        labelX -= labelOffset + label.box.width();
        label.options.rotationOrigin = RIGHT;
      }
      labelBox = label.box.move(labelX, positionStart);
    } else {
      var labelY = lineBox.y1;
      if (mirror) {
        labelY -= labelOffset + label.box.height();
        label.options.rotationOrigin = BOTTOM;
      } else {
        labelY += labelOffset;
        label.options.rotationOrigin = TOP;
      }
      labelBox = new box_default(
        positionStart,
        labelY,
        positionEnd,
        labelY + label.box.height()
      );
    }
    label.reflow(labelBox);
  };
  Axis2.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {
    if (labelBox.width() < slotWidth) {
      return 0;
    }
    if (labelBox.height() > slotWidth) {
      return -90;
    }
    return -45;
  };
  Axis2.prototype.autoRotateLabels = function autoRotateLabels() {
    var this$1 = this;
    if (!this.options.autoRotateLabels || this.options.vertical) {
      return false;
    }
    var tickPositions = this.getMajorTickPositions();
    var labels = this.labels;
    var limit = Math.min(labels.length, tickPositions.length - 1);
    var angle = 0;
    for (var idx = 0; idx < limit; idx++) {
      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);
      var labelBox = labels[idx].box;
      var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);
      if (labelAngle !== 0) {
        angle = labelAngle;
      }
      if (angle === -90) {
        break;
      }
    }
    if (angle !== 0) {
      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {
        labels[idx$1].options.rotation = angle;
        labels[idx$1].reflow(new box_default());
      }
      return true;
    }
  };
  Axis2.prototype.arrangeTitle = function arrangeTitle() {
    var ref2 = this;
    var options = ref2.options;
    var title3 = ref2.title;
    var mirror = options.labels.mirror;
    var vertical = options.vertical;
    if (title3) {
      if (vertical) {
        title3.options.align = mirror ? RIGHT : LEFT;
        title3.options.vAlign = title3.options.position;
      } else {
        title3.options.align = title3.options.position;
        title3.options.vAlign = mirror ? TOP : BOTTOM;
      }
      title3.reflow(this.box);
    }
  };
  Axis2.prototype.arrangeNotes = function arrangeNotes() {
    var this$1 = this;
    for (var idx = 0; idx < this.notes.length; idx++) {
      var item = this$1.notes[idx];
      var value2 = item.options.value;
      var slot = void 0;
      if (defined(value2)) {
        if (this$1.shouldRenderNote(value2)) {
          item.show();
        } else {
          item.hide();
        }
        slot = this$1.noteSlot(value2);
      } else {
        item.hide();
      }
      item.reflow(slot || this$1.lineBox());
    }
  };
  Axis2.prototype.noteSlot = function noteSlot(value2) {
    return this.getSlot(value2);
  };
  Axis2.prototype.alignTo = function alignTo(secondAxis) {
    var lineBox = secondAxis.lineBox();
    var vertical = this.options.vertical;
    var pos = vertical ? Y : X;
    this.box.snapTo(lineBox, pos);
    if (vertical) {
      this.box.shrink(0, this.lineBox().height() - lineBox.height());
    } else {
      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
    }
    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
  };
  Axis2.prototype.axisLabelText = function axisLabelText(value2, options, context) {
    var this$1 = this;
    var text;
    var tmpl = getTemplate(options);
    var defaultText = function() {
      if (!options.format) {
        return value2;
      }
      return this$1.chartService.format.localeAuto(
        options.format,
        [value2],
        options.culture
      );
    };
    if (tmpl) {
      var templateContext = Object.assign({}, context, {
        get text() {
          return defaultText();
        },
        value: value2,
        format: options.format,
        culture: options.culture
      });
      text = tmpl(templateContext);
    } else {
      text = defaultText();
    }
    return text;
  };
  Axis2.prototype.slot = function slot(from, to, limit) {
    var slot2 = this.getSlot(from, to, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  Axis2.prototype.contentBox = function contentBox() {
    var box = this.box.clone();
    var labels = this.labels;
    if (labels.length) {
      var axis = this.options.vertical ? Y : X;
      if (this.chartService.isPannable(axis)) {
        var offset = this.maxLabelOffset();
        box[axis + 1] -= offset.start;
        box[axis + 2] += offset.end;
      } else {
        if (labels[0].options.visible) {
          box.wrap(labels[0].box);
        }
        var lastLabel = labels[labels.length - 1];
        if (lastLabel.options.visible) {
          box.wrap(lastLabel.box);
        }
      }
    }
    return box;
  };
  Axis2.prototype.maxLabelOffset = function maxLabelOffset() {
    var this$1 = this;
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var tickPositions = this.getLabelsTickPositions();
    var offsetField = vertical ? Y : X;
    var labels = this.labels;
    var startPosition = reverse ? 1 : 0;
    var endPosition = reverse ? 0 : 1;
    var maxStartOffset = 0;
    var maxEndOffset = 0;
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var startTick = void 0, endTick = void 0;
      if (labelsBetweenTicks) {
        startTick = tickPositions[tickIx + startPosition];
        endTick = tickPositions[tickIx + endPosition];
      } else {
        startTick = endTick = tickPositions[tickIx];
      }
      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);
      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);
    }
    return {
      start: maxStartOffset,
      end: maxEndOffset
    };
  };
  Axis2.prototype.limitRange = function limitRange(from, to, min4, max3, offset) {
    var options = this.options;
    if (from < min4 && offset < 0 && (!defined(options.min) || options.min <= min4) || max3 < to && offset > 0 && (!defined(options.max) || max3 <= options.max)) {
      return null;
    }
    if (to < min4 && offset > 0 || max3 < from && offset < 0) {
      return {
        min: from,
        max: to
      };
    }
    var rangeSize = to - from;
    var minValue = from;
    var maxValue = to;
    if (from < min4 && offset < 0) {
      minValue = limitValue(from, min4, max3);
      maxValue = limitValue(from + rangeSize, min4 + rangeSize, max3);
    } else if (to > max3 && offset > 0) {
      maxValue = limitValue(to, min4, max3);
      minValue = limitValue(to - rangeSize, min4, max3 - rangeSize);
    }
    return {
      min: minValue,
      max: maxValue
    };
  };
  Axis2.prototype.valueRange = function valueRange3() {
    return {
      min: this.seriesMin,
      max: this.seriesMax
    };
  };
  Axis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    return (vertical ? -1 : 1) * (reverse ? -1 : 1);
  };
  Axis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = this.lineDir();
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  Axis2.prototype.pointOffset = function pointOffset(point) {
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];
    var offset = relative / lineSize;
    return offset;
  };
  Axis2.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {
    var MAX_SCALE = 0.999;
    var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);
    var delta;
    if (scale > 0) {
      delta = range * Math.min(1, scale);
    } else {
      delta = range - range / (1 + scale);
    }
    return delta;
  };
  Axis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.options.justified;
  };
  Axis2.prototype.prepareUserOptions = function prepareUserOptions() {
  };
  return Axis2;
}(chart_element_default);
setDefaultOptions(Axis, {
  labels: {
    visible: true,
    rotation: 0,
    mirror: false,
    step: 1,
    skip: 0
  },
  line: {
    width: 1,
    color: BLACK,
    visible: true
  },
  title: {
    visible: true,
    position: CENTER
  },
  majorTicks: {
    align: OUTSIDE,
    size: 4,
    skip: 0,
    step: 1
  },
  minorTicks: {
    align: OUTSIDE,
    size: 3,
    skip: 0,
    step: 1
  },
  axisCrossingValue: 0,
  majorTickType: OUTSIDE,
  minorTickType: NONE,
  majorGridLines: {
    skip: 0,
    step: 1
  },
  minorGridLines: {
    visible: false,
    width: 1,
    color: BLACK,
    skip: 0,
    step: 1
  },
  // TODO: Move to line or labels options
  margin: 5,
  visible: true,
  reverse: false,
  justified: true,
  notes: {
    label: {
      text: ""
    }
  },
  _alignLines: true,
  _deferLabels: false
});
var axis_default = Axis;

// node_modules/@progress/kendo-charts/dist/es/date-utils/constants.js
var MILLISECONDS = "milliseconds";
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var DAYS = "days";
var WEEKS = "weeks";
var MONTHS = "months";
var YEARS = "years";
var TIME_PER_MILLISECOND = 1;
var TIME_PER_SECOND = 1e3;
var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;
var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;
var TIME_PER_DAY = 24 * TIME_PER_HOUR;
var TIME_PER_WEEK = 7 * TIME_PER_DAY;
var TIME_PER_MONTH = 31 * TIME_PER_DAY;
var TIME_PER_YEAR = 365 * TIME_PER_DAY;
var TIME_PER_UNIT = {
  "years": TIME_PER_YEAR,
  "months": TIME_PER_MONTH,
  "weeks": TIME_PER_WEEK,
  "days": TIME_PER_DAY,
  "hours": TIME_PER_HOUR,
  "minutes": TIME_PER_MINUTE,
  "seconds": TIME_PER_SECOND,
  "milliseconds": TIME_PER_MILLISECOND
};

// node_modules/@progress/kendo-charts/dist/es/date-utils/absolute-date-diff.js
function absoluteDateDiff(a38, b2) {
  var diff = a38.getTime() - b2;
  var offsetDiff = a38.getTimezoneOffset() - b2.getTimezoneOffset();
  return diff - offsetDiff * TIME_PER_MINUTE;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-ticks.js
function addTicks(date, ticks) {
  return new Date(date.getTime() + ticks);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-date.js
function toDate(value2) {
  var result;
  if (value2 instanceof Date) {
    result = value2;
  } else if (value2) {
    result = new Date(value2);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/start-of-week.js
function startOfWeek(date, weekStartDay) {
  if (weekStartDay === void 0) weekStartDay = 0;
  var daysToSubtract = 0;
  var day = date.getDay();
  if (!isNaN(day)) {
    while (day !== weekStartDay) {
      if (day === 0) {
        day = 6;
      } else {
        day--;
      }
      daysToSubtract++;
    }
  }
  return addTicks(date, -daysToSubtract * TIME_PER_DAY);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-duration.js
function adjustDST(date, hours) {
  if (hours === 0 && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
    return true;
  }
  return false;
}
function addHours(date, hours) {
  var roundedDate = new Date(date);
  roundedDate.setMinutes(0, 0, 0);
  var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;
  return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);
}
function addDuration(dateValue, value2, unit2, weekStartDay) {
  var result = dateValue;
  if (dateValue) {
    var date = toDate(dateValue);
    var hours = date.getHours();
    if (unit2 === YEARS) {
      result = new Date(date.getFullYear() + value2, 0, 1);
      adjustDST(result, 0);
    } else if (unit2 === MONTHS) {
      result = new Date(date.getFullYear(), date.getMonth() + value2, 1);
      adjustDST(result, hours);
    } else if (unit2 === WEEKS) {
      result = addDuration(startOfWeek(date, weekStartDay), value2 * 7, DAYS);
      adjustDST(result, hours);
    } else if (unit2 === DAYS) {
      result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value2);
      adjustDST(result, hours);
    } else if (unit2 === HOURS) {
      result = addHours(date, value2);
    } else if (unit2 === MINUTES) {
      result = addTicks(date, value2 * TIME_PER_MINUTE);
      if (result.getSeconds() > 0) {
        result.setSeconds(0);
      }
    } else if (unit2 === SECONDS) {
      result = addTicks(date, value2 * TIME_PER_SECOND);
    } else if (unit2 === MILLISECONDS) {
      result = addTicks(date, value2);
    }
    if (unit2 !== MILLISECONDS && result.getMilliseconds() > 0) {
      result.setMilliseconds(0);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/floor-date.js
function floorDate(date, unit2, weekStartDay) {
  return addDuration(toDate(date), 0, unit2, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/ceil-date.js
function ceilDate(dateValue, unit2, weekStartDay) {
  var date = toDate(dateValue);
  if (date && floorDate(date, unit2, weekStartDay).getTime() === date.getTime()) {
    return date;
  }
  return addDuration(date, 1, unit2, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-comparer.js
function dateComparer(a38, b2) {
  if (a38 && b2) {
    return a38.getTime() - b2.getTime();
  }
  return -1;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-diff.js
function dateDiff(a38, b2) {
  return a38.getTime() - b2;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-time.js
function toTime(value2) {
  if (isArray(value2)) {
    var result = [];
    for (var idx = 0; idx < value2.length; idx++) {
      result.push(toTime(value2[idx]));
    }
    return result;
  } else if (value2) {
    return toDate(value2).getTime();
  }
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-equals.js
function dateEquals(a38, b2) {
  if (a38 && b2) {
    return toTime(a38) === toTime(b2);
  }
  return a38 === b2;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-index.js
function timeIndex(date, start, baseUnit) {
  return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];
}
function dateIndex(value2, start, baseUnit, baseUnitStep) {
  var date = toDate(value2);
  var startDate = toDate(start);
  var index;
  if (baseUnit === MONTHS) {
    index = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  } else if (baseUnit === YEARS) {
    index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;
  } else if (baseUnit === DAYS || baseUnit === WEEKS) {
    index = timeIndex(date, startDate, baseUnit);
  } else {
    index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];
  }
  return index / baseUnitStep;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/duration.js
function duration(a38, b2, unit2) {
  var diff;
  if (unit2 === YEARS) {
    diff = b2.getFullYear() - a38.getFullYear();
  } else if (unit2 === MONTHS) {
    diff = duration(a38, b2, YEARS) * 12 + b2.getMonth() - a38.getMonth();
  } else if (unit2 === DAYS) {
    diff = Math.floor(dateDiff(b2, a38) / TIME_PER_DAY);
  } else {
    diff = Math.floor(dateDiff(b2, a38) / TIME_PER_UNIT[unit2]);
  }
  return diff;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-date.js
function parseDate(intlService, date) {
  var result;
  if (isString(date)) {
    result = intlService.parseDate(date) || toDate(date);
  } else {
    result = toDate(date);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-dates.js
function parseDates(intlService, dates) {
  if (isArray(dates)) {
    var result = [];
    for (var idx = 0; idx < dates.length; idx++) {
      result.push(parseDate(intlService, dates[idx]));
    }
    return result;
  }
  return parseDate(intlService, dates);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/first-day.js
function firstDay(options, intlService) {
  if (isNumber(options.weekStartDay)) {
    return options.weekStartDay;
  }
  if (intlService && intlService.firstDay) {
    return intlService.firstDay();
  }
  return 0;
}

// node_modules/@progress/kendo-charts/dist/es/core/category-axis.js
var MIN_CATEGORY_POINTS_RANGE = 0.01;
var MIN_CATEGORY_RANGE = 0.1;
function indexOf(value2, arr) {
  if (value2 instanceof Date) {
    var length = arr.length;
    for (var idx = 0; idx < length; idx++) {
      if (dateEquals(arr[idx], value2)) {
        return idx;
      }
    }
    return -1;
  }
  return arr.indexOf(value2);
}
var CategoryAxis = function(Axis2) {
  function CategoryAxis2() {
    Axis2.apply(this, arguments);
  }
  if (Axis2) CategoryAxis2.__proto__ = Axis2;
  CategoryAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  CategoryAxis2.prototype.constructor = CategoryAxis2;
  CategoryAxis2.prototype.initFields = function initFields() {
    this._ticks = {};
  };
  CategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    return "";
  };
  CategoryAxis2.prototype.clone = function clone3() {
    var copy = new CategoryAxis2(Object.assign({}, this.options, {
      categories: this.options.srcCategories
    }), this.chartService);
    copy.createLabels();
    return copy;
  };
  CategoryAxis2.prototype.initUserOptions = function initUserOptions(options) {
    var categories = options.categories || [];
    var definedMin = defined(options.min);
    var definedMax = defined(options.max);
    options.srcCategories = options.categories = categories;
    if ((definedMin || definedMax) && categories.length) {
      var min4 = definedMin ? Math.floor(options.min) : 0;
      var max3;
      if (definedMax) {
        max3 = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);
      } else {
        max3 = categories.length;
      }
      options.categories = options.categories.slice(min4, max3);
    }
    return options;
  };
  CategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    var options = this.options;
    var length = options.categories.length || 1;
    var min4 = isNumber(options.min) ? options.min % 1 : 0;
    var max3;
    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {
      max3 = length - (1 - options.max % 1);
    } else {
      max3 = length - (options.justified ? 1 : 0);
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.range = function range() {
    var options = this.options;
    var min4 = isNumber(options.min) ? options.min : 0;
    var max3 = isNumber(options.max) ? options.max : this.totalRange().max;
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.roundedRange = function roundedRange() {
    return this.range();
  };
  CategoryAxis2.prototype.totalRange = function totalRange() {
    var options = this.options;
    return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };
  };
  CategoryAxis2.prototype.scaleOptions = function scaleOptions() {
    var ref2 = this.rangeIndices();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var lineBox = this.lineBox();
    var size = this.options.vertical ? lineBox.height() : lineBox.width();
    var scale = size / (max3 - min4 || 1);
    return {
      scale: scale * (this.options.reverse ? -1 : 1),
      box: lineBox,
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    Axis2.prototype.arrangeLabels.call(this);
    this.hideOutOfRangeLabels();
  };
  CategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    var ref2 = this;
    var box = ref2.box;
    var labels = ref2.labels;
    if (labels.length > 0) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      var firstLabel = labels[0];
      var lastLabel = last(labels);
      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
        firstLabel.options.visible = false;
      }
      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
        lastLabel.options.visible = false;
      }
    }
  };
  CategoryAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTicks().majorTicks;
  };
  CategoryAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTicks().minorTicks;
  };
  CategoryAxis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getTicks().labelTicks;
  };
  CategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this.rangeIndices();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var limit = Math.ceil(max3);
    var current4 = Math.floor(min4);
    var indices = [];
    while (current4 <= limit) {
      indices.push(current4);
      current4 += stepSize;
    }
    return indices;
  };
  CategoryAxis2.prototype.getTickPositions = function getTickPositions(stepSize) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min4 = ref$1.min;
    var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];
    var indices = this.tickIndices(stepSize);
    var positions = [];
    for (var idx = 0; idx < indices.length; idx++) {
      positions.push(pos + round(scale * (indices[idx] - min4), COORD_PRECISION));
    }
    return positions;
  };
  CategoryAxis2.prototype.getTicks = function getTicks() {
    var options = this.options;
    var cache2 = this._ticks;
    var range = this.rangeIndices();
    var lineBox = this.lineBox();
    var hash = lineBox.getHash() + range.min + "," + range.max + options.reverse + options.justified;
    if (cache2._hash !== hash) {
      var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;
      cache2._hash = hash;
      cache2.labelTicks = this.getTickPositions(1);
      cache2.majorTicks = this.filterOutOfRangePositions(cache2.labelTicks, lineBox);
      cache2.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];
    }
    return cache2;
  };
  CategoryAxis2.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {
    if (!positions.length) {
      return positions;
    }
    var axis = this.options.vertical ? Y : X;
    var inRange = function(position) {
      return lineBox[axis + 1] <= position && position <= lineBox[axis + 2];
    };
    var end = positions.length - 1;
    var startIndex = 0;
    while (!inRange(positions[startIndex]) && startIndex <= end) {
      startIndex++;
    }
    var endIndex = end;
    while (!inRange(positions[endIndex]) && endIndex >= 0) {
      endIndex--;
    }
    return positions.slice(startIndex, endIndex + 1);
  };
  CategoryAxis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = reverse ? -1 : 1;
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  CategoryAxis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    return reverse ? -1 : 1;
  };
  CategoryAxis2.prototype.getSlot = function getSlot(from, to, limit) {
    var options = this.options;
    var reverse = options.reverse;
    var justified = options.justified;
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var box = ref2.box;
    var min4 = ref2.min;
    var ref$1 = this.lineInfo();
    var valueAxis = ref$1.axis;
    var lineStart = ref$1.lineStart;
    var slotBox = box.clone();
    var singleSlot = !defined(to);
    var start = valueOrDefault(from, 0);
    var end = valueOrDefault(to, start);
    end = Math.max(end - 1, start);
    end = Math.max(start, end);
    var p1 = lineStart + (start - min4) * scale;
    var p22 = lineStart + (end + 1 - min4) * scale;
    if (singleSlot && justified) {
      p22 = p1;
    }
    if (limit) {
      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);
      p22 = limitValue(p22, box[valueAxis + 1], box[valueAxis + 2]);
    }
    slotBox[valueAxis + 1] = reverse ? p22 : p1;
    slotBox[valueAxis + 2] = reverse ? p1 : p22;
    return slotBox;
  };
  CategoryAxis2.prototype.limitSlot = function limitSlot(slot) {
    var vertical = this.options.vertical;
    var valueAxis = vertical ? Y : X;
    var lineBox = this.lineBox();
    var limittedSlot = slot.clone();
    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    return limittedSlot;
  };
  CategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var min4 = Math.floor(this.options.min || 0);
    var start = from;
    var end = to;
    if (typeof start === "string") {
      start = this.categoryIndex(start);
    } else if (isNumber(start)) {
      start -= min4;
    }
    if (typeof end === "string") {
      end = this.categoryIndex(end);
    } else if (isNumber(end)) {
      end -= min4;
    }
    return Axis2.prototype.slot.call(this, start, end, limit);
  };
  CategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min4 = ref$1.min;
    var max3 = ref$1.max;
    var startValue = reverse ? max3 : min4;
    var lineStart = box[valueAxis + 1];
    var lineEnd = box[valueAxis + 2];
    var pos = point[valueAxis];
    if (pos < lineStart || pos > lineEnd) {
      return null;
    }
    var value2 = startValue + (pos - lineStart) / scale;
    var diff = value2 % 1;
    if (justified) {
      value2 = Math.round(value2);
    } else if (diff === 0 && value2 > 0) {
      value2--;
    }
    return Math.floor(value2);
  };
  CategoryAxis2.prototype.getCategory = function getCategory(point) {
    var index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.options.categories[index];
  };
  CategoryAxis2.prototype.categoryIndex = function categoryIndex(value2) {
    return this.totalIndex(value2) - Math.floor(this.options.min || 0);
  };
  CategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    var options = this.options;
    return (total3 ? options.srcCategories : options.categories)[index];
  };
  CategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return (this.options.categories || []).length;
  };
  CategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var lineBox = this.lineBox();
    var size = options.vertical ? lineBox.height() : lineBox.width();
    var range = options.categories.length;
    var scale = size / range;
    var offset = round(delta / scale, DEFAULT_PRECISION);
    return {
      min: offset,
      max: range + offset
    };
  };
  CategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var rangeIndices = this.limitedRangeIndices();
    var range = rangeIndices.max - rangeIndices.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min4 = rangeIndices.min + minDelta;
    var max3 = rangeIndices.max - maxDelta;
    if (max3 - min4 < MIN_CATEGORY_RANGE) {
      max3 = min4 + MIN_CATEGORY_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this.totalRange();
    var totalMin = ref2.min;
    var totalMax = ref2.max;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  };
  CategoryAxis2.prototype.labelsCount = function labelsCount() {
    var labelsRange = this.labelsRange();
    return labelsRange.max - labelsRange.min;
  };
  CategoryAxis2.prototype.labelsRange = function labelsRange() {
    var options = this.options;
    var justified = options.justified;
    var labelOptions = options.labels;
    var ref2 = this.limitedRangeIndices(true);
    var min4 = ref2.min;
    var max3 = ref2.max;
    var start = Math.floor(min4);
    if (!justified) {
      min4 = Math.floor(min4);
      max3 = Math.ceil(max3);
    } else {
      min4 = Math.ceil(min4);
      max3 = Math.floor(max3);
    }
    var skip;
    if (min4 > labelOptions.skip) {
      skip = labelOptions.skip + labelOptions.step * Math.ceil((min4 - labelOptions.skip) / labelOptions.step);
    } else {
      skip = labelOptions.skip;
    }
    return {
      min: skip - start,
      max: (options.categories.length ? max3 + (justified ? 1 : 0) : 0) - start
    };
  };
  CategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options = this.options;
    var dataItem = options.dataItems ? options.dataItems[index] : null;
    var category = valueOrDefault(options.categories[index], "");
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(category, labelOptions, labelContext);
    return new axis_label_default(category, text, index, dataItem, labelOptions);
  };
  CategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.limitedRangeIndices();
    return Math.floor(range.min) <= value2 && value2 <= Math.ceil(range.max);
  };
  CategoryAxis2.prototype.noteSlot = function noteSlot(value2) {
    var options = this.options;
    var index = value2 - Math.floor(options.min || 0);
    return this.getSlot(index);
  };
  CategoryAxis2.prototype.arrangeNotes = function arrangeNotes() {
    Axis2.prototype.arrangeNotes.call(this);
    this.hideOutOfRangeNotes();
  };
  CategoryAxis2.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {
    var ref2 = this;
    var notes3 = ref2.notes;
    var box = ref2.box;
    if (notes3 && notes3.length) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      for (var idx = 0; idx < notes3.length; idx++) {
        var note = notes3[idx];
        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {
          note.hide();
        }
      }
    }
  };
  CategoryAxis2.prototype.pan = function pan(delta) {
    var range = this.limitedRangeIndices(true);
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var offset = round(delta / scale, DEFAULT_PRECISION);
    var totalRange = this.totalRange();
    var min4 = range.min + offset;
    var max3 = range.max + offset;
    return this.limitRange(min4, max3, 0, totalRange.max, offset);
  };
  CategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var range = this.limitedRangeIndices(true);
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var lineStart = box[valueAxis + (reverse ? 2 : 1)];
    var diffStart = start[valueAxis] - lineStart;
    var diffEnd = end[valueAxis] - lineStart;
    var min4 = range.min + diffStart / scale;
    var max3 = range.min + diffEnd / scale;
    var rangeMin = Math.min(min4, max3);
    var rangeMax = Math.max(min4, max3);
    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {
      return {
        min: rangeMin,
        max: rangeMax
      };
    }
  };
  CategoryAxis2.prototype.valueRange = function valueRange3() {
    return this.range();
  };
  CategoryAxis2.prototype.totalIndex = function totalIndex3(value2) {
    var options = this.options;
    var index = this._categoriesMap ? this._categoriesMap.get(value2) : indexOf(value2, options.srcCategories);
    return index;
  };
  CategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var options = this.options;
    var min4 = 0;
    if (isNumber(options.min)) {
      min4 = Math.floor(options.min);
    }
    var max3;
    if (isNumber(options.max)) {
      max3 = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;
    } else {
      max3 = this.totalCount() - 1;
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.limitedRangeIndices = function limitedRangeIndices(totalLimit) {
    var options = this.options;
    var min4 = isNumber(options.min) ? options.min : 0;
    var max3;
    if (isNumber(options.max)) {
      max3 = options.max;
    } else if (isNumber(options.min)) {
      max3 = min4 + options.categories.length;
    } else {
      max3 = this.totalRange().max || 1;
    }
    if (totalLimit) {
      var totalRange = this.totalRange();
      min4 = limitValue(min4, 0, totalRange.max);
      max3 = limitValue(max3, 0, totalRange.max);
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices() {
    return {
      min: 0,
      max: this.totalRange().max || 1
    };
  };
  CategoryAxis2.prototype.indexCategories = function indexCategories() {
    if (!this._categoriesMap) {
      var map3 = this._categoriesMap = new hash_map_default();
      var srcCategories = this.options.srcCategories;
      for (var idx = 0; idx < srcCategories.length; idx++) {
        map3.set(srcCategories[idx], idx);
      }
    }
  };
  CategoryAxis2.prototype.totalCount = function totalCount3() {
    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);
  };
  return CategoryAxis2;
}(axis_default);
setDefaultOptions(CategoryAxis, {
  type: "category",
  vertical: false,
  majorGridLines: {
    visible: false,
    width: 1,
    color: BLACK
  },
  labels: {
    zIndex: 1
  },
  justified: false,
  _deferLabels: true
});
var category_axis_default = CategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/constants.js
var COORDINATE_LIMIT = 3e5;
var DateLabelFormats = {
  milliseconds: "HH:mm:ss.fff",
  seconds: "HH:mm:ss",
  minutes: "HH:mm",
  hours: "HH:mm",
  days: "M/d",
  weeks: "M/d",
  months: "MMM 'yy",
  years: "yyyy"
};
var ZERO_THRESHOLD = 0.2;

// node_modules/@progress/kendo-charts/dist/es/core/date-category-axis.js
var AUTO = "auto";
var BASE_UNITS = [
  MILLISECONDS,
  SECONDS,
  MINUTES,
  HOURS,
  DAYS,
  WEEKS,
  MONTHS,
  YEARS
];
var FIT = "fit";
function categoryRange(categories, clearCache) {
  if (clearCache) {
    categories._range = void 0;
  }
  var range = categories._range;
  if (!range) {
    range = categories._range = sparseArrayLimits(categories);
    range.min = toDate(range.min);
    range.max = toDate(range.max);
  }
  return range;
}
var EmptyDateRange = function EmptyDateRange2(options) {
  this.options = options;
};
EmptyDateRange.prototype.displayIndices = function displayIndices() {
  return {
    min: 0,
    max: 1
  };
};
EmptyDateRange.prototype.displayRange = function displayRange() {
  return {};
};
EmptyDateRange.prototype.total = function total() {
  return {};
};
EmptyDateRange.prototype.valueRange = function valueRange() {
  return {};
};
EmptyDateRange.prototype.valueIndex = function valueIndex() {
  return -1;
};
EmptyDateRange.prototype.values = function values3() {
  return [];
};
EmptyDateRange.prototype.totalIndex = function totalIndex() {
  return -1;
};
EmptyDateRange.prototype.valuesCount = function valuesCount() {
  return 0;
};
EmptyDateRange.prototype.totalCount = function totalCount() {
  return 0;
};
EmptyDateRange.prototype.dateAt = function dateAt() {
  return null;
};
var DateRange = function DateRange2(start, end, options) {
  this.options = options;
  options.baseUnitStep = options.baseUnitStep || 1;
  var roundToBaseUnit = options.roundToBaseUnit;
  var justified = options.justified;
  this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);
  var lowerEnd = this.roundToTotalStep(end);
  var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;
  this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);
  var min4 = options.min || start;
  this.valueStart = this.roundToTotalStep(min4);
  this.displayStart = roundToBaseUnit ? this.valueStart : min4;
  var max3 = options.max;
  if (!max3) {
    this.valueEnd = lowerEnd;
    this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;
  } else {
    var next = !justified && dateEquals(max3, this.roundToTotalStep(max3)) ? -1 : 0;
    this.valueEnd = this.roundToTotalStep(max3, false, next);
    this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max3, !justified) : options.max;
  }
  if (this.valueEnd < this.valueStart) {
    this.valueEnd = this.valueStart;
  }
  if (this.displayEnd <= this.displayStart) {
    this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);
  }
};
DateRange.prototype.displayRange = function displayRange2() {
  return {
    min: this.displayStart,
    max: this.displayEnd
  };
};
DateRange.prototype.displayIndices = function displayIndices2() {
  if (!this._indices) {
    var options = this.options;
    var baseUnit = options.baseUnit;
    var baseUnitStep = options.baseUnitStep;
    var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);
    var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);
    this._indices = { min: minIdx, max: maxIdx };
  }
  return this._indices;
};
DateRange.prototype.total = function total2() {
  return {
    min: this.start,
    max: this.end
  };
};
DateRange.prototype.totalCount = function totalCount2() {
  var last2 = this.totalIndex(this.end);
  return last2 + (this.options.justified ? 1 : 0);
};
DateRange.prototype.valueRange = function valueRange2() {
  return {
    min: this.valueStart,
    max: this.valueEnd
  };
};
DateRange.prototype.valueIndex = function valueIndex2(value2) {
  var options = this.options;
  return Math.floor(dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep));
};
DateRange.prototype.totalIndex = function totalIndex2(value2) {
  var options = this.options;
  return Math.floor(dateIndex(value2, this.start, options.baseUnit, options.baseUnitStep));
};
DateRange.prototype.dateIndex = function dateIndex$1(value2) {
  var options = this.options;
  return dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep);
};
DateRange.prototype.valuesCount = function valuesCount2() {
  var maxIdx = this.valueIndex(this.valueEnd);
  return maxIdx + 1;
};
DateRange.prototype.values = function values4() {
  var values5 = this._values;
  if (!values5) {
    var options = this.options;
    var range = this.valueRange();
    this._values = values5 = [];
    for (var date = range.min; date <= range.max; ) {
      values5.push(date);
      date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);
    }
  }
  return values5;
};
DateRange.prototype.dateAt = function dateAt2(index, total3) {
  var options = this.options;
  return addDuration(total3 ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);
};
DateRange.prototype.roundToTotalStep = function roundToTotalStep(value2, upper, next) {
  var ref2 = this.options;
  var baseUnit = ref2.baseUnit;
  var baseUnitStep = ref2.baseUnitStep;
  var weekStartDay = ref2.weekStartDay;
  var start = this.start;
  var step = dateIndex(value2, start, baseUnit, baseUnitStep);
  var roundedStep = upper ? Math.ceil(step) : Math.floor(step);
  if (next) {
    roundedStep += next;
  }
  return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);
};
function autoBaseUnit(options, startUnit, startStep) {
  var categoryLimits = categoryRange(options.categories);
  var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);
  var autoBaseUnitSteps = options.autoBaseUnitSteps;
  var maxDateGroups = options.maxDateGroups;
  var autoUnit = options.baseUnit === FIT;
  var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;
  var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;
  var units = span / TIME_PER_UNIT[baseUnit];
  var totalUnits = units;
  var unitSteps, step, nextStep;
  while (!step || units >= maxDateGroups) {
    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
    do {
      nextStep = unitSteps.shift();
    } while (nextStep && startUnit === baseUnit && nextStep < startStep);
    if (nextStep) {
      step = nextStep;
      units = totalUnits / step;
    } else if (baseUnit === last(BASE_UNITS)) {
      step = Math.ceil(totalUnits / maxDateGroups);
      break;
    } else if (autoUnit) {
      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);
      totalUnits = span / TIME_PER_UNIT[baseUnit];
      unitSteps = null;
    } else {
      if (units > maxDateGroups) {
        step = Math.ceil(totalUnits / maxDateGroups);
      }
      break;
    }
  }
  options.baseUnitStep = step;
  options.baseUnit = baseUnit;
}
function defaultBaseUnit(options) {
  var categories = options.categories;
  var count = defined(categories) ? categories.length : 0;
  var minDiff = MAX_VALUE;
  var lastCategory, unit2;
  for (var categoryIx = 0; categoryIx < count; categoryIx++) {
    var category = categories[categoryIx];
    if (category && lastCategory) {
      var diff = Math.abs(absoluteDateDiff(category, lastCategory));
      if (diff !== 0) {
        minDiff = Math.min(minDiff, diff);
        if (minDiff >= TIME_PER_YEAR) {
          unit2 = YEARS;
        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {
          unit2 = MONTHS;
        } else if (minDiff >= TIME_PER_WEEK) {
          unit2 = WEEKS;
        } else if (minDiff >= TIME_PER_DAY) {
          unit2 = DAYS;
        } else if (minDiff >= TIME_PER_HOUR) {
          unit2 = HOURS;
        } else if (minDiff >= TIME_PER_MINUTE) {
          unit2 = MINUTES;
        } else {
          unit2 = SECONDS;
        }
      }
    }
    lastCategory = category;
  }
  options.baseUnit = unit2 || DAYS;
}
function initUnit(options) {
  var baseUnit = (options.baseUnit || "").toLowerCase();
  var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);
  if (useDefault) {
    defaultBaseUnit(options);
  }
  if (baseUnit === FIT || options.baseUnitStep === AUTO) {
    autoBaseUnit(options);
  }
  return options;
}
var DateCategoryAxis = function(CategoryAxis2) {
  function DateCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2) DateCategoryAxis2.__proto__ = CategoryAxis2;
  DateCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  DateCategoryAxis2.prototype.constructor = DateCategoryAxis2;
  DateCategoryAxis2.prototype.clone = function clone3() {
    var copy = new DateCategoryAxis2(Object.assign({}, this.options), this.chartService);
    copy.createLabels();
    return copy;
  };
  DateCategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    var start = this.dataRange.total().min;
    return this.options.baseUnit + this.options.baseUnitStep + start;
  };
  DateCategoryAxis2.prototype.initUserOptions = function initUserOptions(options) {
    return options;
  };
  DateCategoryAxis2.prototype.initFields = function initFields() {
    CategoryAxis2.prototype.initFields.call(this);
    var chartService = this.chartService;
    var intlService = chartService.intl;
    var options = this.options;
    var categories = options.categories || [];
    if (!categories._parsed) {
      categories = parseDates(intlService, categories);
      categories._parsed = true;
    }
    options = deepExtend({
      roundToBaseUnit: true
    }, options, {
      categories,
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      weekStartDay: firstDay(options, intlService)
    });
    if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {
      options.roundToBaseUnit = false;
    }
    options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;
    options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;
    this.options = options;
    options.srcCategories = categories;
    if (categories.length > 0) {
      var range = categoryRange(categories, true);
      var maxDivisions = options.maxDivisions;
      var safeOptions = initUnit(options);
      var forecast = options._forecast;
      if (forecast) {
        if (forecast.before > 0) {
          range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
        if (forecast.after > 0) {
          range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
      }
      this.dataRange = new DateRange(range.min, range.max, safeOptions);
      if (maxDivisions) {
        var dataRange = this.dataRange.displayRange();
        var divisionOptions = Object.assign({}, options, {
          justified: true,
          roundToBaseUnit: false,
          baseUnit: "fit",
          min: dataRange.min,
          max: dataRange.max,
          maxDateGroups: maxDivisions
        });
        var dataRangeOptions = this.dataRange.options;
        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);
        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);
      } else {
        this.divisionRange = this.dataRange;
      }
    } else {
      options.baseUnit = options.baseUnit || DAYS;
      this.dataRange = this.divisionRange = new EmptyDateRange(options);
    }
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this;
    var dataRange = ref2.dataRange;
    var divisionRange = ref2.divisionRange;
    var valuesCount3 = divisionRange.valuesCount();
    if (!this.options.maxDivisions || !valuesCount3) {
      return CategoryAxis2.prototype.tickIndices.call(this, stepSize);
    }
    var indices = [];
    var values5 = divisionRange.values();
    var offset = 0;
    if (!this.options.justified) {
      values5 = values5.concat(divisionRange.dateAt(valuesCount3));
      offset = 0.5;
    }
    for (var idx = 0; idx < values5.length; idx++) {
      indices.push(dataRange.dateIndex(values5[idx]) + offset);
      if (stepSize !== 1 && idx >= 1) {
        var last2 = indices.length - 1;
        indices.splice(idx, 0, indices[last2 - 1] + (indices[last2] - indices[last2 - 1]) * stepSize);
      }
    }
    return indices;
  };
  DateCategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    var categories = this.options.categories || [];
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0 && categories.length;
  };
  DateCategoryAxis2.prototype.parseNoteValue = function parseNoteValue(value2) {
    return parseDate(this.chartService.intl, value2);
  };
  DateCategoryAxis2.prototype.noteSlot = function noteSlot(value2) {
    return this.getSlot(value2);
  };
  DateCategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var baseUnit = options.baseUnit;
    var weekStartDay = options.weekStartDay;
    var vertical = options.vertical;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / (range.max - range.min);
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if (range.min && range.max) {
      var from = addTicks(options.min || range.min, offset);
      var to = addTicks(options.max || range.max, offset);
      range = {
        min: addDuration(from, 0, baseUnit, weekStartDay),
        max: addDuration(to, 0, baseUnit, weekStartDay)
      };
    }
    return range;
  };
  DateCategoryAxis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.divisionRange.valuesCount()
    };
  };
  DateCategoryAxis2.prototype.pan = function pan(delta) {
    if (this.isEmpty()) {
      return null;
    }
    var options = this.options;
    var lineBox = this.lineBox();
    var size = options.vertical ? lineBox.height() : lineBox.width();
    var ref2 = this.dataRange.displayRange();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var totalLimits = this.dataRange.total();
    var scale = size / (max3 - min4);
    var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);
    var from = addTicks(min4, offset);
    var to = addTicks(max3, offset);
    var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);
    if (panRange) {
      panRange.min = toDate(panRange.min);
      panRange.max = toDate(panRange.max);
      panRange.baseUnit = options.baseUnit;
      panRange.baseUnitStep = options.baseUnitStep || 1;
      panRange.userSetBaseUnit = options.userSetBaseUnit;
      panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;
      return panRange;
    }
  };
  DateCategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    if (this.isEmpty()) {
      return null;
    }
    var pointsRange2 = CategoryAxis2.prototype.pointsRange.call(this, start, end);
    var datesRange = this.dataRange.displayRange();
    var indicesRange = this.dataRange.displayIndices();
    var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
    var options = this.options;
    var min4 = addTicks(datesRange.min, pointsRange2.min * scale);
    var max3 = addTicks(datesRange.min, pointsRange2.max * scale);
    return {
      min: min4,
      max: max3,
      baseUnit: options.userSetBaseUnit || options.baseUnit,
      baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
    };
  };
  DateCategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    if (this.isEmpty()) {
      return {};
    }
    var options = this.options;
    var fit = options.userSetBaseUnit === FIT;
    var totalLimits = this.dataRange.total();
    var ref2 = this.dataRange.displayRange();
    var rangeMin = ref2.min;
    var rangeMax = ref2.max;
    var position = Math.abs(this.pointOffset(cursor));
    var range = rangeMax - rangeMin;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = Math.round(position * delta);
    var maxDelta = Math.round((1 - position) * delta);
    var ref$1 = this.dataRange.options;
    var baseUnit = ref$1.baseUnit;
    var min4 = new Date(rangeMin.getTime() + minDelta);
    var max3 = new Date(rangeMax.getTime() - maxDelta);
    if (fit) {
      var autoBaseUnitSteps = options.autoBaseUnitSteps;
      var maxDateGroups = options.maxDateGroups;
      var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];
      var rangeDiff = dateDiff(rangeMax, rangeMin);
      var diff = dateDiff(max3, min4);
      var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
      var autoBaseUnitStep, ticks;
      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {
        baseUnit = BASE_UNITS[baseUnitIndex - 1];
        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);
        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;
        min4 = addTicks(rangeMin, ticks);
        max3 = addTicks(rangeMax, -ticks);
      } else if (diff > maxDiff && baseUnit !== YEARS) {
        var stepIndex = 0;
        do {
          baseUnitIndex++;
          baseUnit = BASE_UNITS[baseUnitIndex];
          stepIndex = 0;
          ticks = 2 * TIME_PER_UNIT[baseUnit];
          do {
            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
            stepIndex++;
          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);
        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
        if (ticks > 0) {
          min4 = addTicks(rangeMin, -ticks);
          max3 = addTicks(rangeMax, ticks);
          min4 = addTicks(min4, limitValue(max3, totalLimits.min, totalLimits.max) - max3);
          max3 = addTicks(max3, limitValue(min4, totalLimits.min, totalLimits.max) - min4);
        }
      }
    }
    if (min4 && max3 && dateDiff(max3, min4) > 0) {
      return {
        min: min4,
        max: max3,
        baseUnit: options.userSetBaseUnit || options.baseUnit,
        baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
      };
    }
  };
  DateCategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var totalLimits = this.dataRange.total();
    var range = this.scaleRange(scale, cursor);
    if (range) {
      if (range.min < totalLimits.min) {
        range.min = totalLimits.min;
      }
      if (range.max > totalLimits.max) {
        range.max = totalLimits.max;
      }
    }
    return range;
  };
  DateCategoryAxis2.prototype.range = function range() {
    return this.dataRange.displayRange();
  };
  DateCategoryAxis2.prototype.createLabels = function createLabels() {
    CategoryAxis2.prototype.createLabels.call(this);
    this.createRangeLabels();
  };
  DateCategoryAxis2.prototype.clearLabels = function clearLabels() {
    CategoryAxis2.prototype.clearLabels.call(this);
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    this.arrangeRangeLabels();
    CategoryAxis2.prototype.arrangeLabels.call(this);
  };
  DateCategoryAxis2.prototype.arrangeRangeLabels = function arrangeRangeLabels() {
    var ref2 = this;
    var options = ref2.options;
    var rangeLabels = ref2.rangeLabels;
    if (rangeLabels.length === 0) {
      return;
    }
    var lineBox = this.lineBox();
    var vertical = options.vertical;
    var mirror = options.rangeLabels.mirror || options.labels.mirror;
    var firstLabel = rangeLabels[0];
    if (firstLabel) {
      var position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;
      this.positionLabel(firstLabel, mirror, position);
    }
    var lastLabel = rangeLabels[1];
    if (lastLabel) {
      var position$1 = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;
      this.positionLabel(lastLabel, mirror, position$1);
    }
  };
  DateCategoryAxis2.prototype.autoRotateLabels = function autoRotateLabels() {
    CategoryAxis2.prototype.autoRotateLabels.call(this);
    this.autoRotateRangeLabels();
  };
  DateCategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    CategoryAxis2.prototype.hideOutOfRangeLabels.call(this);
    this.hideOverlappingLabels();
  };
  DateCategoryAxis2.prototype.hideOverlappingLabels = function hideOverlappingLabels() {
    var ref2 = this;
    var rangeLabels = ref2.rangeLabels;
    var labels = ref2.labels;
    if (rangeLabels.length === 0) {
      return;
    }
    function clip(rangeLabel, label) {
      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {
        label.options.visible = false;
        return true;
      }
      return false;
    }
    var firstRangeLabel = rangeLabels[0];
    if (firstRangeLabel && firstRangeLabel.options.visible) {
      for (var i36 = 0; i36 < labels.length; i36++) {
        var overlaps = clip(firstRangeLabel, labels[i36]);
        if (!overlaps) {
          break;
        }
      }
    }
    var lastRangeLabel = rangeLabels[1];
    if (lastRangeLabel && lastRangeLabel.options.visible) {
      for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {
        var overlaps$1 = clip(lastRangeLabel, labels[i$1]);
        if (!overlaps$1) {
          break;
        }
      }
    }
  };
  DateCategoryAxis2.prototype.contentBox = function contentBox() {
    var box = CategoryAxis2.prototype.contentBox.call(this);
    var rangeLabels = this.rangeLabels;
    for (var i36 = 0; i36 < rangeLabels.length; i36++) {
      var label = rangeLabels[i36];
      if (label.options.visible) {
        box.wrap(label.box);
      }
    }
    return box;
  };
  DateCategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    if (labelContext === void 0) labelContext = {};
    var options = this.options;
    var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;
    var date = this.divisionRange.dateAt(index);
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    if (text) {
      return new axis_label_default(date, text, index, dataItem, labelOptions);
    }
  };
  DateCategoryAxis2.prototype.createRangeLabels = function createRangeLabels() {
    var this$1 = this;
    var ref2 = this.divisionRange;
    var displayStart = ref2.displayStart;
    var displayEnd = ref2.displayEnd;
    var options = this.options;
    var labelOptions = Object.assign({}, options.labels, options.rangeLabels, {
      align: CENTER,
      zIndex: options.zIndex
    });
    if (labelOptions.visible !== true) {
      return;
    }
    this.normalizeLabelRotation(labelOptions);
    labelOptions.alignRotation = CENTER;
    if (labelOptions.rotation === "auto") {
      labelOptions.rotation = 0;
      options.autoRotateRangeLabels = true;
    }
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var createLabel = function(index, date, text) {
      if (text) {
        var label = new axis_label_default(date, text, index, null, labelOptions);
        this$1.append(label);
        this$1.rangeLabels.push(label);
      }
    };
    var startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });
    createLabel(0, displayStart, startText);
    var endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });
    createLabel(1, displayEnd, endText);
  };
  DateCategoryAxis2.prototype.autoRotateRangeLabels = function autoRotateRangeLabels() {
    var this$1 = this;
    var labels = this.rangeLabels;
    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {
      return;
    }
    var rotateLabel = function(label, tickPositions2, index) {
      var width = Math.abs(tickPositions2[index + 1] - tickPositions2[index]) * 2;
      var angle = this$1.autoRotateLabelAngle(label.box, width);
      if (angle !== 0) {
        label.options.rotation = angle;
        label.reflow(new box_default());
      }
    };
    var tickPositions = this.getMajorTickPositions();
    rotateLabel(labels[0], tickPositions, 0);
    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);
  };
  DateCategoryAxis2.prototype.categoryIndex = function categoryIndex(value2) {
    return this.dataRange.valueIndex(value2);
  };
  DateCategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var dateRange = this.dataRange;
    var start = from;
    var end = to;
    if (start instanceof Date) {
      start = dateRange.dateIndex(start);
    }
    if (end instanceof Date) {
      end = dateRange.dateIndex(end);
    }
    var slot2 = this.getSlot(start, end, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  DateCategoryAxis2.prototype.getSlot = function getSlot(a38, b2, limit) {
    var start = a38;
    var end = b2;
    if (typeof start === OBJECT) {
      start = this.categoryIndex(start);
    }
    if (typeof end === OBJECT) {
      end = this.categoryIndex(end);
    }
    return CategoryAxis2.prototype.getSlot.call(this, start, end, limit);
  };
  DateCategoryAxis2.prototype.valueRange = function valueRange3() {
    var options = this.options;
    var range = categoryRange(options.srcCategories);
    return {
      min: toDate(range.min),
      max: toDate(range.max)
    };
  };
  DateCategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    return this.dataRange.dateAt(index, total3);
  };
  DateCategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return this.dataRange.valuesCount();
  };
  DateCategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    return this.dataRange.displayIndices();
  };
  DateCategoryAxis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.divisionRange.options.justified;
  };
  DateCategoryAxis2.prototype.prepareUserOptions = function prepareUserOptions() {
    if (this.isEmpty()) {
      return;
    }
    this.options.categories = this.dataRange.values();
  };
  DateCategoryAxis2.prototype.getCategory = function getCategory(point) {
    var index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.dataRange.dateAt(index);
  };
  DateCategoryAxis2.prototype.totalIndex = function totalIndex3(value2) {
    return this.dataRange.totalIndex(value2);
  };
  DateCategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var range = this.dataRange.valueRange();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalRange = function totalRange() {
    return this.dataRange.total();
  };
  DateCategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices() {
    var range = this.dataRange.total();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalCount = function totalCount3() {
    return this.dataRange.totalCount();
  };
  DateCategoryAxis2.prototype.isEmpty = function isEmpty() {
    return !this.options.srcCategories.length;
  };
  DateCategoryAxis2.prototype.roundedRange = function roundedRange() {
    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {
      return this.range();
    }
    var options = this.options;
    var datesRange = categoryRange(options.srcCategories);
    var dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {
      justified: false,
      roundToBaseUnit: true,
      justifyEnd: false
    }));
    return dateRange.displayRange();
  };
  return DateCategoryAxis2;
}(category_axis_default);
setDefaultOptions(DateCategoryAxis, {
  type: DATE,
  labels: {
    dateFormats: DateLabelFormats
  },
  rangeLabels: {
    visible: false
  },
  autoBaseUnitSteps: {
    milliseconds: [1, 10, 100],
    seconds: [1, 2, 5, 15, 30],
    minutes: [1, 2, 5, 15, 30],
    hours: [1, 2, 3],
    days: [1, 2, 3],
    weeks: [1, 2],
    months: [1, 2, 3, 6],
    years: [1, 2, 3, 5, 10, 25, 50]
  },
  maxDateGroups: 10
});
var date_category_axis_default = DateCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-min.js
function autoAxisMin(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 0;
  }
  var axisMin;
  if (min4 >= 0 && max3 >= 0) {
    var minValue = min4 === max3 ? 0 : min4;
    var diff = (max3 - minValue) / max3;
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMin = Math.max(0, minValue - (max3 - minValue) / 2);
  } else {
    axisMin = min4;
  }
  return axisMin;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-max.js
function autoAxisMax(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 1;
  }
  var axisMax;
  if (min4 <= 0 && max3 <= 0) {
    var maxValue = min4 === max3 ? 0 : max3;
    var diff = Math.abs((maxValue - min4) / maxValue);
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMax = Math.min(0, maxValue - (min4 - maxValue) / 2);
  } else {
    axisMax = max3;
  }
  return axisMax;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/floor.js
function floor(value2, step) {
  return round(Math.floor(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/ceil.js
function ceil(value2, step) {
  return round(Math.ceil(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/limit-coordinate.js
function limitCoordinate(value2) {
  return Math.max(Math.min(value2, COORDINATE_LIMIT), -COORDINATE_LIMIT);
}

// node_modules/@progress/kendo-charts/dist/es/core/numeric-axis.js
var MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);
var NumericAxis = function(Axis2) {
  function NumericAxis2(seriesMin, seriesMax, options, chartService) {
    Axis2.call(this, Object.assign({}, options, {
      seriesMin,
      seriesMax
    }), chartService);
  }
  if (Axis2) NumericAxis2.__proto__ = Axis2;
  NumericAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  NumericAxis2.prototype.constructor = NumericAxis2;
  NumericAxis2.prototype.initUserOptions = function initUserOptions(options) {
    var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);
    this.totalOptions = totalAxisOptions(autoOptions, options);
    return axisOptions(autoOptions, options);
  };
  NumericAxis2.prototype.initFields = function initFields() {
    this.totalMin = this.totalOptions.min;
    this.totalMax = this.totalOptions.max;
    this.totalMajorUnit = this.totalOptions.majorUnit;
    this.seriesMin = this.options.seriesMin;
    this.seriesMax = this.options.seriesMax;
  };
  NumericAxis2.prototype.clone = function clone3() {
    return new NumericAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  NumericAxis2.prototype.startValue = function startValue() {
    return 0;
  };
  NumericAxis2.prototype.range = function range() {
    var options = this.options;
    return { min: options.min, max: options.max };
  };
  NumericAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    if (stepValue === 0) {
      return 1;
    }
    var options = this.options;
    var range = options.max - options.min;
    return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;
  };
  NumericAxis2.prototype.getTickPositions = function getTickPositions(unit2, skipUnit) {
    var options = this.options;
    var ref2 = this.lineInfo();
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var range = options.max - options.min;
    var scale = lineSize / range;
    var step = unit2 * scale;
    var divisions = this.getDivisions(unit2);
    var positions = [];
    var pos = lineBox[axisOrigin];
    var skipStep = 0;
    if (skipUnit) {
      skipStep = skipUnit / unit2;
    }
    for (var idx = 0; idx < divisions; idx++) {
      if (idx % skipStep !== 0) {
        positions.push(round(pos, COORD_PRECISION));
      }
      pos = pos + step * axisDir;
    }
    return positions;
  };
  NumericAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  NumericAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  NumericAxis2.prototype.getSlot = function getSlot(a38, b2, limit) {
    if (limit === void 0) limit = false;
    var options = this.options;
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var lineStart = ref2.lineStart;
    var step = axisDir * (lineSize / (options.max - options.min));
    var start = valueOrDefault(a38, b2 || 0);
    var end = valueOrDefault(b2, a38 || 0);
    if (limit) {
      start = limitValue(start, options.min, options.max);
      end = limitValue(end, options.min, options.max);
    }
    var p1 = Math.min(start, end) - options.min;
    var p22 = Math.max(start, end) - options.min;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p22));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p22 : p1));
    return slotBox;
  };
  NumericAxis2.prototype.getValue = function getValue(point) {
    var options = this.options;
    var max3 = Number(options.max);
    var min4 = Number(options.min);
    var offset = this.pointOffset(point);
    var valueOffset = offset * (max3 - min4);
    if (offset < 0 || offset > 1) {
      return null;
    }
    var value2 = min4 + valueOffset;
    return round(value2, DEFAULT_PRECISION);
  };
  NumericAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var vertical = options.vertical;
    var reverse = options.reverse;
    var max3 = options.max;
    var min4 = options.min;
    var ref2 = this.lineInfo();
    var lineSize = ref2.lineSize;
    var range = max3 - min4;
    var scale = lineSize / range;
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: min4 + offset,
      max: max3 + offset,
      offset
    };
  };
  NumericAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  NumericAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options = this.options;
    var value2 = round(options.min + index * options.majorUnit, DEFAULT_PRECISION);
    var text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  };
  NumericAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return range.min <= value2 && value2 <= range.max;
  };
  NumericAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  NumericAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min4 = Math.min(startValue, endValue);
    var max3 = Math.max(startValue, endValue);
    if (this.isValidRange(min4, max3)) {
      return {
        min: min4,
        max: max3
      };
    }
  };
  NumericAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min4 = round(this.options.min + minDelta, DEFAULT_PRECISION);
    var max3 = round(this.options.max - maxDelta, DEFAULT_PRECISION);
    if (max3 - min4 < MIN_VALUE_RANGE) {
      max3 = min4 + MIN_VALUE_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  };
  NumericAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax),
      narrowRange: false
    };
  };
  NumericAxis2.prototype.isValidRange = function isValidRange(min4, max3) {
    return max3 - min4 > MIN_VALUE_RANGE;
  };
  return NumericAxis2;
}(axis_default);
function autoAxisOptions(seriesMin, seriesMax, options) {
  var narrowRange = options.narrowRange;
  var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);
  var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);
  var majorUnit = autoMajorUnit(autoMin, autoMax);
  var autoOptions = {
    majorUnit
  };
  if (options.roundToMajorUnit !== false) {
    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
      autoMin -= majorUnit;
    }
    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
      autoMax += majorUnit;
    }
  }
  autoOptions.min = floor(autoMin, majorUnit);
  autoOptions.max = ceil(autoMax, majorUnit);
  return autoOptions;
}
function totalAxisOptions(autoOptions, options) {
  return {
    min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,
    max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,
    majorUnit: autoOptions.majorUnit
  };
}
function clearNullValues(options, fields) {
  for (var idx = 0; idx < fields.length; idx++) {
    var field = fields[idx];
    if (options[field] === null) {
      options[field] = void 0;
    }
  }
}
function axisOptions(autoOptions, userOptions) {
  var options = userOptions;
  var userSetMin, userSetMax;
  if (userOptions) {
    clearNullValues(userOptions, ["min", "max"]);
    userSetMin = defined(userOptions.min);
    userSetMax = defined(userOptions.max);
    var userSetLimits = userSetMin || userSetMax;
    if (userSetLimits) {
      if (userOptions.min === userOptions.max) {
        if (userOptions.min > 0) {
          userOptions.min = 0;
        } else {
          userOptions.max = 1;
        }
      }
    }
    if (userOptions.majorUnit) {
      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);
      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);
    } else if (userSetLimits) {
      options = deepExtend(autoOptions, userOptions);
      autoOptions.majorUnit = autoMajorUnit(options.min, options.max);
    }
  }
  autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;
  var result = deepExtend(autoOptions, options);
  if (result.min >= result.max) {
    if (userSetMin && !userSetMax) {
      result.max = result.min + result.majorUnit;
    } else if (!userSetMin && userSetMax) {
      result.min = result.max - result.majorUnit;
    }
  }
  return result;
}
function remainderClose(value2, divisor, ratio) {
  var remainder = round(Math.abs(value2 % divisor), DEFAULT_PRECISION);
  var threshold = divisor * (1 - ratio);
  return remainder === 0 || remainder > threshold;
}
setDefaultOptions(NumericAxis, {
  type: "numeric",
  min: 0,
  max: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    format: "#.####################"
  },
  zIndex: 1
});
var numeric_axis_default = NumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/date-value-axis.js
var MIN_VALUE_RANGE2 = 1e3;
var DateValueAxis = function(Axis2) {
  function DateValueAxis2(seriesMin, seriesMax, axisOptions2, chartService) {
    var min4 = toDate(seriesMin);
    var max3 = toDate(seriesMax);
    var intlService = chartService.intl;
    var options = axisOptions2 || {};
    options = deepExtend(options || {}, {
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),
      weekStartDay: firstDay(options, intlService)
    });
    options = applyDefaults(min4, max3, options);
    Axis2.call(this, options, chartService);
    this.intlService = intlService;
    this.seriesMin = min4;
    this.seriesMax = max3;
    var weekStartDay = options.weekStartDay || 0;
    this.totalMin = toTime(floorDate(toTime(min4) - 1, options.baseUnit, weekStartDay));
    this.totalMax = toTime(ceilDate(toTime(max3) + 1, options.baseUnit, weekStartDay));
  }
  if (Axis2) DateValueAxis2.__proto__ = Axis2;
  DateValueAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  DateValueAxis2.prototype.constructor = DateValueAxis2;
  DateValueAxis2.prototype.clone = function clone3() {
    return new DateValueAxis2(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  };
  DateValueAxis2.prototype.range = function range() {
    var options = this.options;
    return { min: options.min, max: options.max };
  };
  DateValueAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    var options = this.options;
    return Math.floor(
      duration(options.min, options.max, options.baseUnit) / stepValue + 1
    );
  };
  DateValueAxis2.prototype.getTickPositions = function getTickPositions(step) {
    var options = this.options;
    var ref2 = this.lineInfo();
    var dir = ref2.axisDir;
    var lineSize = ref2.lineSize;
    var start = ref2.lineStart;
    var divisions = this.getDivisions(step);
    var timeRange = dateDiff(options.max, options.min);
    var scale = lineSize / timeRange;
    var weekStartDay = options.weekStartDay || 0;
    var positions = [start];
    for (var i36 = 1; i36 < divisions; i36++) {
      var date = addDuration(options.min, i36 * step, options.baseUnit, weekStartDay);
      var pos = start + dateDiff(date, options.min) * scale * dir;
      positions.push(round(pos, COORD_PRECISION));
    }
    return positions;
  };
  DateValueAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  DateValueAxis2.prototype.getSlot = function getSlot(a38, b2, limit) {
    return numeric_axis_default.prototype.getSlot.call(
      this,
      parseDate(this.intlService, a38),
      parseDate(this.intlService, b2),
      limit
    );
  };
  DateValueAxis2.prototype.getValue = function getValue(point) {
    var value2 = numeric_axis_default.prototype.getValue.call(this, point);
    return value2 !== null ? toDate(value2) : null;
  };
  DateValueAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options = this.options;
    var offset = index * options.majorUnit;
    var weekStartDay = options.weekStartDay || 0;
    var date = options.min;
    if (offset > 0) {
      date = addDuration(date, offset, options.baseUnit, weekStartDay);
    }
    var unitFormat = labelOptions.dateFormats[options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    return new axis_label_default(date, text, index, null, labelOptions);
  };
  DateValueAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var lineBox = this.lineBox();
    var vertical = options.vertical;
    var reverse = options.reverse;
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / dateDiff(range.max, range.min);
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    var from = addTicks(options.min, offset);
    var to = addTicks(options.max, offset);
    return {
      min: from,
      max: to,
      offset
    };
  };
  DateValueAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0;
  };
  DateValueAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta, true);
    var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);
    if (limittedRange) {
      return {
        min: toDate(limittedRange.min),
        max: toDate(limittedRange.max)
      };
    }
  };
  DateValueAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min4 = Math.min(startValue, endValue);
    var max3 = Math.max(startValue, endValue);
    return {
      min: toDate(min4),
      max: toDate(max3)
    };
  };
  DateValueAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min4 = toDate(toTime(this.options.min) + minDelta);
    var max3 = toDate(toTime(this.options.max) - maxDelta);
    if (max3 - min4 < MIN_VALUE_RANGE2) {
      max3 = toDate(toTime(min4) + MIN_VALUE_RANGE2);
    }
    return {
      min: min4,
      max: max3
    };
  };
  DateValueAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var min4 = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));
    var max3 = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));
    return {
      min: min4,
      max: max3
    };
  };
  return DateValueAxis2;
}(axis_default);
function timeUnits(delta) {
  var unit2 = HOURS;
  if (delta >= TIME_PER_YEAR) {
    unit2 = YEARS;
  } else if (delta >= TIME_PER_MONTH) {
    unit2 = MONTHS;
  } else if (delta >= TIME_PER_WEEK) {
    unit2 = WEEKS;
  } else if (delta >= TIME_PER_DAY) {
    unit2 = DAYS;
  }
  return unit2;
}
function applyDefaults(seriesMin, seriesMax, options) {
  var min4 = options.min || seriesMin;
  var max3 = options.max || seriesMax;
  var baseUnit = options.baseUnit || (max3 && min4 ? timeUnits(absoluteDateDiff(max3, min4)) : HOURS);
  var baseUnitTime = TIME_PER_UNIT[baseUnit];
  var weekStartDay = options.weekStartDay || 0;
  var autoMin = floorDate(toTime(min4) - 1, baseUnit, weekStartDay) || toDate(max3);
  var autoMax = ceilDate(toTime(max3) + 1, baseUnit, weekStartDay);
  var userMajorUnit = options.majorUnit ? options.majorUnit : void 0;
  var majorUnit = userMajorUnit || ceil(
    autoMajorUnit(autoMin.getTime(), autoMax.getTime()),
    baseUnitTime
  ) / baseUnitTime;
  var actualUnits = duration(autoMin, autoMax, baseUnit);
  var totalUnits = ceil(actualUnits, majorUnit);
  var unitsToAdd = totalUnits - actualUnits;
  var head = Math.floor(unitsToAdd / 2);
  var tail = unitsToAdd - head;
  if (!options.baseUnit) {
    delete options.baseUnit;
  }
  options.baseUnit = options.baseUnit || baseUnit;
  options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);
  options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);
  options.minorUnit = options.minorUnit || majorUnit / 5;
  options.majorUnit = majorUnit;
  return options;
}
setDefaultOptions(DateValueAxis, {
  type: DATE,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    dateFormats: DateLabelFormats
  }
});
var date_value_axis_default = DateValueAxis;

// node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js
var DEFAULT_MAJOR_UNIT = 10;
var MIN_VALUE_RANGE3 = 1e-6;
var LogarithmicAxis = function(Axis2) {
  function LogarithmicAxis2(seriesMin, seriesMax, options, chartService) {
    var axisOptions2 = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);
    var base = axisOptions2.majorUnit;
    var autoMax = autoAxisMax2(seriesMax, base);
    var autoMin = autoAxisMin2(seriesMin, seriesMax, axisOptions2);
    var range = initRange(autoMin, autoMax, axisOptions2, options);
    axisOptions2.max = range.max;
    axisOptions2.min = range.min;
    axisOptions2.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);
    Axis2.call(this, axisOptions2, chartService);
    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;
    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;
    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);
    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);
    this.seriesMin = seriesMin;
    this.seriesMax = seriesMax;
    this.createLabels();
  }
  if (Axis2) LogarithmicAxis2.__proto__ = Axis2;
  LogarithmicAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  LogarithmicAxis2.prototype.constructor = LogarithmicAxis2;
  LogarithmicAxis2.prototype.clone = function clone3() {
    return new LogarithmicAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  LogarithmicAxis2.prototype.startValue = function startValue() {
    return this.options.min;
  };
  LogarithmicAxis2.prototype.getSlot = function getSlot(a38, b2, limit) {
    var ref2 = this;
    var options = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options.majorUnit;
    var min4 = options.min;
    var max3 = options.max;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineBox = ref$1.lineBox;
    var lineSize = ref$1.lineSize;
    var lineStart = ref$1.lineStart;
    var step = axisDir * (lineSize / (logMax - logMin));
    var start = valueOrDefault(a38, b2 || 1);
    var end = valueOrDefault(b2, a38 || 1);
    if (start <= 0 || end <= 0) {
      return null;
    }
    if (limit) {
      start = limitValue(start, min4, max3);
      end = limitValue(end, min4, max3);
    }
    start = log(start, base);
    end = log(end, base);
    var p1 = Math.min(start, end) - logMin;
    var p22 = Math.max(start, end) - logMin;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p22));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p22 : p1));
    return slotBox;
  };
  LogarithmicAxis2.prototype.getValue = function getValue(point) {
    var ref2 = this;
    var options = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options.majorUnit;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineStart = ref$1.lineStart;
    var lineSize = ref$1.lineSize;
    var step = (logMax - logMin) / lineSize;
    var offset = axisDir * (point[axis] - lineStart);
    var valueOffset = offset * step;
    if (offset < 0 || offset > lineSize) {
      return null;
    }
    var value2 = logMin + valueOffset;
    return round(Math.pow(base, value2), DEFAULT_PRECISION);
  };
  LogarithmicAxis2.prototype.range = function range() {
    var options = this.options;
    return { min: options.min, max: options.max };
  };
  LogarithmicAxis2.prototype.translateRange = function translateRange(delta) {
    var ref2 = this;
    var options = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var reverse = options.reverse;
    var vertical = options.vertical;
    var base = options.majorUnit;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var scale = size / (logMax - logMin);
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: Math.pow(base, logMin + offset),
      max: Math.pow(base, logMax + offset),
      offset
    };
  };
  LogarithmicAxis2.prototype.labelsCount = function labelsCount() {
    var floorMax = Math.floor(this.logMax);
    var count = Math.floor(floorMax - this.logMin) + 1;
    return count;
  };
  LogarithmicAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    var ticks = [];
    this.traverseMajorTicksPositions(function(position) {
      ticks.push(position);
    }, { step: 1, skip: 0 });
    return ticks;
  };
  LogarithmicAxis2.prototype.createTicks = function createTicks(lineGroup) {
    var options = this.options;
    var majorTicks = options.majorTicks;
    var minorTicks = options.minorTicks;
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var lineBox = this.lineBox();
    var ticks = [];
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical
    };
    function render(tickPosition, tickOptions) {
      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickLineOptions.position = tickPosition;
      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
    }
    if (majorTicks.visible) {
      this.traverseMajorTicksPositions(render, majorTicks);
    }
    if (minorTicks.visible) {
      this.traverseMinorTicksPositions(render, minorTicks);
    }
    return ticks;
  };
  LogarithmicAxis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options = this.options;
    var minorGridLines = options.minorGridLines;
    var majorGridLines = options.majorGridLines;
    var vertical = options.vertical;
    var lineBox = altAxis.lineBox();
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPosition, gridLine) {
      if (!inArray(tickPosition, majorTicks)) {
        lineOptions.position = tickPosition;
        container.append(createAxisGridLine(lineOptions, gridLine));
        majorTicks.push(tickPosition);
      }
    }
    if (majorGridLines.visible) {
      this.traverseMajorTicksPositions(render, majorGridLines);
    }
    if (minorGridLines.visible) {
      this.traverseMinorTicksPositions(render, minorGridLines);
    }
    return container.children;
  };
  LogarithmicAxis2.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {
    var ref2 = this.lineInfo();
    var lineStart = ref2.lineStart;
    var step = ref2.step;
    var ref$1 = this;
    var logMin = ref$1.logMin;
    var logMax = ref$1.logMax;
    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
      var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);
      callback(position, tickOptions);
    }
  };
  LogarithmicAxis2.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {
    var this$1 = this;
    var ref2 = this.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var ref$1 = this.lineInfo();
    var lineStart = ref$1.lineStart;
    var step = ref$1.step;
    var ref$2 = this;
    var logMin = ref$2.logMin;
    var logMax = ref$2.logMax;
    var start = Math.floor(logMin);
    for (var power = start; power < logMax; power++) {
      var minorOptions = this$1._minorIntervalOptions(power);
      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
        var value2 = minorOptions.value + idx * minorOptions.minorStep;
        if (value2 > max3) {
          break;
        }
        if (value2 >= min4) {
          var position = round(lineStart + step * (log(value2, base) - logMin), DEFAULT_PRECISION);
          callback(position, tickOptions);
        }
      }
    }
  };
  LogarithmicAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var power = Math.ceil(this.logMin + index);
    var value2 = Math.pow(this.options.majorUnit, power);
    var text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  };
  LogarithmicAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return range.min <= value2 && value2 <= range.max;
  };
  LogarithmicAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  LogarithmicAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min4 = Math.min(startValue, endValue);
    var max3 = Math.max(startValue, endValue);
    return {
      min: min4,
      max: max3
    };
  };
  LogarithmicAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var ref2 = this.options;
    var base = ref2.majorUnit;
    var logMin = log(this.options.min, base);
    var logMax = log(this.options.max, base);
    var position = Math.abs(this.pointOffset(cursor));
    var range = logMax - logMin;
    var delta = this.scaleToDelta(scale, range);
    var min4 = Math.pow(base, logMin + position * delta);
    var max3 = Math.pow(base, logMax - (1 - position) * delta);
    if (max3 - min4 < MIN_VALUE_RANGE3) {
      max3 = min4 + MIN_VALUE_RANGE3;
    }
    return {
      min: min4,
      max: max3
    };
  };
  LogarithmicAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  };
  LogarithmicAxis2.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {
    var ref2 = this.options;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var value2 = Math.pow(base, power);
    var nextValue = Math.pow(base, power + 1);
    var difference = nextValue - value2;
    var minorStep = difference / minorUnit;
    return {
      value: value2,
      minorStep
    };
  };
  LogarithmicAxis2.prototype.lineInfo = function lineInfo() {
    var info = Axis2.prototype.lineInfo.call(this);
    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));
    return info;
  };
  return LogarithmicAxis2;
}(axis_default);
function initRange(autoMin, autoMax, axisOptions2, options) {
  var min4 = axisOptions2.min;
  var max3 = axisOptions2.max;
  if (defined(axisOptions2.axisCrossingValue) && axisOptions2.axisCrossingValue <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.max)) {
    max3 = autoMax;
  } else if (options.max <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.min)) {
    min4 = autoMin;
  } else if (options.min <= 0) {
    throwNegativeValuesError();
  }
  return {
    min: min4,
    max: max3
  };
}
function autoAxisMin2(min4, max3, options) {
  var base = options.majorUnit;
  var autoMin = min4;
  if (min4 <= 0) {
    autoMin = max3 <= 1 ? Math.pow(base, -2) : 1;
  } else if (!options.narrowRange) {
    autoMin = Math.pow(base, Math.floor(log(min4, base)));
  }
  return autoMin;
}
function autoAxisMax2(max3, base) {
  var logMaxRemainder = round(log(max3, base), DEFAULT_PRECISION) % 1;
  var autoMax;
  if (max3 <= 0) {
    autoMax = base;
  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
    autoMax = Math.pow(base, log(max3, base) + 0.2);
  } else {
    autoMax = Math.pow(base, Math.ceil(log(max3, base)));
  }
  return autoMax;
}
function throwNegativeValuesError() {
  throw new Error("Non positive values cannot be used for a logarithmic axis");
}
function log(x5, base) {
  return Math.log(x5) / Math.log(base);
}
setDefaultOptions(LogarithmicAxis, {
  type: "log",
  majorUnit: DEFAULT_MAJOR_UNIT,
  minorUnit: 1,
  axisCrossingValue: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  zIndex: 1,
  _deferLabels: true
});
var logarithmic_axis_default = LogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/grid-lines-mixin.js
var GridLinesMixin = {
  createGridLines: function(altAxis) {
    var options = this.options;
    var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);
    var gridLines = [];
    var skipMajor = false;
    var majorAngles, minorAngles;
    if (options.majorGridLines.visible) {
      majorAngles = this.majorGridLineAngles(altAxis);
      skipMajor = true;
      gridLines = this.renderMajorGridLines(
        majorAngles,
        radius,
        options.majorGridLines
      );
    }
    if (options.minorGridLines.visible) {
      minorAngles = this.minorGridLineAngles(altAxis, skipMajor);
      append(gridLines, this.renderMinorGridLines(
        minorAngles,
        radius,
        options.minorGridLines,
        altAxis,
        skipMajor
      ));
    }
    return gridLines;
  },
  renderMajorGridLines: function(angles, radius, options) {
    return this.renderGridLines(angles, radius, options);
  },
  renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {
    var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);
    return this.renderGridLines(angles, radius, options, radiusCallback);
  },
  renderGridLines: function(angles, radius, options, radiusCallback) {
    var style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    var center = this.box.center();
    var circle = new geometry_exports.Circle([center.x, center.y], radius);
    var container = this.gridLinesVisual();
    for (var i36 = 0; i36 < angles.length; i36++) {
      var line = new drawing_exports.Path(style);
      if (radiusCallback) {
        circle.radius = radiusCallback(angles[i36]);
      }
      line.moveTo(circle.center).lineTo(circle.pointAt(angles[i36] + 180));
      container.append(line);
    }
    return container.children;
  },
  gridLineAngles: function(altAxis, size, skip, step, skipAngles) {
    var this$1 = this;
    var divs = this.intervals(size, skip, step, skipAngles);
    var options = altAxis.options;
    var altAxisVisible = options.visible && (options.line || {}).visible !== false;
    return map(divs, function(d6) {
      var alpha = this$1.intervalAngle(d6);
      if (!altAxisVisible || alpha !== 90) {
        return alpha;
      }
    });
  }
};
var grid_lines_mixin_default = GridLinesMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-category-axis.js
var RadarCategoryAxis = function(CategoryAxis2) {
  function RadarCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2) RadarCategoryAxis2.__proto__ = CategoryAxis2;
  RadarCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  RadarCategoryAxis2.prototype.constructor = RadarCategoryAxis2;
  RadarCategoryAxis2.prototype.range = function range() {
    return { min: 0, max: this.options.categories.length };
  };
  RadarCategoryAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  RadarCategoryAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  RadarCategoryAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    for (var i36 = 0; i36 < labels.length; i36++) {
      labels[i36].reflow(measureBox);
      var labelBox = labels[i36].box;
      labels[i36].reflow(this$1.getSlot(skip + i36 * step).adjacentBox(
        0,
        labelBox.width(),
        labelBox.height()
      ));
    }
  };
  RadarCategoryAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0) skipAngles = false;
    var options = this.options;
    var categories = options.categories.length;
    var divCount = categories / size || 1;
    var divAngle = 360 / divCount;
    var skip = skipOption || 0;
    var step = stepOption || 1;
    var divs = [];
    var angle = 0;
    for (var i36 = skip; i36 < divCount; i36 += step) {
      if (options.reverse) {
        angle = 360 - i36 * divAngle;
      } else {
        angle = i36 * divAngle;
      }
      angle = round(angle, COORD_PRECISION) % 360;
      if (!(skipAngles && inArray(angle, skipAngles))) {
        divs.push(angle);
      }
    }
    return divs;
  };
  RadarCategoryAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(1);
  };
  RadarCategoryAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(0.5);
  };
  RadarCategoryAxis2.prototype.intervalAngle = function intervalAngle(interval) {
    return (360 + interval + this.options.startAngle) % 360;
  };
  RadarCategoryAxis2.prototype.majorAngles = function majorAngles() {
    var this$1 = this;
    return map(this.majorIntervals(), function(interval) {
      return this$1.intervalAngle(interval);
    });
  };
  RadarCategoryAxis2.prototype.createLine = function createLine() {
    return [];
  };
  RadarCategoryAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);
  };
  RadarCategoryAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var ref2 = this.options;
    var minorGridLines = ref2.minorGridLines;
    var majorGridLines = ref2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  RadarCategoryAxis2.prototype.radiusCallback = function radiusCallback(radius, altAxis, skipMajor) {
    if (altAxis.options.type !== ARC) {
      var minorAngle = rad(360 / (this.options.categories.length * 2));
      var minorRadius = Math.cos(minorAngle) * radius;
      var majorAngles = this.majorAngles();
      var radiusCallback2 = function(angle) {
        if (!skipMajor && inArray(angle, majorAngles)) {
          return radius;
        }
        return minorRadius;
      };
      return radiusCallback2;
    }
  };
  RadarCategoryAxis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var plotBands = this.options.plotBands || [];
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i36 = 0; i36 < plotBands.length; i36++) {
      var band = plotBands[i36];
      var slot = this$1.plotBandSlot(band);
      var singleSlot = this$1.getSlot(band.from);
      var head = band.from - Math.floor(band.from);
      slot.startAngle += head * singleSlot.angle;
      var tail = Math.ceil(band.to) - band.to;
      slot.angle -= (tail + head) * singleSlot.angle;
      var ring = shape_builder_default.current.createRing(slot, {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      });
      group.append(ring);
    }
    this.appendVisual(group);
  };
  RadarCategoryAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to - 1);
  };
  RadarCategoryAxis2.prototype.getSlot = function getSlot(from, to) {
    var options = this.options;
    var justified = options.justified;
    var box = this.box;
    var divs = this.majorAngles();
    var totalDivs = divs.length;
    var slotAngle = 360 / totalDivs;
    var fromValue = from;
    if (options.reverse && !justified) {
      fromValue = (fromValue + 1) % totalDivs;
    }
    fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);
    var slotStart = divs[fromValue];
    if (justified) {
      slotStart = slotStart - slotAngle / 2;
      if (slotStart < 0) {
        slotStart += 360;
      }
    }
    var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);
    var slots = toValue - fromValue + 1;
    var angle = slotAngle * slots;
    return new ring_default(box.center(), 0, box.height() / 2, slotStart, angle);
  };
  RadarCategoryAxis2.prototype.slot = function slot(from, to) {
    var slot2 = this.getSlot(from, to);
    var startAngle = slot2.startAngle + 180;
    var endAngle = startAngle + slot2.angle;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  RadarCategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point) {
    var this$1 = this;
    var length = this.options.categories.length;
    var index = null;
    for (var i36 = 0; i36 < length; i36++) {
      var slot = this$1.getSlot(i36);
      if (slot.containsPoint(point)) {
        index = i36;
        break;
      }
    }
    return index;
  };
  return RadarCategoryAxis2;
}(category_axis_default);
setDefaultOptions(RadarCategoryAxis, {
  startAngle: 90,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    visible: true
  },
  justified: true
});
deepExtend(RadarCategoryAxis.prototype, grid_lines_mixin_default);
var radar_category_axis_default = RadarCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/polar-axis.js
var PolarAxis = function(Axis2) {
  function PolarAxis2(options, chartService) {
    Axis2.call(this, options, chartService);
    var instanceOptions = this.options;
    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;
  }
  if (Axis2) PolarAxis2.__proto__ = Axis2;
  PolarAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  PolarAxis2.prototype.constructor = PolarAxis2;
  PolarAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    return numeric_axis_default.prototype.getDivisions.call(this, stepValue) - 1;
  };
  PolarAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  PolarAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    var divs = this.intervals(options.majorUnit, skip, step);
    for (var i36 = 0; i36 < labels.length; i36++) {
      labels[i36].reflow(measureBox);
      var labelBox = labels[i36].box;
      labels[i36].reflow(this$1.getSlot(divs[i36]).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  };
  PolarAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  PolarAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0) skipAngles = false;
    var min4 = this.options.min;
    var divisions = this.getDivisions(size);
    var divs = [];
    var skip = skipOption || 0;
    var step = stepOption || 1;
    for (var i36 = skip; i36 < divisions; i36 += step) {
      var current4 = (360 + min4 + i36 * size) % 360;
      if (!(skipAngles && inArray(current4, skipAngles))) {
        divs.push(current4);
      }
    }
    return divs;
  };
  PolarAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(this.options.majorUnit);
  };
  PolarAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(this.options.minorUnit);
  };
  PolarAxis2.prototype.intervalAngle = function intervalAngle(i36) {
    return (540 - i36 - this.options.startAngle) % 360;
  };
  PolarAxis2.prototype.createLine = function createLine() {
    return [];
  };
  PolarAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);
  };
  PolarAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var options = this.options;
    var minorGridLines = options.minorGridLines;
    var majorGridLines = options.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  PolarAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to);
  };
  PolarAxis2.prototype.getSlot = function getSlot(a38, b2) {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var startAngle = options.startAngle;
    var start = limitValue(a38, options.min, options.max);
    var end = limitValue(b2 || start, start, options.max);
    if (options.reverse) {
      start *= -1;
      end *= -1;
    }
    start = (540 - start - startAngle) % 360;
    end = (540 - end - startAngle) % 360;
    if (end < start) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    return new ring_default(box.center(), 0, box.height() / 2, start, end - start);
  };
  PolarAxis2.prototype.slot = function slot(from, to) {
    if (to === void 0) to = from;
    var options = this.options;
    var start = 360 - options.startAngle;
    var slot2 = this.getSlot(from, to);
    var min4 = Math.min(from, to);
    var max3 = Math.max(from, to);
    var startAngle, endAngle;
    if (options.reverse) {
      startAngle = min4;
      endAngle = max3;
    } else {
      startAngle = 360 - max3;
      endAngle = 360 - min4;
    }
    startAngle = (startAngle + start) % 360;
    endAngle = (endAngle + start) % 360;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  PolarAxis2.prototype.getValue = function getValue(point) {
    var options = this.options;
    var center = this.box.center();
    var dx = point.x - center.x;
    var dy = point.y - center.y;
    var theta = Math.round(deg(Math.atan2(dy, dx)));
    var start = options.startAngle;
    if (!options.reverse) {
      theta *= -1;
      start *= -1;
    }
    return (theta + start + 360) % 360;
  };
  PolarAxis2.prototype.valueRange = function valueRange3() {
    return {
      min: 0,
      max: Math.PI * 2
    };
  };
  return PolarAxis2;
}(axis_default);
setDefaultOptions(PolarAxis, {
  type: "polar",
  startAngle: 0,
  reverse: false,
  majorUnit: 60,
  min: 0,
  max: 360,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    color: BLACK,
    visible: true,
    width: 1
  },
  minorGridLines: {
    color: "#aaa"
  }
});
deepExtend(PolarAxis.prototype, grid_lines_mixin_default, {
  createPlotBands: radar_category_axis_default.prototype.createPlotBands,
  majorAngles: radar_category_axis_default.prototype.majorAngles,
  range: numeric_axis_default.prototype.range,
  labelsCount: numeric_axis_default.prototype.labelsCount,
  createAxisLabel: numeric_axis_default.prototype.createAxisLabel
});
var polar_axis_default = PolarAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/radar-numeric-axis-mixin.js
var RadarNumericAxisMixin = {
  options: {
    majorGridLines: {
      visible: true
    }
  },
  createPlotBands: function() {
    var this$1 = this;
    var ref2 = this.options;
    var type = ref2.majorGridLines.type;
    var plotBands = ref2.plotBands;
    if (plotBands === void 0) plotBands = [];
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i36 = 0; i36 < plotBands.length; i36++) {
      var band = plotBands[i36];
      var bandStyle = {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      };
      var slot = this$1.getSlot(band.from, band.to, true);
      var ring = new ring_default(center, center.y - slot.y2, center.y - slot.y1, 0, 360);
      var shape = void 0;
      if (type === ARC) {
        shape = shape_builder_default.current.createRing(ring, bandStyle);
      } else {
        shape = drawing_exports.Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();
      }
      group.append(shape);
    }
    this.appendVisual(group);
  },
  plotBandPoints: function(ring, angles) {
    var innerPoints = [];
    var outerPoints = [];
    var center = [ring.center.x, ring.center.y];
    var innerCircle = new geometry_exports.Circle(center, ring.innerRadius);
    var outerCircle = new geometry_exports.Circle(center, ring.radius);
    for (var i36 = 0; i36 < angles.length; i36++) {
      innerPoints.push(innerCircle.pointAt(angles[i36] + 180));
      outerPoints.push(outerCircle.pointAt(angles[i36] + 180));
    }
    innerPoints.reverse();
    innerPoints.push(innerPoints[0]);
    outerPoints.push(outerPoints[0]);
    return outerPoints.concat(innerPoints);
  },
  createGridLines: function(altAxis) {
    var options = this.options;
    var majorTicks = this.radarMajorGridLinePositions();
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var gridLines = [];
    if (options.majorGridLines.visible) {
      gridLines = this.renderGridLines(
        center,
        majorTicks,
        majorAngles,
        options.majorGridLines
      );
    }
    if (options.minorGridLines.visible) {
      var minorTicks = this.radarMinorGridLinePositions();
      append(gridLines, this.renderGridLines(
        center,
        minorTicks,
        majorAngles,
        options.minorGridLines
      ));
    }
    return gridLines;
  },
  renderGridLines: function(center, ticks, angles, options) {
    var style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    var skip = options.skip;
    if (skip === void 0) skip = 0;
    var step = options.step;
    if (step === void 0) step = 0;
    var container = this.gridLinesVisual();
    for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {
      var tickRadius = center.y - ticks[tickIx];
      if (tickRadius > 0) {
        var circle = new geometry_exports.Circle([center.x, center.y], tickRadius);
        if (options.type === ARC) {
          container.append(new drawing_exports.Circle(circle, style));
        } else {
          var line = new drawing_exports.Path(style);
          for (var angleIx = 0; angleIx < angles.length; angleIx++) {
            line.lineTo(circle.pointAt(angles[angleIx] + 180));
          }
          line.close();
          container.append(line);
        }
      }
    }
    return container.children;
  },
  getValue: function(point) {
    var lineBox = this.lineBox();
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var radius = point.distanceTo(center);
    var distance = radius;
    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {
      var dx = point.x - center.x;
      var dy = point.y - center.y;
      var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;
      majorAngles.sort(function(a38, b2) {
        return angularDistance(a38, theta) - angularDistance(b2, theta);
      });
      var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;
      var alpha = angularDistance(theta, majorAngles[0]);
      var gamma = 90 - midAngle;
      var beta = 180 - alpha - gamma;
      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));
    }
    return this.axisType().prototype.getValue.call(
      this,
      new point_default(lineBox.x1, lineBox.y2 - distance)
    );
  }
};
function angularDistance(a38, b2) {
  return 180 - Math.abs(Math.abs(a38 - b2) - 180);
}
var radar_numeric_axis_mixin_default = RadarNumericAxisMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-numeric-axis.js
var RadarNumericAxis = function(NumericAxis2) {
  function RadarNumericAxis2() {
    NumericAxis2.apply(this, arguments);
  }
  if (NumericAxis2) RadarNumericAxis2.__proto__ = NumericAxis2;
  RadarNumericAxis2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadarNumericAxis2.prototype.constructor = RadarNumericAxis2;
  RadarNumericAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  RadarNumericAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var options = this.options;
    var minorSkipStep = 0;
    if (options.majorGridLines.visible) {
      minorSkipStep = options.majorUnit;
    }
    return this.getTickPositions(options.minorUnit, minorSkipStep);
  };
  RadarNumericAxis2.prototype.axisType = function axisType() {
    return NumericAxis2;
  };
  return RadarNumericAxis2;
}(numeric_axis_default);
deepExtend(RadarNumericAxis.prototype, radar_numeric_axis_mixin_default);
var radar_numeric_axis_default = RadarNumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/radar-logarithmic-axis.js
var RadarLogarithmicAxis = function(LogarithmicAxis2) {
  function RadarLogarithmicAxis2() {
    LogarithmicAxis2.apply(this, arguments);
  }
  if (LogarithmicAxis2) RadarLogarithmicAxis2.__proto__ = LogarithmicAxis2;
  RadarLogarithmicAxis2.prototype = Object.create(LogarithmicAxis2 && LogarithmicAxis2.prototype);
  RadarLogarithmicAxis2.prototype.constructor = RadarLogarithmicAxis2;
  RadarLogarithmicAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    var positions = [];
    this.traverseMajorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.majorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var positions = [];
    this.traverseMinorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.minorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.axisType = function axisType() {
    return LogarithmicAxis2;
  };
  return RadarLogarithmicAxis2;
}(logarithmic_axis_default);
deepExtend(RadarLogarithmicAxis.prototype, radar_numeric_axis_mixin_default);
var radar_logarithmic_axis_default = RadarLogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var CurveProcessor = function(Class) {
  function CurveProcessor2(closed) {
    Class.call(this);
    this.closed = closed;
  }
  if (Class) CurveProcessor2.__proto__ = Class;
  CurveProcessor2.prototype = Object.create(Class && Class.prototype);
  CurveProcessor2.prototype.constructor = CurveProcessor2;
  CurveProcessor2.prototype.process = function process(dataPoints) {
    var this$1 = this;
    var points = dataPoints.slice(0);
    var segments = [];
    var closed = this.closed;
    var length = points.length;
    if (length > 2) {
      this.removeDuplicates(0, points);
      length = points.length;
    }
    if (length < 2 || length === 2 && points[0].equals(points[1])) {
      return segments;
    }
    var p0 = points[0];
    var p1 = points[1];
    var p22 = points[2];
    segments.push(new geometry_exports.Segment(p0));
    while (p0.equals(points[length - 1])) {
      closed = true;
      points.pop();
      length--;
    }
    if (length === 2) {
      var tangent = this.tangent(p0, p1, X, Y);
      last(segments).controlOut(
        this.firstControlPoint(tangent, p0, p1, X, Y)
      );
      segments.push(new geometry_exports.Segment(
        p1,
        this.secondControlPoint(tangent, p0, p1, X, Y)
      ));
      return segments;
    }
    var initialControlPoint, lastControlPoint;
    if (closed) {
      p0 = points[length - 1];
      p1 = points[0];
      p22 = points[1];
      var controlPoints = this.controlPoints(p0, p1, p22);
      initialControlPoint = controlPoints[1];
      lastControlPoint = controlPoints[0];
    } else {
      var tangent$1 = this.tangent(p0, p1, X, Y);
      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);
    }
    var cp0 = initialControlPoint;
    for (var idx = 0; idx <= length - 3; idx++) {
      this$1.removeDuplicates(idx, points);
      length = points.length;
      if (idx + 3 <= length) {
        p0 = points[idx];
        p1 = points[idx + 1];
        p22 = points[idx + 2];
        var controlPoints$1 = this$1.controlPoints(p0, p1, p22);
        last(segments).controlOut(cp0);
        cp0 = controlPoints$1[1];
        var cp1 = controlPoints$1[0];
        segments.push(new geometry_exports.Segment(p1, cp1));
      }
    }
    if (closed) {
      p0 = points[length - 2];
      p1 = points[length - 1];
      p22 = points[0];
      var controlPoints$2 = this.controlPoints(p0, p1, p22);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p1,
        controlPoints$2[0]
      ));
      last(segments).controlOut(controlPoints$2[1]);
      segments.push(new geometry_exports.Segment(
        p22,
        lastControlPoint
      ));
    } else {
      var tangent$2 = this.tangent(p1, p22, X, Y);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p22,
        this.secondControlPoint(tangent$2, p1, p22, X, Y)
      ));
    }
    return segments;
  };
  CurveProcessor2.prototype.removeDuplicates = function removeDuplicates(idx, points) {
    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {
      points.splice(idx + 1, 1);
    }
  };
  CurveProcessor2.prototype.invertAxis = function invertAxis(p0, p1, p22) {
    var invertAxis2 = false;
    if (p0.x === p1.x) {
      invertAxis2 = true;
    } else if (p1.x === p22.x) {
      if (p1.y < p22.y && p0.y <= p1.y || p22.y < p1.y && p1.y <= p0.y) {
        invertAxis2 = true;
      }
    } else {
      var fn = this.lineFunction(p0, p1);
      var y2 = this.calculateFunction(fn, p22.x);
      if (!(p0.y <= p1.y && p22.y <= y2) && !(p1.y <= p0.y && p22.y >= y2)) {
        invertAxis2 = true;
      }
    }
    return invertAxis2;
  };
  CurveProcessor2.prototype.isLine = function isLine(p0, p1, p22) {
    var fn = this.lineFunction(p0, p1);
    var y2 = this.calculateFunction(fn, p22.x);
    return p0.x === p1.x && p1.x === p22.x || round(y2, 1) === round(p22.y, 1);
  };
  CurveProcessor2.prototype.lineFunction = function lineFunction(p1, p22) {
    var a38 = (p22.y - p1.y) / (p22.x - p1.x);
    var b2 = p1.y - a38 * p1.x;
    return [b2, a38];
  };
  CurveProcessor2.prototype.controlPoints = function controlPoints(p0, p1, p22) {
    var xField = X;
    var yField = Y;
    var restrict = false;
    var switchOrientation = false;
    var tangent;
    if (this.isLine(p0, p1, p22)) {
      tangent = this.tangent(p0, p1, X, Y);
    } else {
      var monotonic = {
        x: this.isMonotonicByField(p0, p1, p22, X),
        y: this.isMonotonicByField(p0, p1, p22, Y)
      };
      if (monotonic.x && monotonic.y) {
        tangent = this.tangent(p0, p22, X, Y);
        restrict = true;
      } else {
        if (this.invertAxis(p0, p1, p22)) {
          xField = Y;
          yField = X;
        }
        if (monotonic[xField]) {
          tangent = 0;
        } else {
          var sign;
          if (p22[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p22[yField] && p1[yField] <= p0[yField]) {
            sign = numberSign((p22[yField] - p0[yField]) * (p1[xField] - p0[xField]));
          } else {
            sign = -numberSign((p22[xField] - p0[xField]) * (p1[yField] - p0[yField]));
          }
          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
          switchOrientation = true;
        }
      }
    }
    var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);
    if (switchOrientation) {
      var oldXField = xField;
      xField = yField;
      yField = oldXField;
    }
    var firstControlPoint = this.firstControlPoint(tangent, p1, p22, xField, yField);
    if (restrict) {
      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);
      this.restrictControlPoint(p1, p22, firstControlPoint, tangent);
    }
    return [secondControlPoint, firstControlPoint];
  };
  CurveProcessor2.prototype.restrictControlPoint = function restrictControlPoint(p1, p22, cp, tangent) {
    if (p1.y < p22.y) {
      if (p22.y < cp.y) {
        cp.x = p1.x + (p22.y - p1.y) / tangent;
        cp.y = p22.y;
      } else if (cp.y < p1.y) {
        cp.x = p22.x - (p22.y - p1.y) / tangent;
        cp.y = p1.y;
      }
    } else {
      if (cp.y < p22.y) {
        cp.x = p1.x - (p1.y - p22.y) / tangent;
        cp.y = p22.y;
      } else if (p1.y < cp.y) {
        cp.x = p22.x + (p1.y - p22.y) / tangent;
        cp.y = p1.y;
      }
    }
  };
  CurveProcessor2.prototype.tangent = function tangent(p0, p1, xField, yField) {
    var x5 = p1[xField] - p0[xField];
    var y = p1[yField] - p0[yField];
    var tangent2;
    if (x5 === 0) {
      tangent2 = 0;
    } else {
      tangent2 = y / x5;
    }
    return tangent2;
  };
  CurveProcessor2.prototype.isMonotonicByField = function isMonotonicByField(p0, p1, p22, field) {
    return p22[field] > p1[field] && p1[field] > p0[field] || p22[field] < p1[field] && p1[field] < p0[field];
  };
  CurveProcessor2.prototype.firstControlPoint = function firstControlPoint(tangent, p0, p32, xField, yField) {
    var t1 = p0[xField];
    var t210 = p32[xField];
    var distance = (t210 - t1) * WEIGHT;
    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.secondControlPoint = function secondControlPoint(tangent, p0, p32, xField, yField) {
    var t1 = p0[xField];
    var t210 = p32[xField];
    var distance = (t210 - t1) * WEIGHT;
    return this.point(t210 - distance, p32[yField] - distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.point = function point(xValue, yValue, xField, yField) {
    var controlPoint = new geometry_exports.Point();
    controlPoint[xField] = xValue;
    controlPoint[yField] = yValue;
    return controlPoint;
  };
  CurveProcessor2.prototype.calculateFunction = function calculateFunction(fn, x5) {
    var length = fn.length;
    var result = 0;
    for (var i36 = 0; i36 < length; i36++) {
      result += Math.pow(x5, i36) * fn[i36];
    }
    return result;
  };
  return CurveProcessor2;
}(class_default);
function numberSign(value2) {
  return value2 <= 0 ? -1 : 1;
}
var curve_processor_default = CurveProcessor;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-axis.js
var ChartAxis = function(Class) {
  function ChartAxis2(axis) {
    Class.call(this);
    this._axis = axis;
    this.options = axis.options;
  }
  if (Class) ChartAxis2.__proto__ = Class;
  ChartAxis2.prototype = Object.create(Class && Class.prototype);
  ChartAxis2.prototype.constructor = ChartAxis2;
  ChartAxis2.prototype.value = function value2(point) {
    var axis = this._axis;
    var value3 = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);
    return value3;
  };
  ChartAxis2.prototype.slot = function slot(from, to, limit) {
    if (limit === void 0) limit = true;
    return this._axis.slot(from, to, limit);
  };
  ChartAxis2.prototype.range = function range() {
    return this._axis.range();
  };
  ChartAxis2.prototype.valueRange = function valueRange3() {
    return this._axis.valueRange();
  };
  return ChartAxis2;
}(class_default);
var chart_axis_default = ChartAxis;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/find-axis-by-name.js
function findAxisByName(name2, axes) {
  for (var idx = 0; idx < axes.length; idx++) {
    if (axes[idx].options.name === name2) {
      axes[idx].prepareUserOptions();
      return new chart_axis_default(axes[idx]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-pane.js
var ChartPane = function ChartPane2(pane) {
  this.visual = pane.visual;
  this.chartsVisual = pane.chartContainer.visual;
  this._pane = pane;
};
ChartPane.prototype.findAxisByName = function findAxisByName$1(name2) {
  return findAxisByName(name2, this._pane.axes);
};
var chart_pane_default = ChartPane;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-plotarea.js
var ChartPlotArea = function(Class) {
  function ChartPlotArea2(plotArea) {
    Class.call(this);
    this._plotArea = plotArea;
    this.visual = plotArea.visual;
    this.backgroundVisual = plotArea._bgVisual;
  }
  if (Class) ChartPlotArea2.__proto__ = Class;
  ChartPlotArea2.prototype = Object.create(Class && Class.prototype);
  ChartPlotArea2.prototype.constructor = ChartPlotArea2;
  return ChartPlotArea2;
}(class_default);
var chart_plotarea_default = ChartPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/count-numbers.js
function countNumbers(values5) {
  var length = values5.length;
  var count = 0;
  for (var i36 = 0; i36 < length; i36++) {
    var num = values5[i36];
    if (isNumber(num)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/aggregates.js
var Aggregates = {
  min: function(values5) {
    var length = values5.length;
    var min4 = MAX_VALUE;
    for (var i36 = 0; i36 < length; i36++) {
      var value2 = values5[i36];
      if (isNumber(value2)) {
        min4 = Math.min(min4, value2);
      }
    }
    return min4 === MAX_VALUE ? values5[0] : min4;
  },
  max: function(values5) {
    var length = values5.length;
    var max3 = MIN_VALUE;
    for (var i36 = 0; i36 < length; i36++) {
      var value2 = values5[i36];
      if (isNumber(value2)) {
        max3 = Math.max(max3, value2);
      }
    }
    return max3 === MIN_VALUE ? values5[0] : max3;
  },
  sum: function(values5) {
    var length = values5.length;
    var sum2 = 0;
    for (var i36 = 0; i36 < length; i36++) {
      var value2 = values5[i36];
      if (isNumber(value2)) {
        sum2 += value2;
      }
    }
    return sum2;
  },
  sumOrNull: function(values5) {
    var result = null;
    if (countNumbers(values5)) {
      result = Aggregates.sum(values5);
    }
    return result;
  },
  count: function(values5) {
    var length = values5.length;
    var count = 0;
    for (var i36 = 0; i36 < length; i36++) {
      var value2 = values5[i36];
      if (value2 !== null && defined(value2)) {
        count++;
      }
    }
    return count;
  },
  avg: function(values5) {
    var count = countNumbers(values5);
    var result = values5[0];
    if (count > 0) {
      result = Aggregates.sum(values5) / count;
    }
    return result;
  },
  first: function(values5) {
    var length = values5.length;
    for (var i36 = 0; i36 < length; i36++) {
      var value2 = values5[i36];
      if (value2 !== null && defined(value2)) {
        return value2;
      }
    }
    return values5[0];
  }
};
var aggregates_default = Aggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-field.js
function getField(field, row) {
  if (row === null) {
    return row;
  }
  var get3 = getter(field, true);
  return get3(row);
}

// node_modules/@progress/kendo-charts/dist/es/chart/series-binder.js
var SeriesBinder = function(Class) {
  function SeriesBinder2() {
    Class.call(this);
    this._valueFields = {};
    this._otherFields = {};
    this._nullValue = {};
    this._undefinedValue = {};
  }
  if (Class) SeriesBinder2.__proto__ = Class;
  SeriesBinder2.prototype = Object.create(Class && Class.prototype);
  SeriesBinder2.prototype.constructor = SeriesBinder2;
  SeriesBinder2.prototype.register = function register4(seriesTypes, valueFields, otherFields) {
    var this$1 = this;
    if (valueFields === void 0) valueFields = [VALUE];
    if (otherFields === void 0) otherFields = {};
    for (var i36 = 0; i36 < seriesTypes.length; i36++) {
      var type = seriesTypes[i36];
      this$1._valueFields[type] = valueFields;
      this$1._otherFields[type] = otherFields;
      this$1._nullValue[type] = this$1._makeValue(valueFields, null);
      this$1._undefinedValue[type] = this$1._makeValue(valueFields, void 0);
    }
  };
  SeriesBinder2.prototype.canonicalFields = function canonicalFields(series) {
    return this.valueFields(series).concat(this.otherFields(series));
  };
  SeriesBinder2.prototype.valueFields = function valueFields(series) {
    return this._valueFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.otherFields = function otherFields(series) {
    return this._otherFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var data = series.data;
    var pointData = defined(item) ? item : data[pointIx];
    var result = { valueFields: { value: pointData } };
    var valueFields = this.valueFields(series);
    var otherFields = this._otherFields[series.type];
    var fields, value2;
    if (pointData === null) {
      value2 = this._nullValue[series.type];
    } else if (!defined(pointData)) {
      value2 = this._undefinedValue[series.type];
    } else if (Array.isArray(pointData)) {
      var fieldData = pointData.slice(valueFields.length);
      value2 = this._bindFromArray(pointData, valueFields);
      fields = this._bindFromArray(fieldData, otherFields);
    } else if (typeof pointData === "object") {
      var srcValueFields = this.sourceFields(series, valueFields);
      var srcPointFields = this.sourceFields(series, otherFields);
      value2 = this._bindFromObject(pointData, valueFields, srcValueFields);
      fields = this._bindFromObject(pointData, otherFields, srcPointFields);
    }
    if (defined(value2)) {
      if (valueFields.length === 1) {
        result.valueFields.value = value2[valueFields[0]];
      } else {
        result.valueFields = value2;
      }
    }
    result.fields = fields || {};
    return result;
  };
  SeriesBinder2.prototype._makeValue = function _makeValue(fields, initialValue) {
    var value2 = {};
    var length = fields.length;
    for (var i36 = 0; i36 < length; i36++) {
      var fieldName = fields[i36];
      value2[fieldName] = initialValue;
    }
    return value2;
  };
  SeriesBinder2.prototype._bindFromArray = function _bindFromArray(array, fields) {
    var value2 = {};
    if (fields) {
      var length = Math.min(fields.length, array.length);
      for (var i36 = 0; i36 < length; i36++) {
        value2[fields[i36]] = array[i36];
      }
    }
    return value2;
  };
  SeriesBinder2.prototype._bindFromObject = function _bindFromObject(object, fields, srcFields) {
    if (srcFields === void 0) srcFields = fields;
    var value2 = {};
    if (fields) {
      var length = fields.length;
      for (var i36 = 0; i36 < length; i36++) {
        var fieldName = fields[i36];
        var srcFieldName = srcFields[i36];
        if (srcFieldName !== null) {
          value2[fieldName] = getField(srcFieldName, object);
        }
      }
    }
    return value2;
  };
  SeriesBinder2.prototype.sourceFields = function sourceFields(series, canonicalFields) {
    var sourceFields2 = [];
    if (canonicalFields) {
      var length = canonicalFields.length;
      for (var i36 = 0; i36 < length; i36++) {
        var fieldName = canonicalFields[i36];
        var sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";
        sourceFields2.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);
      }
    }
    return sourceFields2;
  };
  return SeriesBinder2;
}(class_default);
SeriesBinder.current = new SeriesBinder();
var series_binder_default = SeriesBinder;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-range-calculator.js
var STD_ERR = "stderr";
var STD_DEV = "stddev";
var percentRegex = /percent(?:\w*)\((\d+)\)/;
var standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\((\\d+(?:\\.\\d+)?)\\))?$");
var ErrorRangeCalculator = function(Class) {
  function ErrorRangeCalculator2(errorValue, series, field) {
    Class.call(this);
    this.initGlobalRanges(errorValue, series, field);
  }
  if (Class) ErrorRangeCalculator2.__proto__ = Class;
  ErrorRangeCalculator2.prototype = Object.create(Class && Class.prototype);
  ErrorRangeCalculator2.prototype.constructor = ErrorRangeCalculator2;
  ErrorRangeCalculator2.prototype.initGlobalRanges = function initGlobalRanges(errorValue, series, field) {
    var data = series.data;
    var deviationMatch = standardDeviationRegex.exec(errorValue);
    if (deviationMatch) {
      this.valueGetter = this.createValueGetter(series, field);
      var average = this.getAverage(data);
      var deviation = this.getStandardDeviation(data, average, false);
      var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;
      var errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };
      this.globalRange = function() {
        return errorRange;
      };
    } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {
      this.valueGetter = this.createValueGetter(series, field);
      var standardError = this.getStandardError(data, this.getAverage(data));
      this.globalRange = function(value2) {
        return { low: value2 - standardError, high: value2 + standardError };
      };
    }
  };
  ErrorRangeCalculator2.prototype.createValueGetter = function createValueGetter(series, field) {
    var data = series.data;
    var binder = series_binder_default.current;
    var valueFields = binder.valueFields(series);
    var item = defined(data[0]) ? data[0] : {};
    var valueGetter10;
    if (isArray(item)) {
      var index = field ? valueFields.indexOf(field) : 0;
      valueGetter10 = getter("[" + index + "]");
    } else if (isNumber(item)) {
      valueGetter10 = getter();
    } else if (typeof item === OBJECT) {
      var srcValueFields = binder.sourceFields(series, valueFields);
      valueGetter10 = getter(srcValueFields[valueFields.indexOf(field)]);
    }
    return valueGetter10;
  };
  ErrorRangeCalculator2.prototype.getErrorRange = function getErrorRange(pointValue, errorValue) {
    var low, high, value2;
    if (!defined(errorValue)) {
      return null;
    }
    if (this.globalRange) {
      return this.globalRange(pointValue);
    }
    if (isArray(errorValue)) {
      low = pointValue - errorValue[0];
      high = pointValue + errorValue[1];
    } else if (isNumber(value2 = parseFloat(errorValue))) {
      low = pointValue - value2;
      high = pointValue + value2;
    } else if (value2 = percentRegex.exec(errorValue)) {
      var percentValue = pointValue * (parseFloat(value2[1]) / 100);
      low = pointValue - Math.abs(percentValue);
      high = pointValue + Math.abs(percentValue);
    } else {
      throw new Error("Invalid ErrorBar value: " + errorValue);
    }
    return { low, high };
  };
  ErrorRangeCalculator2.prototype.getStandardError = function getStandardError(data, average) {
    return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);
  };
  ErrorRangeCalculator2.prototype.getStandardDeviation = function getStandardDeviation(data, average, isSample) {
    var this$1 = this;
    var length = data.length;
    var total3 = isSample ? average.count - 1 : average.count;
    var squareDifferenceSum = 0;
    for (var idx = 0; idx < length; idx++) {
      var value2 = this$1.valueGetter(data[idx]);
      if (isNumber(value2)) {
        squareDifferenceSum += Math.pow(value2 - average.value, 2);
      }
    }
    return Math.sqrt(squareDifferenceSum / total3);
  };
  ErrorRangeCalculator2.prototype.getAverage = function getAverage(data) {
    var this$1 = this;
    var length = data.length;
    var sum2 = 0;
    var count = 0;
    for (var idx = 0; idx < length; idx++) {
      var value2 = this$1.valueGetter(data[idx]);
      if (isNumber(value2)) {
        sum2 += value2;
        count++;
      }
    }
    return {
      value: sum2 / count,
      count
    };
  };
  return ErrorRangeCalculator2;
}(class_default);
var error_range_calculator_default = ErrorRangeCalculator;

// node_modules/@progress/kendo-charts/dist/es/chart/constants.js
var browser2 = support_default.browser || {};
var INITIAL_ANIMATION_DURATION = 600;
var FADEIN = "fadeIn";
var BORDER_BRIGHTNESS = 0.8;
var TOOLTIP_OFFSET = 5;
var START_SCALE = browser2.msie ? 1e-3 : 0;
var ERROR_LOW_FIELD = "errorLow";
var ERROR_HIGH_FIELD = "errorHigh";
var X_ERROR_LOW_FIELD = "xErrorLow";
var X_ERROR_HIGH_FIELD = "xErrorHigh";
var Y_ERROR_LOW_FIELD = "yErrorLow";
var Y_ERROR_HIGH_FIELD = "yErrorHigh";
var LINE_MARKER_SIZE = 8;
var ZERO = "zero";
var INTERPOLATE = "interpolate";
var GAP = "gap";
var ABOVE = "above";
var BELOW = "below";
var SMOOTH = "smooth";
var STEP = "step";
var AREA = "area";
var BAR = "bar";
var BOX_PLOT = "boxPlot";
var BUBBLE = "bubble";
var BULLET = "bullet";
var CANDLESTICK = "candlestick";
var COLUMN = "column";
var DONUT = "donut";
var FUNNEL = "funnel";
var PYRAMID = "pyramid";
var HEATMAP = "heatmap";
var HORIZONTAL_WATERFALL = "horizontalWaterfall";
var LINE = "line";
var OHLC = "ohlc";
var PIE = "pie";
var POLAR_AREA = "polarArea";
var POLAR_LINE = "polarLine";
var POLAR_SCATTER = "polarScatter";
var RADAR_AREA = "radarArea";
var RADAR_COLUMN = "radarColumn";
var RADAR_LINE = "radarLine";
var RANGE_AREA = "rangeArea";
var RANGE_BAR = "rangeBar";
var RANGE_COLUMN = "rangeColumn";
var SCATTER = "scatter";
var SCATTER_LINE = "scatterLine";
var VERTICAL_AREA = "verticalArea";
var VERTICAL_BOX_PLOT = "verticalBoxPlot";
var VERTICAL_BULLET = "verticalBullet";
var VERTICAL_LINE = "verticalLine";
var VERTICAL_RANGE_AREA = "verticalRangeArea";
var WATERFALL = "waterfall";
var EQUALLY_SPACED_SERIES = [
  BAR,
  COLUMN,
  OHLC,
  CANDLESTICK,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  BULLET,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL
];
var TRENDLINE_EXPONENTIAL = "exponentialTrendline";
var TRENDLINE_LINEAR = "linearTrendline";
var TRENDLINE_LOGARITHMIC = "logarithmicTrendline";
var TRENDLINE_MOVING_AVERAGE = "movingAverageTrendline";
var TRENDLINE_POLYNOMIAL = "polynomialTrendline";
var TRENDLINE_POWER = "powerTrendline";
var TRENDLINE_SERIES = [
  TRENDLINE_EXPONENTIAL,
  TRENDLINE_LINEAR,
  TRENDLINE_LOGARITHMIC,
  TRENDLINE_MOVING_AVERAGE,
  TRENDLINE_POLYNOMIAL,
  TRENDLINE_POWER
];
var LEGEND_ITEM_CLICK = "legendItemClick";
var LEGEND_ITEM_HOVER = "legendItemHover";
var LEGEND_ITEM_LEAVE = "legendItemLeave";
var SERIES_CLICK = "seriesClick";
var SERIES_HOVER = "seriesHover";
var SERIES_OVER = "seriesOver";
var SERIES_LEAVE = "seriesLeave";
var PLOT_AREA_CLICK = "plotAreaClick";
var PLOT_AREA_HOVER = "plotAreaHover";
var PLOT_AREA_LEAVE = "plotAreaLeave";
var DRAG = "drag";
var DRAG_END = "dragEnd";
var DRAG_START = "dragStart";
var ZOOM_START = "zoomStart";
var ZOOM = "zoom";
var ZOOM_END = "zoomEnd";
var SELECT_START = "selectStart";
var SELECT2 = "select";
var SELECT_END = "selectEnd";
var RENDER = "render";
var SHOW_TOOLTIP = "showTooltip";
var HIDE_TOOLTIP = "hideTooltip";
var PANE_RENDER = "paneRender";
var CHART_POINT_ROLE = "graphics-symbol";
var CHART_POINT_CLASSNAME = "k-chart-point";
var CHART_POINT_ROLE_DESCRIPTION = "Point";
var LEGEND_ITEM_ROLE = "checkbox";
var LEGEND_ITEM_CLASSNAME = "k-chart-legend-item";
var LEGEND_ITEM_ARIA_ROLE_DESCRIPTION = "Legend item";
var LOGARITHMIC = "log";
var CATEGORY = "category";
var INSIDE_END = "insideEnd";
var INSIDE_BASE = "insideBase";
var OUTSIDE_END = "outsideEnd";
var MOUSEWHEEL = "wheel";
var MOUSEWHEEL_DELAY = 150;
var MOUSEWHEEL_ZOOM_RATE = 0.3;
var DRILLDOWN = "drilldown";
var DRILLDOWN_FIELD = "drilldown";
var PATTERN_FIELD = "pattern";
var MIN_MOVING_AVERAGE_PERIOD = 2;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-bar-base.js
var DEFAULT_ERROR_BAR_WIDTH = 4;
var ErrorBarBase = function(ChartElement2) {
  function ErrorBarBase2(low, high, isVertical, chart, series, options) {
    ChartElement2.call(this, options);
    this.low = low;
    this.high = high;
    this.isVertical = isVertical;
    this.chart = chart;
    this.series = series;
  }
  if (ChartElement2) ErrorBarBase2.__proto__ = ChartElement2;
  ErrorBarBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ErrorBarBase2.prototype.constructor = ErrorBarBase2;
  ErrorBarBase2.prototype.reflow = function reflow(targetBox) {
    var endCaps = this.options.endCaps;
    var isVertical = this.isVertical;
    var axis = this.getAxis();
    var valueBox = axis.getSlot(this.low, this.high);
    var centerBox = targetBox.center();
    var capsWidth = this.getCapsWidth(targetBox, isVertical);
    var capValue = isVertical ? centerBox.x : centerBox.y;
    var capStart = capValue - capsWidth;
    var capEnd = capValue + capsWidth;
    var linePoints;
    if (isVertical) {
      linePoints = [
        new point_default(centerBox.x, valueBox.y1),
        new point_default(centerBox.x, valueBox.y2)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default(capStart, valueBox.y1),
          new point_default(capEnd, valueBox.y1),
          new point_default(capStart, valueBox.y2),
          new point_default(capEnd, valueBox.y2)
        );
      }
      this.box = new box_default(capStart, valueBox.y1, capEnd, valueBox.y2);
    } else {
      linePoints = [
        new point_default(valueBox.x1, centerBox.y),
        new point_default(valueBox.x2, centerBox.y)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default(valueBox.x1, capStart),
          new point_default(valueBox.x1, capEnd),
          new point_default(valueBox.x2, capStart),
          new point_default(valueBox.x2, capEnd)
        );
      }
      this.box = new box_default(valueBox.x1, capStart, valueBox.x2, capEnd);
    }
    this.linePoints = linePoints;
  };
  ErrorBarBase2.prototype.getCapsWidth = function getCapsWidth(box, isVertical) {
    var boxSize = isVertical ? box.width() : box.height();
    var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;
    return capsWidth;
  };
  ErrorBarBase2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options = this.options;
    var visual = options.visual;
    if (visual) {
      this.visual = visual({
        low: this.low,
        high: this.high,
        rect: this.box.toRect(),
        sender: this.getSender(),
        options: {
          endCaps: options.endCaps,
          color: options.color,
          line: options.line
        },
        createVisual: function() {
          this$1.createDefaultVisual();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
    } else {
      this.createDefaultVisual();
    }
  };
  ErrorBarBase2.prototype.createDefaultVisual = function createDefaultVisual() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var linePoints = ref2.linePoints;
    var lineOptions = {
      stroke: {
        color: options.color,
        width: options.line.width,
        dashType: options.line.dashType
      }
    };
    ChartElement2.prototype.createVisual.call(this);
    for (var idx = 0; idx < linePoints.length; idx += 2) {
      var line = new drawing_exports.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);
      alignPathToPixel(line);
      this$1.visual.append(line);
    }
  };
  return ErrorBarBase2;
}(chart_element_default);
setDefaultOptions(ErrorBarBase, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  endCaps: true,
  line: {
    width: 2
  },
  zIndex: 1
});
var error_bar_base_default = ErrorBarBase;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/categorical-error-bar.js
var CategoricalErrorBar = function(ErrorBarBase2) {
  function CategoricalErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2) CategoricalErrorBar2.__proto__ = ErrorBarBase2;
  CategoricalErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  CategoricalErrorBar2.prototype.constructor = CategoricalErrorBar2;
  CategoricalErrorBar2.prototype.getAxis = function getAxis() {
    var axis = this.chart.seriesValueAxis(this.series);
    return axis;
  };
  return CategoricalErrorBar2;
}(error_bar_base_default);
var categorical_error_bar_default = CategoricalErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/any-has-z-index.js
function anyHasZIndex(elements) {
  for (var idx = 0; idx < elements.length; idx++) {
    if (defined(elements[idx].zIndex)) {
      return true;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/append-if-not-null.js
function appendIfNotNull(array, element) {
  if (element !== null) {
    array.push(element);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/are-numbers.js
function areNumbers(values5) {
  return countNumbers(values5) === values5.length;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/segment-visible.js
function segmentVisible(series, fields, index) {
  var visible = fields.visible;
  if (defined(visible)) {
    return visible;
  }
  var pointVisibility = series.pointVisibility;
  if (pointVisibility) {
    return pointVisibility[index];
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/bind-segments.js
function bindSegments(series) {
  var data = series.data;
  var points = [];
  var sum2 = 0;
  var count = 0;
  for (var idx = 0; idx < data.length; idx++) {
    var pointData = series_binder_default.current.bindPoint(series, idx);
    var value2 = pointData.valueFields.value;
    if (isString(value2)) {
      value2 = parseFloat(value2);
    }
    if (isNumber(value2)) {
      pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;
      pointData.value = Math.abs(value2);
      points.push(pointData);
      if (pointData.visible) {
        sum2 += pointData.value;
      }
      if (value2 !== 0) {
        count++;
      }
    } else {
      points.push(null);
    }
  }
  return {
    total: sum2,
    points,
    count
  };
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/categories-count.js
function categoriesCount(series) {
  var seriesCount = series.length;
  var categories = 0;
  for (var i36 = 0; i36 < seriesCount; i36++) {
    categories = Math.max(categories, series[i36].data.length);
  }
  return categories;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/equals-ignore-case.js
function equalsIgnoreCase(a38, b2) {
  if (a38 && b2) {
    return a38.toLowerCase() === b2.toLowerCase();
  }
  return a38 === b2;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/eval-options.js
var MAX_EXPAND_DEPTH = 5;
function evalOptions(options, context, state, dryRun) {
  if (state === void 0) state = {};
  if (dryRun === void 0) dryRun = false;
  var defaults = state.defaults = state.defaults || {};
  var depth = state.depth = state.depth || 0;
  var needsEval = false;
  state.excluded = state.excluded || [];
  if (depth > MAX_EXPAND_DEPTH) {
    return null;
  }
  for (var property in options) {
    if (!inArray(property, state.excluded) && hasOwnProperty(options, property)) {
      var propValue = options[property];
      if (isFunction(propValue)) {
        needsEval = true;
        if (!dryRun) {
          options[property] = valueOrDefault(propValue(context), defaults[property]);
        }
      } else if (isObject(propValue)) {
        if (!dryRun) {
          state.defaults = defaults[property];
        }
        state.depth++;
        needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;
        state.depth--;
      }
    }
  }
  return needsEval;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/filter-series-by-type.js
function filterSeriesByType(series, types) {
  var result = [];
  var seriesTypes = [].concat(types);
  for (var idx = 0; idx < series.length; idx++) {
    var currentSeries = series[idx];
    if (inArray(currentSeries.type, seriesTypes)) {
      result.push(currentSeries);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/parse-date-category.js
var dateCache = /* @__PURE__ */ new WeakMap();
function parseDateCategory(category, row, intlService) {
  if (row === null || typeof row !== "object") {
    return parseDate(intlService, category);
  }
  var date = dateCache.get(row);
  if (!date) {
    date = parseDate(intlService, category);
    dateCache.set(row, date);
  }
  return date;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-gradient-overlay.js
function hasGradientOverlay(options) {
  var overlay = options.overlay;
  return overlay && overlay.gradient && overlay.gradient !== "none";
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-value.js
function hasValue(value2) {
  return defined(value2) && value2 !== null;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/is-date-axis.js
function isDateAxis(axisOptions2, sampleCategory) {
  var type = axisOptions2.type;
  var dateCategory = sampleCategory instanceof Date;
  return !type && dateCategory || equalsIgnoreCase(type, DATE);
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/single-item-or-array.js
function singleItemOrArray(array) {
  return array.length === 1 ? array[0] : array;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js
var AREA_REGEX = /area/i;
function seriesMissingValues(series) {
  if (series.missingValues) {
    return series.missingValues;
  }
  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;
}
function hasValue2(series, item) {
  var fields = series_binder_default.current.bindPoint(series, null, item);
  var valueFields = fields.valueFields;
  for (var field in valueFields) {
    if (convertableToNumber(valueFields[field])) {
      return true;
    }
  }
}
function findNext(ref2) {
  var start = ref2.start;
  var dir = ref2.dir;
  var min4 = ref2.min;
  var max3 = ref2.max;
  var getter2 = ref2.getter;
  var hasItem = ref2.hasItem;
  var series = ref2.series;
  var pointHasValue, outPoint;
  var idx = start;
  do {
    idx += dir;
    if (hasItem(idx)) {
      outPoint = getter2(idx);
      pointHasValue = hasValue2(series, outPoint.item);
    }
  } while (min4 <= idx && idx <= max3 && !pointHasValue);
  if (pointHasValue) {
    return outPoint;
  }
}
function createOutOfRangePoints(series, range, count, getter2, hasItem) {
  var min4 = range.min;
  var max3 = range.max;
  var hasMinPoint = min4 > 0 && min4 < count;
  var hasMaxPoint = max3 + 1 < count;
  if (hasMinPoint || hasMaxPoint) {
    var missingValues = seriesMissingValues(series);
    var minPoint, maxPoint;
    if (missingValues !== INTERPOLATE) {
      if (hasMinPoint) {
        minPoint = getter2(min4 - 1);
      }
      if (hasMaxPoint) {
        maxPoint = getter2(max3 + 1);
      }
    } else {
      var outPoint, pointHasValue;
      if (hasMinPoint) {
        outPoint = getter2(min4 - 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          minPoint = findNext({
            start: min4,
            dir: -1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          minPoint = outPoint;
        }
      }
      if (hasMaxPoint) {
        outPoint = getter2(max3 + 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          maxPoint = findNext({
            start: max3,
            dir: 1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          maxPoint = outPoint;
        }
      }
    }
    if (minPoint) {
      series._outOfRangeMinPoint = minPoint;
    }
    if (maxPoint) {
      series._outOfRangeMaxPoint = maxPoint;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js
var CategoricalChart = function(ChartElement2) {
  function CategoricalChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);
    this.valueAxisRanges = {};
    this.points = [];
    this.categoryPoints = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
    this.render();
  }
  if (ChartElement2) CategoricalChart2.__proto__ = ChartElement2;
  CategoricalChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  CategoricalChart2.prototype.constructor = CategoricalChart2;
  CategoricalChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  CategoricalChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options = this.seriesOptions[seriesIx];
    if (!options) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        vertical: !this.options.invertAxes
      }, series);
    }
    return options;
  };
  CategoricalChart2.prototype.plotValue = function plotValue(point) {
    if (!point) {
      return 0;
    }
    if (this.options.isStacked100 && isNumber(point.value)) {
      var categoryIx = point.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      var otherValues = [];
      var categorySum = 0;
      for (var i36 = 0; i36 < categoryPoints.length; i36++) {
        var other = categoryPoints[i36];
        if (other) {
          var stack = point.series.stack;
          var otherStack = other.series.stack;
          if (stack && otherStack && stack.group !== otherStack.group) {
            continue;
          }
          if (isNumber(other.value)) {
            categorySum += Math.abs(other.value);
            otherValues.push(Math.abs(other.value));
          }
        }
      }
      if (categorySum > 0) {
        return point.value / categorySum;
      }
    }
    return point.value;
  };
  CategoricalChart2.prototype.plotRange = function plotRange(point, startValue) {
    var this$1 = this;
    if (startValue === void 0) startValue = 0;
    var categoryPoints = this.categoryPoints[point.categoryIx];
    if (this.options.isStacked) {
      var plotValue = this.plotValue(point);
      var positive = plotValue >= 0;
      var prevValue = startValue;
      var isStackedBar = false;
      var stack = defined(point.series.stack) ? point.series.stack : this.options.defaultStack;
      var isNonGroupStack = function(stack2) {
        return stack2 === true || typeof stack2 === OBJECT && !stack2.group;
      };
      if (stack) {
        for (var i36 = 0; i36 < categoryPoints.length; i36++) {
          var other = categoryPoints[i36];
          if (point === other) {
            break;
          }
          var otherStack = defined(other.series.stack) ? other.series.stack : this$1.options.defaultStack;
          if (!otherStack) {
            continue;
          }
          if (typeof stack === STRING && stack !== otherStack) {
            continue;
          }
          if (isNonGroupStack(stack) && !isNonGroupStack(otherStack)) {
            continue;
          }
          if (stack.group && stack.group !== otherStack.group) {
            continue;
          }
          var otherValue = this$1.plotValue(other);
          if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
            if (startValue === 0 || otherValue !== 0) {
              prevValue += otherValue;
              plotValue += otherValue;
              isStackedBar = true;
              if (this$1.options.isStacked100) {
                plotValue = Math.min(plotValue, 1);
              }
            }
          }
        }
      }
      if (isStackedBar) {
        prevValue -= startValue;
      }
      return [prevValue, plotValue];
    }
    var series = point.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];
  };
  CategoricalChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var this$1 = this;
    var min4 = MAX_VALUE;
    var max3 = MIN_VALUE;
    for (var i36 = 0; i36 < this.categoryPoints.length; i36++) {
      var categoryPoints = this$1.categoryPoints[i36];
      if (!categoryPoints) {
        continue;
      }
      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {
        var point = categoryPoints[pIx];
        if (point) {
          if (point.series.stack === stackName || point.series.axis === axisName) {
            var to = this$1.plotRange(point, 0)[1];
            if (defined(to) && isFinite(to)) {
              max3 = Math.max(max3, to);
              min4 = Math.min(min4, to);
            }
          }
        }
      }
    }
    return { min: min4, max: max3 };
  };
  CategoricalChart2.prototype.updateStackRange = function updateStackRange() {
    var this$1 = this;
    var ref2 = this.options;
    var isStacked = ref2.isStacked;
    var chartSeries = ref2.series;
    var limitsCache = {};
    if (isStacked) {
      for (var i36 = 0; i36 < chartSeries.length; i36++) {
        var series = chartSeries[i36];
        var axisName = series.axis;
        var key = axisName + series.stack;
        var limits = limitsCache[key];
        if (!limits) {
          limits = this$1.stackLimits(axisName, series.stack);
          var errorTotals = this$1.errorTotals;
          if (errorTotals) {
            if (errorTotals.negative.length) {
              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);
            }
            if (errorTotals.positive.length) {
              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);
            }
          }
          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {
            limitsCache[key] = limits;
          } else {
            limits = null;
          }
        }
        if (limits) {
          this$1.valueAxisRanges[axisName] = limits;
        }
      }
    }
  };
  CategoricalChart2.prototype.addErrorBar = function addErrorBar(point, data, categoryIx) {
    var value2 = point.value;
    var series = point.series;
    var seriesIx = point.seriesIx;
    var errorBars = point.options.errorBars;
    var lowValue = data.fields[ERROR_LOW_FIELD];
    var highValue = data.fields[ERROR_HIGH_FIELD];
    var errorRange;
    if (isNumber(lowValue) && isNumber(highValue)) {
      errorRange = { low: lowValue, high: highValue };
    } else if (errorBars && defined(errorBars.value)) {
      this.seriesErrorRanges = this.seriesErrorRanges || [];
      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new error_range_calculator_default(errorBars.value, series, VALUE);
      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value2, errorBars.value);
    }
    if (errorRange) {
      point.low = errorRange.low;
      point.high = errorRange.high;
      this.addPointErrorBar(point, categoryIx);
    }
  };
  CategoricalChart2.prototype.addPointErrorBar = function addPointErrorBar(point, categoryIx) {
    var isVertical = !this.options.invertAxes;
    var options = point.options.errorBars;
    var series = point.series;
    var low = point.low;
    var high = point.high;
    if (this.options.isStacked) {
      var stackedErrorRange = this.stackedErrorRange(point, categoryIx);
      low = stackedErrorRange.low;
      high = stackedErrorRange.high;
    } else {
      var fields = { categoryIx, series };
      this.updateRange({ value: low }, fields);
      this.updateRange({ value: high }, fields);
    }
    var errorBar = new categorical_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars = [errorBar];
    point.append(errorBar);
  };
  CategoricalChart2.prototype.stackedErrorRange = function stackedErrorRange(point, categoryIx) {
    var plotValue = this.plotRange(point, 0)[1] - point.value;
    var low = point.low + plotValue;
    var high = point.high + plotValue;
    this.errorTotals = this.errorTotals || { positive: [], negative: [] };
    if (low < 0) {
      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
    }
    if (high > 0) {
      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
    }
    return { low, high };
  };
  CategoricalChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var categoryPoints = this.categoryPoints[categoryIx];
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    var seriesPoints = this.seriesPoints[seriesIx];
    if (!seriesPoints) {
      this.seriesPoints[seriesIx] = seriesPoints = [];
    }
    var point = this.createPoint(data, fields);
    if (point) {
      Object.assign(point, fields);
      point.owner = this;
      point.noteText = data.fields.noteText;
      if (!defined(point.dataItem)) {
        point.dataItem = series.data[categoryIx];
      }
      this.addErrorBar(point, data, categoryIx);
    }
    this.points.push(point);
    seriesPoints.push(point);
    categoryPoints.push(point);
    this.updateRange(data.valueFields, fields);
  };
  CategoricalChart2.prototype.evalPointOptions = function evalPointOptions(options, value2, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "aggregate",
        "_events",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    var pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, pointOptions);
      evalOptions(pointOptions, {
        value: value2,
        category,
        index: categoryIx,
        series,
        dataItem: series.data[categoryIx]
      }, state);
    }
    return pointOptions;
  };
  CategoricalChart2.prototype.updateRange = function updateRange(data, fields) {
    var axisName = fields.series.axis;
    var value2 = data.value;
    var axisRange = this.valueAxisRanges[axisName];
    if (isFinite(value2) && value2 !== null) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, value2);
      axisRange.max = Math.max(axisRange.max, value2);
    }
  };
  CategoricalChart2.prototype.seriesValueAxis = function seriesValueAxis(series) {
    var plotArea = this.plotArea;
    var axisName = series.axis;
    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;
    if (!axis) {
      throw new Error("Unable to locate value axis with name " + axisName);
    }
    return axis;
  };
  CategoricalChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var categorySlots = this.categorySlots = [];
    var chartPoints = this.points;
    var categoryAxis = this.categoryAxis;
    var pointIx = 0;
    this.traverseDataPoints(function(data, fields) {
      var categoryIx = fields.categoryIx;
      var currentSeries = fields.series;
      var valueAxis = this$1.seriesValueAxis(currentSeries);
      var point = chartPoints[pointIx++];
      var categorySlot = categorySlots[categoryIx];
      if (!categorySlot) {
        categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);
      }
      if (point) {
        var plotRange = this$1.plotRange(point, valueAxis.startValue());
        var valueSlot = this$1.valueSlot(valueAxis, plotRange);
        if (valueSlot) {
          var pointSlot = this$1.pointSlot(categorySlot, valueSlot);
          point.aboveAxis = this$1.aboveAxis(point, valueAxis);
          point.stackValue = plotRange[1];
          if (this$1.options.isStacked100) {
            point.percentage = this$1.plotValue(point);
          }
          this$1.reflowPoint(point, pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.reflowCategories(categorySlots);
    if (!this.options.clip && this.options.limitPoints && this.points.length) {
      this.limitPoints();
    }
    this.box = targetBox;
  };
  CategoricalChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);
  };
  CategoricalChart2.prototype.limitPoints = function limitPoints() {
    var this$1 = this;
    var categoryPoints = this.categoryPoints;
    var points = categoryPoints[0].concat(last(categoryPoints));
    for (var idx = 0; idx < points.length; idx++) {
      if (points[idx]) {
        this$1.limitPoint(points[idx]);
      }
    }
  };
  CategoricalChart2.prototype.limitPoint = function limitPoint(point) {
    var limitedSlot = this.categoryAxis.limitSlot(point.box);
    if (!limitedSlot.equals(point.box)) {
      point.reflow(limitedSlot);
    }
  };
  CategoricalChart2.prototype.aboveAxis = function aboveAxis(point, valueAxis) {
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    var value2 = point.value;
    return valueAxis.options.reverse ? value2 < axisCrossingValue : value2 >= axisCrossingValue;
  };
  CategoricalChart2.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {
    var categoryAxis = this.categoryAxis;
    var options = valueAxis.options;
    var crossingValues = [].concat(
      options.axisCrossingValues || options.axisCrossingValue
    );
    return crossingValues[categoryAxis.axisIndex || 0] || 0;
  };
  CategoricalChart2.prototype.reflowPoint = function reflowPoint(point, pointSlot) {
    point.reflow(pointSlot);
  };
  CategoricalChart2.prototype.reflowCategories = function reflowCategories() {
  };
  CategoricalChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var options = this.options;
    var invertAxes = options.invertAxes;
    var slotX = invertAxes ? valueSlot : categorySlot;
    var slotY = invertAxes ? categorySlot : valueSlot;
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  CategoricalChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  CategoricalChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var count = categoriesCount(series);
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this$1._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
    }
    for (var categoryIx = 0; categoryIx < count; categoryIx++) {
      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {
        var currentSeries = series[seriesIx$1];
        var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);
        var pointData = this$1.plotArea.bindPoint(currentSeries, categoryIx);
        callback(pointData, {
          category: currentCategory,
          categoryIx,
          categoriesCount: count,
          series: currentSeries,
          seriesIx: seriesIx$1
        });
      }
    }
    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {
      this$1._outOfRangeCallback(series[seriesIx$2], "_outOfRangeMaxPoint", seriesIx$2, callback);
    }
  };
  CategoricalChart2.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {
    var outOfRangePoint = series[field];
    if (outOfRangePoint) {
      var categoryIx = outOfRangePoint.categoryIx;
      var pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);
      callback(pointData, {
        category: outOfRangePoint.category,
        categoryIx,
        series,
        seriesIx,
        dataItem: outOfRangePoint.item
      });
    }
  };
  CategoricalChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    if (point.value === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value);
  };
  CategoricalChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.value;
  };
  return CategoricalChart2;
}(chart_element_default);
setDefaultOptions(CategoricalChart, {
  series: [],
  invertAxes: false,
  isStacked: false,
  clip: true,
  limitPoints: true
});
var categorical_chart_default = CategoricalChart;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/point-events-mixin.js
var PointEventsMixin = {
  click: function(chart, e39) {
    return chart.trigger(
      SERIES_CLICK,
      this.eventArgs(e39)
    );
  },
  hover: function(chart, e39) {
    return chart.trigger(
      SERIES_HOVER,
      this.eventArgs(e39)
    );
  },
  over: function(chart, e39) {
    return chart.trigger(
      SERIES_OVER,
      this.eventArgs(e39)
    );
  },
  out: function(chart, e39) {
    return chart.trigger(
      SERIES_LEAVE,
      this.eventArgs(e39)
    );
  },
  eventArgs: function(e39) {
    return {
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      category: this.category,
      series: this.series,
      dataItem: this.dataItem,
      runningTotal: this.runningTotal,
      total: this.total,
      element: eventElement(e39),
      originalEvent: e39,
      point: this
    };
  }
};
var point_events_mixin_default = PointEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/note-mixin.js
var NoteMixin = {
  createNote: function() {
    var options = this.options.notes;
    var text = this.noteText || options.label.text;
    if (options.visible !== false && defined(text) && text !== null) {
      this.note = new note_default({
        value: this.value,
        text,
        dataItem: this.dataItem,
        category: this.category,
        series: this.series
      }, this.options.notes, this.owner.chartService);
      this.append(this.note);
    }
  }
};
var note_mixin_default = NoteMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-point.js
var LinePoint = function(ChartElement2) {
  function LinePoint2(value2, options) {
    ChartElement2.call(this);
    this.value = value2;
    this.options = options;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
  }
  if (ChartElement2) LinePoint2.__proto__ = ChartElement2;
  LinePoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LinePoint2.prototype.constructor = LinePoint2;
  LinePoint2.prototype.render = function render() {
    var ref2 = this.options;
    var markers = ref2.markers;
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    if (markers.visible && markers.size) {
      this.marker = this.createMarker();
      this.append(this.marker);
    }
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  LinePoint2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  LinePoint2.prototype.createLabelElement = function createLabelElement(options) {
    return new text_box_default(
      this.getLabelText(options),
      deepExtend({
        align: CENTER,
        vAlign: CENTER,
        margin: {
          left: 5,
          right: 5
        },
        zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
      }, options),
      this.pointData()
    );
  };
  LinePoint2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  };
  LinePoint2.prototype.getAriaLabelText = function getAriaLabelText2() {
    var labels = this.options.labels;
    var ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  };
  LinePoint2.prototype.markerBorder = function markerBorder() {
    var options = this.options.markers;
    var background = options.background;
    var border = deepExtend({ color: this.color }, options.border);
    if (!defined(border.color)) {
      border.color = new color_default(background).brightness(BORDER_BRIGHTNESS).toHex();
    }
    return border;
  };
  LinePoint2.prototype.createVisual = function createVisual() {
  };
  LinePoint2.prototype.createMarker = function createMarker() {
    var options = this.options.markers;
    var marker = new shape_element_default({
      type: options.type,
      width: options.size,
      height: options.size,
      rotation: options.rotation,
      background: options.background,
      border: this.markerBorder(),
      opacity: options.opacity,
      pattern: this.options.pattern,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual,
      accessibilityOptions: deepExtend({
        ariaLabel: this.getAriaLabelText(this.options.labels)
      }, this.options.accessibility)
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    return marker;
  };
  LinePoint2.prototype.markerBox = function markerBox() {
    if (!this.marker) {
      this.marker = this.createMarker();
      this.marker.reflow(this._childBox);
    }
    return this.marker.box;
  };
  LinePoint2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var aboveAxis = ref2.aboveAxis;
    var vertical = options.vertical;
    this.render();
    this.box = targetBox;
    var childBox = targetBox.clone();
    if (vertical) {
      if (aboveAxis) {
        childBox.y1 -= childBox.height();
      } else {
        childBox.y2 += childBox.height();
      }
    } else {
      if (aboveAxis) {
        childBox.x1 += childBox.width();
      } else {
        childBox.x2 -= childBox.width();
      }
    }
    this._childBox = childBox;
    if (this.marker) {
      this.marker.reflow(childBox);
    }
    this.reflowLabel(childBox);
    if (this.errorBars) {
      for (var i36 = 0; i36 < this.errorBars.length; i36++) {
        this$1.errorBars[i36].reflow(childBox);
      }
    }
    if (this.note) {
      var noteTargetBox = this.markerBox();
      if (!(options.markers.visible && options.markers.size)) {
        var center = noteTargetBox.center();
        noteTargetBox = new box_default(center.x, center.y, center.x, center.y);
      }
      this.note.reflow(noteTargetBox);
    }
  };
  LinePoint2.prototype.reflowLabel = function reflowLabel(box) {
    var ref2 = this;
    var options = ref2.options;
    var label = ref2.label;
    var anchor = options.labels.position;
    if (label) {
      anchor = anchor === ABOVE ? TOP : anchor;
      anchor = anchor === BELOW ? BOTTOM : anchor;
      label.reflow(box);
      label.box.alignTo(this.markerBox(), anchor);
      label.reflow(label.box);
    }
  };
  LinePoint2.prototype.createHighlight = function createHighlight() {
    var markers = this.options.highlight.markers;
    var defaultColor = this.markerBorder().color;
    var options = this.options.markers;
    var size = options.size + (options.border.width || 0) + (markers.border.width || 0);
    var shadow = new shape_element_default({
      type: options.type,
      width: size,
      height: size,
      rotation: options.rotation,
      background: markers.color || defaultColor,
      border: {
        color: markers.border.color,
        width: markers.border.width,
        opacity: valueOrDefault(markers.border.opacity, 1)
      },
      opacity: valueOrDefault(markers.opacity, 1)
    });
    shadow.reflow(this._childBox);
    return shadow.getElement();
  };
  LinePoint2.prototype.highlightVisual = function highlightVisual() {
    return (this.marker || {}).visual;
  };
  LinePoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var marker = this.marker;
    var visual, rect;
    if (marker) {
      rect = marker.paddingBox.toRect();
      visual = marker.visual;
    } else {
      var size = this.options.markers.size;
      var halfSize = size / 2;
      var center = this.box.center();
      rect = new geometry_exports.Rect([center.x - halfSize, center.y - halfSize], [size, size]);
    }
    return {
      options: this.options,
      rect,
      visual
    };
  };
  LinePoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var markerOptions = this.options.markers;
    var highlightOptions2 = this.options.focusHighlight;
    var size = markerOptions.size + (markerOptions.border.width || 0);
    var highlight = new shape_element_default({
      type: markerOptions.type,
      width: size,
      height: size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      opacity: highlightOptions2.opacity,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this._childBox);
    return highlight.getElement();
  };
  LinePoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var markerBox = this.markerBox();
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(markerBox);
    if (showTooltip) {
      var x5 = markerBox.x2 + TOOLTIP_OFFSET;
      var horizontalAlign = LEFT;
      var y, verticalAlign;
      if (this.aboveAxis) {
        y = markerBox.y1;
        verticalAlign = BOTTOM;
      } else {
        y = markerBox.y2;
        verticalAlign = TOP;
      }
      return {
        point: new point_default(x5, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  LinePoint2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  LinePoint2.prototype.overlapsBox = function overlapsBox(box) {
    var markerBox = this.markerBox();
    return markerBox.overlaps(box);
  };
  LinePoint2.prototype.unclipElements = function unclipElements() {
    if (this.label) {
      this.label.options.noclip = true;
    }
    if (this.note) {
      this.note.options.noclip = true;
    }
  };
  LinePoint2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  LinePoint2.prototype.focusVisual = function focusVisual2() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", this._id);
      }
      this.toggleFocusHighlight(true);
    }
  };
  LinePoint2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", "");
      }
      this.toggleFocusHighlight(false);
    }
  };
  LinePoint2.prototype.getIndex = function getIndex() {
    return defined(this.categoryIx) ? this.categoryIx : this.pointIx;
  };
  return LinePoint2;
}(chart_element_default);
LinePoint.prototype.defaults = {
  vertical: true,
  markers: {
    visible: true,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    position: ABOVE,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    }
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: "#fff",
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  errorBars: {
    line: {
      width: 1
    }
  },
  accessibility: {
    tabIndex: 0,
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
deepExtend(LinePoint.prototype, point_events_mixin_default);
deepExtend(LinePoint.prototype, note_mixin_default);
var line_point_default = LinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-segment.js
var LineSegment = function(ChartElement2) {
  function LineSegment2(linePoints, series, seriesIx) {
    ChartElement2.call(this);
    this.linePoints = linePoints;
    this.series = series;
    this.seriesIx = seriesIx;
  }
  if (ChartElement2) LineSegment2.__proto__ = ChartElement2;
  LineSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LineSegment2.prototype.constructor = LineSegment2;
  LineSegment2.prototype.points = function points() {
    return this.toGeometryPoints(this.linePoints);
  };
  LineSegment2.prototype.toGeometryPoints = function toGeometryPoints(points) {
    var result = [];
    for (var i36 = 0, length = points.length; i36 < length; i36++) {
      if (points[i36] && points[i36].visible !== false) {
        result.push(points[i36]._childBox.toRect().center());
      }
    }
    return result;
  };
  LineSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var customVisual = this.series.visual;
    if (customVisual) {
      this.visual = customVisual({
        points: this.toGeometryPoints(this.linePoints),
        series: this.series,
        sender: this.getSender(),
        createVisual: function() {
          this$1.segmentVisual();
          return this$1.visual;
        }
      });
      if (this.visual && !defined(this.visual.options.zIndex)) {
        this.visual.options.zIndex = this.series.zIndex;
      }
    } else {
      this.segmentVisual();
    }
  };
  LineSegment2.prototype.segmentVisual = function segmentVisual() {
    var ref2 = this;
    var options = ref2.options;
    var series = ref2.series;
    var color = series.color;
    var defaults = series._defaults;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    var line = drawing_exports.Path.fromPoints(this.points(), {
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    if (options.closed) {
      line.close();
    }
    this.visual = line;
  };
  LineSegment2.prototype.aliasFor = function aliasFor(e39, coords) {
    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);
  };
  return LineSegment2;
}(chart_element_default);
setDefaultOptions(LineSegment, {
  closed: false
});
var line_segment_default = LineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-mixin.js
var StepLineMixin = {
  calculateStepPoints: function(points) {
    var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);
    var ref2 = categoryAxis.options;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var stepAxis = vertical ? X : Y;
    var axis = vertical ? Y : X;
    var stepDir = reverse ? 2 : 1;
    var dir = stepDir;
    var previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);
    var result = [previousPoint];
    for (var idx = 1; idx < points.length; idx++) {
      var point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);
      if (previousPoint[stepAxis] !== point[stepAxis]) {
        var stepPoint = new geometry_exports.Point();
        stepPoint[stepAxis] = previousPoint[stepAxis];
        stepPoint[axis] = point[axis];
        result.push(stepPoint, point);
      }
      previousPoint = point;
    }
    if (!justified) {
      result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));
    } else if (previousPoint !== last(result)) {
      result.push(previousPoint);
    }
    return result;
  }
};
function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {
  var box = lintPoint.box;
  var result = new geometry_exports.Point();
  result[stepAxis] = box[stepAxis + stepDir];
  result[axis] = box[axis + dir];
  return result;
}
var step_line_mixin_default = StepLineMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-segment.js
var StepLineSegment = function(LineSegment2) {
  function StepLineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2) StepLineSegment2.__proto__ = LineSegment2;
  StepLineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  StepLineSegment2.prototype.constructor = StepLineSegment2;
  StepLineSegment2.prototype.points = function points() {
    return this.calculateStepPoints(this.linePoints);
  };
  return StepLineSegment2;
}(line_segment_default);
deepExtend(StepLineSegment.prototype, step_line_mixin_default);
var step_line_segment_default = StepLineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/spline-segment.js
var SplineSegment = function(LineSegment2) {
  function SplineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2) SplineSegment2.__proto__ = LineSegment2;
  SplineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  SplineSegment2.prototype.constructor = SplineSegment2;
  SplineSegment2.prototype.segmentVisual = function segmentVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    var curveProcessor = new curve_processor_default(this.options.closed);
    var segments = curveProcessor.process(this.points());
    var curve = new drawing_exports.Path({
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    curve.segments.push.apply(curve.segments, segments);
    this.visual = curve;
  };
  return SplineSegment2;
}(line_segment_default);
var spline_segment_default = SplineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/line-chart-mixin.js
var LineChartMixin = {
  renderSegments: function() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var seriesPoints = ref2.seriesPoints;
    var series = options.series;
    var seriesCount = seriesPoints.length;
    var lastSegment;
    this._segments = [];
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var sortedPoints = this$1.sortPoints(seriesPoints[seriesIx]);
      var pointCount = sortedPoints.length;
      var linePoints = [];
      for (var pointIx = 0; pointIx < pointCount; pointIx++) {
        var point = sortedPoints[pointIx];
        if (point) {
          linePoints.push(point);
        } else if (this$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {
          if (linePoints.length > 1) {
            lastSegment = this$1.createSegment(
              linePoints,
              currentSeries,
              seriesIx,
              lastSegment
            );
            this$1._addSegment(lastSegment);
          }
          linePoints = [];
        }
      }
      if (linePoints.length > 1) {
        lastSegment = this$1.createSegment(
          linePoints,
          currentSeries,
          seriesIx,
          lastSegment
        );
        this$1._addSegment(lastSegment);
      }
    }
    this.children.unshift.apply(this.children, this._segments);
  },
  _addSegment: function(segment) {
    this._segments.push(segment);
    segment.parent = this;
  },
  sortPoints: function(points) {
    return points;
  },
  seriesMissingValues: function(series) {
    var missingValues = series.missingValues;
    var assumeZero = !missingValues && this.options.isStacked;
    return assumeZero ? ZERO : missingValues || INTERPOLATE;
  },
  getNearestPoint: function(x5, y, seriesIx) {
    var target = new point_default(x5, y);
    var allPoints = this.seriesPoints[seriesIx];
    var nearestPointDistance = MAX_VALUE;
    var nearestPoint;
    for (var i36 = 0; i36 < allPoints.length; i36++) {
      var point = allPoints[i36];
      if (point && defined(point.value) && point.value !== null && point.visible !== false) {
        var pointBox = point.box;
        var pointDistance = pointBox.center().distanceTo(target);
        if (pointDistance < nearestPointDistance) {
          nearestPoint = point;
          nearestPointDistance = pointDistance;
        }
      }
    }
    return nearestPoint;
  }
};
var line_chart_mixin_default = LineChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/clip-animation.js
var ClipAnimation = function(superclass) {
  function ClipAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) ClipAnimation2.__proto__ = superclass;
  ClipAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ClipAnimation2.prototype.constructor = ClipAnimation2;
  ClipAnimation2.prototype.setup = function setup() {
    this._setEnd(this.options.box.x1);
  };
  ClipAnimation2.prototype.step = function step(pos) {
    var box = this.options.box;
    this._setEnd(interpolateValue(box.x1, box.x2, pos));
  };
  ClipAnimation2.prototype._setEnd = function _setEnd(x5) {
    var element = this.element;
    var segments = element.segments;
    var topRight = segments[1].anchor();
    var bottomRight = segments[2].anchor();
    element.suspend();
    topRight.setX(x5);
    element.resume();
    bottomRight.setX(x5);
  };
  return ClipAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ClipAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register("clip", ClipAnimation);
var clip_animation_default = ClipAnimation;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/clip-animation-mixin.js
var ClipAnimationMixin = {
  createAnimation: function() {
    var root = this.getRoot();
    if (root && (root.options || {}).transitions !== false) {
      var box = root.size();
      var clipPath = drawing_exports.Path.fromRect(box.toRect());
      this.visual.clip(clipPath);
      this.animation = new clip_animation_default(clipPath, {
        box
      });
      if (anyHasZIndex(this.options.series)) {
        this._setChildrenAnimation(clipPath);
      }
    }
  },
  _setChildrenAnimation: function(clipPath) {
    var points = this.animationPoints();
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      if (point && point.visual && defined(point.visual.options.zIndex)) {
        point.visual.clip(clipPath);
      }
    }
  }
};
var clip_animation_mixin_default = ClipAnimationMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-chart.js
var LineChart = function(CategoricalChart2) {
  function LineChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) LineChart2.__proto__ = CategoricalChart2;
  LineChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  LineChart2.prototype.constructor = LineChart2;
  LineChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
    this.renderSegments();
  };
  LineChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  LineChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var missingValues = this.seriesMissingValues(series);
    var value2 = data.valueFields.value;
    if (!defined(value2) || value2 === null) {
      if (missingValues === ZERO) {
        value2 = 0;
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    var color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  LineChart2.prototype.plotRange = function plotRange(point) {
    var this$1 = this;
    var plotValue = this.plotValue(point);
    if (this.options.isStacked) {
      var categoryIx = point.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      for (var i36 = 0; i36 < categoryPoints.length; i36++) {
        var other = categoryPoints[i36];
        if (point === other) {
          break;
        }
        plotValue += this$1.plotValue(other);
        if (this$1.options.isStacked100) {
          plotValue = Math.min(plotValue, 1);
        }
      }
    }
    return [plotValue, plotValue];
  };
  LineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === STEP) {
      pointType = step_line_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  LineChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result.concat(this._segments);
  };
  LineChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return LineChart2;
}(categorical_chart_default);
deepExtend(LineChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var line_chart_default = LineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-segment.js
var AreaSegment = function(LineSegment2) {
  function AreaSegment2(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {
    LineSegment2.call(this, linePoints, currentSeries, seriesIx);
    this.prevSegment = prevSegment;
    this.stackPoints = stackPoints;
  }
  if (LineSegment2) AreaSegment2.__proto__ = LineSegment2;
  AreaSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  AreaSegment2.prototype.constructor = AreaSegment2;
  AreaSegment2.prototype.createVisual = function createVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var lineOptions = series.line || {};
    var color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    this.visual = new drawing_exports.Group({
      zIndex: series.zIndex
    });
    this.createFill({
      fill: createPatternFill(series.pattern, {
        color,
        opacity: series.opacity
      }),
      stroke: null
    });
    if (lineOptions.width > 0 && lineOptions.visible !== false) {
      this.createStroke({
        stroke: deepExtend({
          color,
          opacity: series.opacity,
          lineCap: "butt"
        }, lineOptions)
      });
    }
  };
  AreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      segments = this._strokeSegments = this.createStrokeSegments();
    }
    return segments;
  };
  AreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.points());
  };
  AreaSegment2.prototype.stackSegments = function stackSegments() {
    if (this.prevSegment) {
      return this.prevSegment.createStackSegments(this.stackPoints);
    }
    return this.createStackSegments(this.stackPoints);
  };
  AreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();
  };
  AreaSegment2.prototype.segmentsFromPoints = function segmentsFromPoints(points) {
    return points.map(function(point) {
      return new geometry_exports.Segment(point);
    });
  };
  AreaSegment2.prototype.createStroke = function createStroke(style) {
    var stroke = new drawing_exports.Path(style);
    stroke.segments.push.apply(stroke.segments, this.strokeSegments());
    this.visual.append(stroke);
  };
  AreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return this.prevSegment || this.stackPoints && this.stackPoints.length;
  };
  AreaSegment2.prototype.createFill = function createFill(style) {
    var strokeSegments = this.strokeSegments();
    var fillSegments = strokeSegments.slice(0);
    var hasStackSegments = this.hasStackSegment();
    if (hasStackSegments) {
      var stackSegments = this.stackSegments();
      append(fillSegments, stackSegments);
    }
    var fill = new drawing_exports.Path(style);
    fill.segments.push.apply(fill.segments, fillSegments);
    if (!hasStackSegments && strokeSegments.length > 1) {
      this.fillToAxes(fill);
    }
    this.visual.append(fill);
  };
  AreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var chart = this.parent;
    var invertAxes = chart.options.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.series);
    var crossingValue = chart.categoryAxisCrossingValue(valueAxis);
    var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);
    var segments = this.strokeSegments();
    var firstPoint = segments[0].anchor();
    var lastPoint = last(segments).anchor();
    var end = invertAxes ? endSlot.x1 : endSlot.y1;
    if (invertAxes) {
      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);
    } else {
      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);
    }
  };
  return AreaSegment2;
}(line_segment_default);
var area_segment_default = AreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/step-area-segment.js
var StepAreaSegment = function(AreaSegment2) {
  function StepAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) StepAreaSegment2.__proto__ = AreaSegment2;
  StepAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  StepAreaSegment2.prototype.constructor = StepAreaSegment2;
  StepAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));
  };
  StepAreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();
  };
  return StepAreaSegment2;
}(area_segment_default);
deepExtend(StepAreaSegment.prototype, step_line_mixin_default);
var step_area_segment_default = StepAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/spline-area-segment.js
var SplineAreaSegment = function(AreaSegment2) {
  function SplineAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) SplineAreaSegment2.__proto__ = AreaSegment2;
  SplineAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  SplineAreaSegment2.prototype.constructor = SplineAreaSegment2;
  SplineAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    var curveProcessor = new curve_processor_default(this.options.closed);
    var linePoints = this.points();
    return curveProcessor.process(linePoints);
  };
  SplineAreaSegment2.prototype.createStackSegments = function createStackSegments() {
    var strokeSegments = this.strokeSegments();
    var stackSegments = [];
    for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {
      var segment = strokeSegments[idx];
      stackSegments.push(new geometry_exports.Segment(
        segment.anchor(),
        segment.controlOut(),
        segment.controlIn()
      ));
    }
    return stackSegments;
  };
  return SplineAreaSegment2;
}(area_segment_default);
var spline_area_segment_default = SplineAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js
var AreaChart = function(LineChart2) {
  function AreaChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2) AreaChart2.__proto__ = LineChart2;
  AreaChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  AreaChart2.prototype.constructor = AreaChart2;
  AreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    if (isStacked && seriesIx > 0 && prevSegment) {
      var missingValues = this.seriesMissingValues(currentSeries);
      if (missingValues !== "gap") {
        stackPoints = prevSegment.linePoints;
        previousSegment = prevSegment;
      } else {
        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);
      }
    }
    var pointType;
    if (style === STEP) {
      pointType = step_area_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_area_segment_default;
    } else {
      pointType = area_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
  };
  AreaChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    LineChart2.prototype.reflow.call(this, targetBox);
    var stackPoints = this._stackPoints;
    if (stackPoints) {
      for (var idx = 0; idx < stackPoints.length; idx++) {
        var stackPoint = stackPoints[idx];
        var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);
        stackPoint.reflow(pointSlot);
      }
    }
  };
  AreaChart2.prototype._gapStackPoints = function _gapStackPoints(linePoints, seriesIx, style) {
    var this$1 = this;
    var seriesPoints = this.seriesPoints;
    var startIdx = linePoints[0].categoryIx;
    var length = linePoints.length;
    if (startIdx < 0) {
      startIdx = 0;
      length--;
    }
    var endIdx = startIdx + length;
    var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;
    var stackPoints = [];
    this._stackPoints = this._stackPoints || [];
    for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {
      var pointIx = categoryIx + pointOffset;
      var currentSeriesIx = seriesIx;
      var point = void 0;
      do {
        currentSeriesIx--;
        point = seriesPoints[currentSeriesIx][pointIx];
      } while (currentSeriesIx > 0 && !point);
      if (point) {
        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));
        }
        stackPoints.push(point);
        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));
        }
      } else {
        var gapStackPoint = this$1._createGapStackPoint(categoryIx);
        this$1._stackPoints.push(gapStackPoint);
        stackPoints.push(gapStackPoint);
      }
    }
    return stackPoints;
  };
  AreaChart2.prototype._previousSegmentPoint = function _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {
    var seriesPoints = this.seriesPoints;
    var index = seriesIdx;
    var point;
    while (index > 0 && !point) {
      index--;
      point = seriesPoints[index][segmentIx];
    }
    if (!point) {
      point = this._createGapStackPoint(categoryIx);
      this._stackPoints.push(point);
    } else {
      point = seriesPoints[index][pointIx];
    }
    return point;
  };
  AreaChart2.prototype._createGapStackPoint = function _createGapStackPoint(categoryIx) {
    var options = this.pointOptions({}, 0);
    var point = new line_point_default(0, options);
    point.categoryIx = categoryIx;
    point.series = {};
    return point;
  };
  AreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  AreaChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return AreaChart2;
}(line_chart_default);
var area_chart_default = AreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/axis-group-range-tracker.js
var AxisGroupRangeTracker = function(Class) {
  function AxisGroupRangeTracker2() {
    Class.call(this);
    this.axisRanges = {};
  }
  if (Class) AxisGroupRangeTracker2.__proto__ = Class;
  AxisGroupRangeTracker2.prototype = Object.create(Class && Class.prototype);
  AxisGroupRangeTracker2.prototype.constructor = AxisGroupRangeTracker2;
  AxisGroupRangeTracker2.prototype.update = function update(chartAxisRanges) {
    var axisRanges2 = this.axisRanges;
    for (var axisName in chartAxisRanges) {
      var chartRange = chartAxisRanges[axisName];
      var range = axisRanges2[axisName];
      axisRanges2[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };
      range.min = Math.min(range.min, chartRange.min);
      range.max = Math.max(range.max, chartRange.max);
    }
  };
  AxisGroupRangeTracker2.prototype.reset = function reset(axisName) {
    this.axisRanges[axisName] = void 0;
  };
  AxisGroupRangeTracker2.prototype.query = function query(axisName) {
    return this.axisRanges[axisName];
  };
  return AxisGroupRangeTracker2;
}(class_default);
var axis_group_range_tracker_default = AxisGroupRangeTracker;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-label.js
var BarLabel = function(ChartElement2) {
  function BarLabel2(content, options, pointData) {
    ChartElement2.call(this, options);
    this.textBox = new text_box_default(content, this.options, pointData);
    this.append(this.textBox);
  }
  if (ChartElement2) BarLabel2.__proto__ = ChartElement2;
  BarLabel2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BarLabel2.prototype.constructor = BarLabel2;
  BarLabel2.prototype.createVisual = function createVisual() {
    this.textBox.options.noclip = this.options.noclip;
  };
  BarLabel2.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var vertical = options.vertical;
    var aboveAxis = options.aboveAxis;
    var text = this.children[0];
    var textOptions = text.options;
    var box = text.box;
    var padding = text.options.padding;
    var labelBox = targetBox;
    textOptions.align = vertical ? CENTER : LEFT;
    textOptions.vAlign = vertical ? TOP : CENTER;
    if (options.position === INSIDE_END) {
      if (vertical) {
        textOptions.vAlign = TOP;
        if (!aboveAxis && box.height() < targetBox.height()) {
          textOptions.vAlign = BOTTOM;
        }
      } else {
        textOptions.align = aboveAxis ? RIGHT : LEFT;
      }
    } else if (options.position === CENTER) {
      textOptions.vAlign = CENTER;
      textOptions.align = CENTER;
    } else if (options.position === INSIDE_BASE) {
      if (vertical) {
        textOptions.vAlign = aboveAxis ? BOTTOM : TOP;
      } else {
        textOptions.align = aboveAxis ? LEFT : RIGHT;
      }
    } else if (options.position === OUTSIDE_END) {
      if (vertical) {
        if (aboveAxis) {
          var boxesDiff = (box.width() - targetBox.width() - padding.left - padding.right) / 2;
          labelBox = new box_default(
            targetBox.x1 - boxesDiff,
            targetBox.y1 - box.height(),
            targetBox.x2 + boxesDiff,
            targetBox.y1
          );
        } else {
          labelBox = new box_default(
            targetBox.x1,
            targetBox.y2,
            targetBox.x2,
            targetBox.y2 + box.height()
          );
        }
      } else {
        textOptions.align = CENTER;
        if (aboveAxis) {
          labelBox = new box_default(
            targetBox.x2,
            targetBox.y1,
            targetBox.x2 + box.width(),
            targetBox.y2
          );
        } else {
          labelBox = new box_default(
            targetBox.x1 - box.width(),
            targetBox.y1,
            targetBox.x1,
            targetBox.y2
          );
        }
      }
    }
    if (!options.rotation) {
      if (vertical) {
        padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;
      } else {
        padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;
      }
    }
    text.reflow(labelBox);
  };
  BarLabel2.prototype.alignToClipBox = function alignToClipBox(clipBox) {
    var vertical = this.options.vertical;
    var field = vertical ? Y : X;
    var start = field + "1";
    var end = field + "2";
    var text = this.children[0];
    var parentBox = this.parent.box;
    if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {
      var targetBox = text.paddingBox.clone();
      targetBox[start] = Math.max(parentBox[start], clipBox[start]);
      targetBox[end] = Math.min(parentBox[end], clipBox[end]);
      this.reflow(targetBox);
    }
  };
  return BarLabel2;
}(chart_element_default);
setDefaultOptions(BarLabel, {
  position: OUTSIDE_END,
  margin: getSpacing(3),
  padding: getSpacing(4),
  color: BLACK,
  background: "",
  border: {
    width: 1,
    color: ""
  },
  aboveAxis: true,
  vertical: false,
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  zIndex: 2
});
var bar_label_default = BarLabel;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/accessibility-attributes-mixin.js
var AccessibilityAttributesMixin = {
  addAccessibilityAttributesToVisual: function() {
    this._id = this._id || guid();
    var accessibilityOptions = deepExtend({
      ariaLabel: this.getAriaLabelText()
    }, this.options.accessibility);
    addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
  },
  getAriaLabelText: function getAriaLabelText() {
    var labels = this.options.labels;
    var ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  },
  focusVisual: function focusVisual() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
  },
  clearFocusFromVisual: function clearFocusFromVisual() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
  }
};
var accessibility_attributes_mixin_default = AccessibilityAttributesMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar.js
var BAR_ALIGN_MIN_WIDTH = 6;
var Bar = function(ChartElement2) {
  function Bar2(value2, options) {
    ChartElement2.call(this);
    this.options = options;
    this.color = options.color || WHITE;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.value = value2;
  }
  if (ChartElement2) Bar2.__proto__ = ChartElement2;
  Bar2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bar2.prototype.constructor = Bar2;
  Bar2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  Bar2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  Bar2.prototype.createLabelElement = function createLabelElement(options) {
    return new bar_label_default(
      this.getLabelText(options),
      deepExtend(
        {
          vertical: this.options.vertical
        },
        options
      ),
      this.pointData()
    );
  };
  Bar2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  };
  Bar2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  Bar2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    if (this.errorBars) {
      for (var i36 = 0; i36 < this.errorBars.length; i36++) {
        this$1.errorBars[i36].reflow(targetBox);
      }
    }
  };
  Bar2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var options = ref2.options;
    var customVisual = options.visual;
    if (this.visible !== false) {
      ChartElement2.prototype.createVisual.call(this);
      this.addAccessibilityAttributesToVisual();
      if (customVisual) {
        var visual = this.rectVisual = customVisual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          sender: this.getSender(),
          series: this.series,
          percentage: this.percentage,
          stackValue: this.stackValue,
          runningTotal: this.runningTotal,
          total: this.total,
          rect: box.toRect(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createRect(group);
            return group;
          },
          options
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else if (box.width() > 0 && box.height() > 0) {
        this.createRect(this.visual);
      }
    }
  };
  Bar2.prototype.createRect = function createRect(visual) {
    var options = this.options;
    var border = options.border;
    var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;
    var rect = this.box.toRect();
    rect.size.width = Math.round(rect.size.width);
    var path = this.rectVisual = drawing_exports.Path.fromRect(rect, {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: {
        color: this.getBorderColor(),
        width: border.width,
        opacity: strokeOpacity,
        dashType: border.dashType
      }
    });
    var width = this.box.width();
    var height = this.box.height();
    var size = options.vertical ? width : height;
    if (size > BAR_ALIGN_MIN_WIDTH) {
      alignPathToPixel(path);
      if (width < 1 || height < 1) {
        path.options.stroke.lineJoin = "round";
      }
    }
    visual.append(path);
    if (hasGradientOverlay(options)) {
      var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay));
      visual.append(overlay);
    }
  };
  Bar2.prototype.createHighlight = function createHighlight(style) {
    var highlight = drawing_exports.Path.fromRect(this.box.toRect(), style);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  Bar2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  Bar2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = this.options.focusHighlight.border.width;
    var highlight = drawing_exports.Path.fromRect(this.box.pad(borderWidth / 2).toRect(), style);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.getBorderColor = function getBorderColor() {
    var color = this.color;
    var border = this.options.border;
    var brightness = border._brightness || BORDER_BRIGHTNESS;
    var borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(color).brightness(brightness).toHex();
    }
    return borderColor;
  };
  Bar2.prototype.tooltipAnchor = function tooltipAnchor() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var aboveAxis = ref2.aboveAxis;
    var clipBox = this.owner.pane.clipBox() || box;
    var horizontalAlign = LEFT;
    var verticalAlign = TOP;
    var x5, y;
    if (options.vertical) {
      x5 = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;
      if (aboveAxis) {
        y = Math.max(box.y1, clipBox.y1);
      } else {
        y = Math.min(box.y2, clipBox.y2);
        verticalAlign = BOTTOM;
      }
    } else {
      var x1 = Math.max(box.x1, clipBox.x1);
      var x22 = Math.min(box.x2, clipBox.x2);
      if (options.isStacked) {
        verticalAlign = BOTTOM;
        if (aboveAxis) {
          horizontalAlign = RIGHT;
          x5 = x22;
        } else {
          x5 = x1;
        }
        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;
      } else {
        if (aboveAxis) {
          x5 = x22 + TOOLTIP_OFFSET;
        } else {
          x5 = x1 - TOOLTIP_OFFSET;
          horizontalAlign = RIGHT;
        }
        y = Math.max(box.y1, clipBox.y1);
      }
    }
    return {
      point: new point_default(x5, y),
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  Bar2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bar2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      runningTotal: this.runningTotal,
      total: this.total,
      series: this.series
    };
  };
  Bar2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Bar2;
}(chart_element_default);
deepExtend(Bar.prototype, point_events_mixin_default);
deepExtend(Bar.prototype, note_mixin_default);
deepExtend(Bar.prototype, accessibility_attributes_mixin_default);
Bar.prototype.defaults = {
  border: {
    width: 1
  },
  vertical: true,
  overlay: {
    gradient: "glass"
  },
  labels: {
    visible: false,
    format: "{0}"
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var bar_default = Bar;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/utils.js
function forEach(elements, callback) {
  elements.forEach(callback);
}
function forEachReverse(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx - length - 1);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/layout/cluster-layout.js
var ClusterLayout = function(ChartElement2) {
  function ClusterLayout2(options) {
    ChartElement2.call(this, options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  if (ChartElement2) ClusterLayout2.__proto__ = ChartElement2;
  ClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ClusterLayout2.prototype.constructor = ClusterLayout2;
  ClusterLayout2.prototype.reflow = function reflow(box) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var gap = ref2.gap;
    var spacing = ref2.spacing;
    var children = this.children;
    var count = children.length;
    var axis = vertical ? Y : X;
    var slots = count + gap + spacing * (count - 1);
    var slotSize = (vertical ? box.height() : box.width()) / slots;
    var position = box[axis + 1] + slotSize * (gap / 2);
    this.forEach(children, function(child, idx) {
      var childBox = (child.box || box).clone();
      childBox[axis + 1] = position;
      childBox[axis + 2] = position + slotSize;
      child.reflow(childBox);
      if (idx < count - 1) {
        position += slotSize * spacing;
      }
      position += slotSize;
    });
  };
  return ClusterLayout2;
}(chart_element_default);
setDefaultOptions(ClusterLayout, {
  vertical: false,
  gap: 0,
  spacing: 0
});
var cluster_layout_default = ClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/stack-wrap.js
var StackWrap = function(ChartElement2) {
  function StackWrap2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2) StackWrap2.__proto__ = ChartElement2;
  StackWrap2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  StackWrap2.prototype.constructor = StackWrap2;
  StackWrap2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var positionAxis = this.options.vertical ? X : Y;
    var children = this.children;
    var childrenCount = children.length;
    var box = this.box = new box_default();
    for (var i36 = 0; i36 < childrenCount; i36++) {
      var currentChild = children[i36];
      if (currentChild.visible !== false) {
        var childBox = currentChild.box.clone();
        childBox.snapTo(targetBox, positionAxis);
        if (i36 === 0) {
          box = this$1.box = childBox.clone();
        }
        currentChild.reflow(childBox);
        box.wrap(childBox);
      }
    }
  };
  return StackWrap2;
}(chart_element_default);
setDefaultOptions(StackWrap, {
  vertical: true
});
var stack_wrap_default = StackWrap;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-chart.js
var BarChart = function(CategoricalChart2) {
  function BarChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) BarChart2.__proto__ = CategoricalChart2;
  BarChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BarChart2.prototype.constructor = BarChart2;
  BarChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
  };
  BarChart2.prototype.pointType = function pointType() {
    return bar_default;
  };
  BarChart2.prototype.clusterType = function clusterType() {
    return cluster_layout_default;
  };
  BarChart2.prototype.stackType = function stackType() {
    return stack_wrap_default;
  };
  BarChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var limits = CategoricalChart2.prototype.stackLimits.call(this, axisName, stackName);
    return limits;
  };
  BarChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var stackOrDefault = defined(series.stack) ? series.stack : options.defaultStack;
    var value2 = this.pointValue(data);
    var pointOptions = this.pointOptions(series, seriesIx);
    var labelOptions = pointOptions.labels;
    if (stackOrDefault) {
      if (labelOptions.position === OUTSIDE_END) {
        labelOptions.position = INSIDE_END;
      }
    }
    pointOptions.isStacked = stackOrDefault;
    var color = data.fields.color || series.color;
    if (value2 < 0 && pointOptions.negativeColor) {
      color = pointOptions.negativeColor;
    }
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var pointType = this.pointType();
    var point = new pointType(value2, pointOptions);
    point.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      var clusterType = this.clusterType();
      cluster = new clusterType({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (options.isStacked) {
      var stackWrap = this.getStackWrap(stackOrDefault, cluster);
      stackWrap.append(point);
    } else {
      cluster.append(point);
    }
    return point;
  };
  BarChart2.prototype.getStackWrap = function getStackWrap(stack, cluster) {
    var stackGroup = typeof stack === OBJECT ? stack.group || true : stack;
    var wraps = cluster.children;
    var stackWrap;
    if (typeof stackGroup === STRING || stackGroup === true) {
      for (var i36 = 0; i36 < wraps.length; i36++) {
        if (wraps[i36]._stackGroup === stackGroup) {
          stackWrap = wraps[i36];
          break;
        }
      }
    }
    if (!stackWrap) {
      var stackType = this.stackType();
      stackWrap = new stackType({
        vertical: !this.options.invertAxes
      });
      stackWrap._stackGroup = stackGroup;
      cluster.append(stackWrap);
    }
    return stackWrap;
  };
  BarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx, valueAxis) {
    var options = this.options;
    var categorySlot2 = categoryAxis.getSlot(categoryIx);
    var startValue = valueAxis.startValue();
    if (options.isStacked) {
      var zeroSlot = valueAxis.getSlot(startValue, startValue, true);
      var stackAxis = options.invertAxes ? X : Y;
      categorySlot2[stackAxis + 1] = categorySlot2[stackAxis + 2] = zeroSlot[stackAxis + 1];
    }
    return categorySlot2;
  };
  BarChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i36 = 0; i36 < childrenLength; i36++) {
      children[i36].reflow(categorySlots[i36]);
    }
  };
  BarChart2.prototype.createAnimation = function createAnimation() {
    this._setAnimationOptions();
    CategoricalChart2.prototype.createAnimation.call(this);
    if (anyHasZIndex(this.options.series)) {
      this._setChildrenAnimation();
    }
  };
  BarChart2.prototype._setChildrenAnimation = function _setChildrenAnimation() {
    var this$1 = this;
    var points = this.points;
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      var pointVisual = point.visual;
      if (pointVisual && defined(pointVisual.options.zIndex)) {
        point.options.animation = this$1.options.animation;
        point.createAnimation();
      }
    }
  };
  BarChart2.prototype._setAnimationOptions = function _setAnimationOptions() {
    var options = this.options;
    var animation = options.animation || {};
    var origin;
    if (options.isStacked) {
      var valueAxis = this.seriesValueAxis(options.series[0]);
      origin = valueAxis.getSlot(valueAxis.startValue());
    } else {
      origin = this.categoryAxis.getSlot(0);
    }
    animation.origin = new geometry_exports.Point(origin.x1, origin.y1);
    animation.vertical = !options.invertAxes;
  };
  return BarChart2;
}(categorical_chart_default);
setDefaultOptions(BarChart, {
  animation: {
    type: BAR
  }
});
var bar_chart_default = BarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick.js
var Candlestick = function(ChartElement2) {
  function Candlestick2(value2, options) {
    ChartElement2.call(this, options);
    this.value = value2;
  }
  if (ChartElement2) Candlestick2.__proto__ = ChartElement2;
  Candlestick2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Candlestick2.prototype.constructor = Candlestick2;
  Candlestick2.prototype.getLabelText = function getLabelText(options) {
    return this.formatValue(options.format);
  };
  Candlestick2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options);
    var ocSlot = valueAxis.getSlot(value2.open, value2.close);
    var lhSlot = valueAxis.getSlot(value2.low, value2.high);
    ocSlot.x1 = lhSlot.x1 = box.x1;
    ocSlot.x2 = lhSlot.x2 = box.x2;
    this.realBody = ocSlot;
    var mid = lhSlot.center().x;
    var points = [];
    points.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);
    points.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);
    this.lines = points;
    this.box = lhSlot.clone().wrap(ocSlot);
    if (!this._rendered) {
      this._rendered = true;
      this.createNote();
    }
    this.reflowNote();
  };
  Candlestick2.prototype.reflowNote = function reflowNote() {
    if (this.note) {
      this.note.reflow(this.box);
    }
  };
  Candlestick2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    this._mainVisual = this.mainVisual(this.options);
    this.visual.append(
      this._mainVisual
    );
    this.createOverlay();
  };
  Candlestick2.prototype.mainVisual = function mainVisual(options) {
    var group = new drawing_exports.Group();
    this.createBody(group, options);
    this.createLines(group, options);
    return group;
  };
  Candlestick2.prototype.createBody = function createBody(container, options) {
    var body = drawing_exports.Path.fromRect(this.realBody.toRect(), {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: this.getBorderColor(),
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    alignPathToPixel(body);
    container.append(body);
    if (hasGradientOverlay(options)) {
      container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay)));
    }
  };
  Candlestick2.prototype.createLines = function createLines(container, options) {
    this.drawLines(container, options, this.lines, options.line);
  };
  Candlestick2.prototype.drawLines = function drawLines(container, options, lines, lineOptions) {
    if (!lines) {
      return;
    }
    var lineStyle = {
      stroke: {
        color: lineOptions.color || this.color,
        opacity: valueOrDefault(lineOptions.opacity, options.opacity),
        width: lineOptions.width,
        dashType: lineOptions.dashType,
        lineCap: "butt"
      }
    };
    for (var i36 = 0; i36 < lines.length; i36++) {
      var line = drawing_exports.Path.fromPoints(lines[i36], lineStyle);
      alignPathToPixel(line);
      container.append(line);
    }
  };
  Candlestick2.prototype.getBorderColor = function getBorderColor() {
    var border = this.options.border;
    var borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(this.color).brightness(border._brightness).toHex();
    }
    return borderColor;
  };
  Candlestick2.prototype.createOverlay = function createOverlay() {
    var overlay = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null
    });
    this.visual.append(overlay);
  };
  Candlestick2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var normalColor = this.color;
    this.color = highlight.color || this.color;
    var overlay = this.mainVisual(
      deepExtend({}, this.options, {
        line: {
          color: this.getBorderColor()
        }
      }, highlight)
    );
    this.color = normalColor;
    return overlay;
  };
  Candlestick2.prototype.highlightVisual = function highlightVisual() {
    return this._mainVisual;
  };
  Candlestick2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this._mainVisual
    };
  };
  Candlestick2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    var clipBox = this.owner.pane.clipBox() || box;
    return {
      point: new point_default(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),
      align: {
        horizontal: LEFT,
        vertical: TOP
      }
    };
  };
  Candlestick2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  Candlestick2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Candlestick2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      value: this.value,
      meanPoints: this.meanPoints,
      medianPoints: this.medianPoints,
      whiskerPoints: this.whiskerPoints,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  Candlestick2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Candlestick2;
}(chart_element_default);
Candlestick.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Candlestick, {
  vertical: true,
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>"
  },
  labels: {
    format: ""
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Candlestick.prototype, point_events_mixin_default);
deepExtend(Candlestick.prototype, note_mixin_default);
deepExtend(Candlestick.prototype, accessibility_attributes_mixin_default);
var candlestick_default = Candlestick;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick-chart.js
var CandlestickChart = function(CategoricalChart2) {
  function CandlestickChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) CandlestickChart2.__proto__ = CategoricalChart2;
  CandlestickChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  CandlestickChart2.prototype.constructor = CandlestickChart2;
  CandlestickChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i36 = 0; i36 < childrenLength; i36++) {
      children[i36].reflow(categorySlots[i36]);
    }
  };
  CandlestickChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options = ref2.options;
    var value2 = data.valueFields;
    var valueParts = this.splitValue(value2);
    var hasValue4 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue4) {
      point = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
      point.noteText = data.fields.noteText;
    }
    this.points.push(point);
    categoryPoints.push(point);
  };
  CandlestickChart2.prototype.pointType = function pointType() {
    return candlestick_default;
  };
  CandlestickChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var pointType = this.pointType();
    var value2 = data.valueFields;
    var pointOptions = deepExtend({}, series);
    var color = data.fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (series.type === CANDLESTICK || series.type === OHLC) {
      if (value2.open > value2.close) {
        color = data.fields.downColor || series.downColor || series.color;
      }
    }
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.vertical = !this.options.invertAxes;
    var point = new pointType(value2, pointOptions);
    point.color = color;
    return point;
  };
  CandlestickChart2.prototype.splitValue = function splitValue(value2) {
    return [value2.low, value2.open, value2.close, value2.high];
  };
  CandlestickChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value2);
    var axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  CandlestickChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(
      format,
      value2.open,
      value2.high,
      value2.low,
      value2.close,
      point.category
    );
  };
  CandlestickChart2.prototype.animationPoints = function animationPoints() {
    return this.points;
  };
  return CandlestickChart2;
}(categorical_chart_default);
deepExtend(CandlestickChart.prototype, clip_animation_mixin_default);
var candlestick_chart_default = CandlestickChart;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot.js
var BoxPlot = function(Candlestick2) {
  function BoxPlot2(value2, options) {
    Candlestick2.call(this, value2, options);
    this.createNote();
  }
  if (Candlestick2) BoxPlot2.__proto__ = Candlestick2;
  BoxPlot2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  BoxPlot2.prototype.constructor = BoxPlot2;
  BoxPlot2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options);
    var whiskerSlot, boxSlot;
    this.boxSlot = boxSlot = valueAxis.getSlot(value2.q1, value2.q3);
    this.realBody = boxSlot;
    this.reflowBoxSlot(box);
    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value2.lower, value2.upper);
    this.reflowWhiskerSlot(box);
    var medianSlot = valueAxis.getSlot(value2.median);
    if (value2.mean) {
      var meanSlot = valueAxis.getSlot(value2.mean);
      this.meanPoints = this.calcMeanPoints(box, meanSlot);
    }
    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);
    this.medianPoints = this.calcMedianPoints(box, medianSlot);
    this.box = whiskerSlot.clone().wrap(boxSlot);
    this.reflowNote();
  };
  BoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.x1 = box.x1;
    this.boxSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.x1 = box.x1;
    this.whiskerSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]
    ];
  };
  BoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().x;
    return [[
      [mid - 5, whiskerSlot.y1],
      [mid + 5, whiskerSlot.y1],
      [mid, whiskerSlot.y1],
      [mid, boxSlot.y1]
    ], [
      [mid - 5, whiskerSlot.y2],
      [mid + 5, whiskerSlot.y2],
      [mid, whiskerSlot.y2],
      [mid, boxSlot.y2]
    ]];
  };
  BoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]
    ];
  };
  BoxPlot2.prototype.renderOutliers = function renderOutliers(options) {
    var this$1 = this;
    var value2 = this.value;
    var outliers = value2.outliers || [];
    var outerFence = Math.abs(value2.q3 - value2.q1) * 3;
    var elements = [];
    var markers = options.markers || {};
    for (var i36 = 0; i36 < outliers.length; i36++) {
      var outlierValue = outliers[i36];
      if (outlierValue < value2.q3 + outerFence && outlierValue > value2.q1 - outerFence) {
        markers = options.outliers;
      } else {
        markers = options.extremes;
      }
      var markersBorder = deepExtend({}, markers.border);
      if (!defined(markersBorder.color)) {
        if (defined(this$1.color)) {
          markersBorder.color = this$1.color;
        } else {
          markersBorder.color = new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex();
        }
      }
      var shape = new shape_element_default({
        type: markers.type,
        width: markers.size,
        height: markers.size,
        rotation: markers.rotation,
        background: markers.background,
        border: markersBorder,
        opacity: markers.opacity
      });
      shape.value = outlierValue;
      elements.push(shape);
    }
    this.reflowOutliers(elements);
    return elements;
  };
  BoxPlot2.prototype.reflowOutliers = function reflowOutliers(outliers) {
    var this$1 = this;
    var valueAxis = this.owner.seriesValueAxis(this.options);
    var center = this.box.center();
    for (var i36 = 0; i36 < outliers.length; i36++) {
      var outlierValue = outliers[i36].value;
      var markerBox = valueAxis.getSlot(outlierValue);
      if (this$1.options.vertical) {
        markerBox.move(center.x);
      } else {
        markerBox.move(void 0, center.y);
      }
      this$1.box = this$1.box.wrap(markerBox);
      outliers[i36].reflow(markerBox);
    }
  };
  BoxPlot2.prototype.mainVisual = function mainVisual(options) {
    var group = Candlestick2.prototype.mainVisual.call(this, options);
    var outliers = this.renderOutliers(options);
    for (var i36 = 0; i36 < outliers.length; i36++) {
      var element = outliers[i36].getElement();
      if (element) {
        group.append(element);
      }
    }
    return group;
  };
  BoxPlot2.prototype.createLines = function createLines(container, options) {
    this.drawLines(container, options, this.whiskerPoints, options.whiskers);
    this.drawLines(container, options, this.medianPoints, options.median);
    this.drawLines(container, options, this.meanPoints, options.mean);
  };
  BoxPlot2.prototype.getBorderColor = function getBorderColor() {
    if ((this.options.border || {}).color) {
      return this.options.border.color;
    }
    if (this.color) {
      return this.color;
    }
    return Candlestick2.prototype.getBorderColor.call(this);
  };
  return BoxPlot2;
}(candlestick_default);
setDefaultOptions(BoxPlot, {
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  median: {
    color: "#f6f6f6"
  },
  mean: {
    width: 2,
    dashType: "dash",
    color: "#f6f6f6"
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  outliers: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CROSS,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  },
  extremes: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  }
});
deepExtend(BoxPlot.prototype, point_events_mixin_default);
var box_plot_default = BoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/vertical-box-plot.js
var VerticalBoxPlot = function(BoxPlot2) {
  function VerticalBoxPlot2() {
    BoxPlot2.apply(this, arguments);
  }
  if (BoxPlot2) VerticalBoxPlot2.__proto__ = BoxPlot2;
  VerticalBoxPlot2.prototype = Object.create(BoxPlot2 && BoxPlot2.prototype);
  VerticalBoxPlot2.prototype.constructor = VerticalBoxPlot2;
  VerticalBoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.y1 = box.y1;
    this.boxSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.y1 = box.y1;
    this.whiskerSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]
    ];
  };
  VerticalBoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().y;
    return [[
      [whiskerSlot.x1, mid - 5],
      [whiskerSlot.x1, mid + 5],
      [whiskerSlot.x1, mid],
      [boxSlot.x1, mid]
    ], [
      [whiskerSlot.x2, mid - 5],
      [whiskerSlot.x2, mid + 5],
      [whiskerSlot.x2, mid],
      [boxSlot.x2, mid]
    ]];
  };
  VerticalBoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]
    ];
  };
  return VerticalBoxPlot2;
}(box_plot_default);
var vertical_box_plot_default = VerticalBoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot-chart.js
var BoxPlotChart = function(CandlestickChart2) {
  function BoxPlotChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2) BoxPlotChart2.__proto__ = CandlestickChart2;
  BoxPlotChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  BoxPlotChart2.prototype.constructor = BoxPlotChart2;
  BoxPlotChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options = ref2.options;
    var value2 = data.valueFields;
    var valueParts = this.splitValue(value2);
    var hasValue4 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue4) {
      point = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
    }
    this.points.push(point);
    categoryPoints.push(point);
  };
  BoxPlotChart2.prototype.pointType = function pointType() {
    if (this.options.invertAxes) {
      return vertical_box_plot_default;
    }
    return box_plot_default;
  };
  BoxPlotChart2.prototype.splitValue = function splitValue(value2) {
    return [
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper
    ];
  };
  BoxPlotChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value2).concat(this.filterOutliers(value2.outliers));
    if (defined(value2.mean)) {
      parts = parts.concat(value2.mean);
    }
    var axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  BoxPlotChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(
      format,
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper,
      value2.mean,
      point.category
    );
  };
  BoxPlotChart2.prototype.filterOutliers = function filterOutliers(items) {
    var length = (items || []).length;
    var result = [];
    for (var i36 = 0; i36 < length; i36++) {
      var item = items[i36];
      if (defined(item) && item !== null) {
        result.push(item);
      }
    }
    return result;
  };
  BoxPlotChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return BoxPlotChart2;
}(candlestick_chart_default);
var box_plot_chart_default = BoxPlotChart;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/scatter-error-bar.js
var ScatterErrorBar = function(ErrorBarBase2) {
  function ScatterErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2) ScatterErrorBar2.__proto__ = ErrorBarBase2;
  ScatterErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  ScatterErrorBar2.prototype.constructor = ScatterErrorBar2;
  ScatterErrorBar2.prototype.getAxis = function getAxis() {
    var axes = this.chart.seriesAxes(this.series);
    var axis = this.isVertical ? axes.y : axes.x;
    return axis;
  };
  return ScatterErrorBar2;
}(error_bar_base_default);
var scatter_error_bar_default = ScatterErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-chart.js
var ScatterChart = function(ChartElement2) {
  function ScatterChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2) ScatterChart2.__proto__ = ChartElement2;
  ScatterChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ScatterChart2.prototype.constructor = ScatterChart2;
  ScatterChart2.prototype._initFields = function _initFields() {
    this.xAxisRanges = {};
    this.yAxisRanges = {};
    this.points = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
  };
  ScatterChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  ScatterChart2.prototype.addErrorBar = function addErrorBar(point, field, fields) {
    var value2 = point.value[field];
    var valueErrorField = field + "Value";
    var lowField = field + "ErrorLow";
    var highField = field + "ErrorHigh";
    var seriesIx = fields.seriesIx;
    var series = fields.series;
    var errorBars = point.options.errorBars;
    var lowValue = fields[lowField];
    var highValue = fields[highField];
    if (isNumber(value2)) {
      var errorRange;
      if (isNumber(lowValue) && isNumber(highValue)) {
        errorRange = { low: lowValue, high: highValue };
      }
      if (errorBars && defined(errorBars[valueErrorField])) {
        this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };
        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new error_range_calculator_default(errorBars[valueErrorField], series, field);
        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value2, errorBars[valueErrorField]);
      }
      if (errorRange) {
        this.addPointErrorBar(errorRange, point, field);
      }
    }
  };
  ScatterChart2.prototype.addPointErrorBar = function addPointErrorBar(errorRange, point, field) {
    var low = errorRange.low;
    var high = errorRange.high;
    var series = point.series;
    var options = point.options.errorBars;
    var isVertical = field === Y;
    var item = {};
    point[field + "Low"] = low;
    point[field + "High"] = high;
    point.errorBars = point.errorBars || [];
    var errorBar = new scatter_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars.push(errorBar);
    point.append(errorBar);
    item[field] = low;
    this.updateRange(item, series);
    item[field] = high;
    this.updateRange(item, series);
  };
  ScatterChart2.prototype.addValue = function addValue(value2, fields) {
    var x5 = value2.x;
    var y = value2.y;
    var seriesIx = fields.seriesIx;
    var series = this.options.series[seriesIx];
    var missingValues = this.seriesMissingValues(series);
    var seriesPoints = this.seriesPoints[seriesIx];
    var pointValue = value2;
    if (!(hasValue(x5) && hasValue(y))) {
      pointValue = this.createMissingValue(pointValue, missingValues);
    }
    var point;
    if (pointValue) {
      point = this.createPoint(pointValue, fields);
      if (point) {
        Object.assign(point, fields);
        this.addErrorBar(point, X, fields);
        this.addErrorBar(point, Y, fields);
      }
      this.updateRange(pointValue, fields.series);
    }
    this.points.push(point);
    seriesPoints.push(point);
  };
  ScatterChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues;
  };
  ScatterChart2.prototype.createMissingValue = function createMissingValue() {
  };
  ScatterChart2.prototype.updateRange = function updateRange(value2, series) {
    var intlService = this.chartService.intl;
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var x5 = value2.x;
    var y = value2.y;
    var xAxisRange = this.xAxisRanges[xAxisName];
    var yAxisRange = this.yAxisRanges[yAxisName];
    if (hasValue(x5)) {
      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString(x5)) {
        x5 = parseDate(intlService, x5);
      }
      xAxisRange.min = Math.min(xAxisRange.min, x5);
      xAxisRange.max = Math.max(xAxisRange.max, x5);
    }
    if (hasValue(y)) {
      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString(y)) {
        y = parseDate(intlService, y);
      }
      yAxisRange.min = Math.min(yAxisRange.min, y);
      yAxisRange.max = Math.max(yAxisRange.max, y);
    }
  };
  ScatterChart2.prototype.evalPointOptions = function evalPointOptions(options, value2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    var pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem
      }, state);
    }
    return pointOptions;
  };
  ScatterChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  ScatterChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options = this.seriesOptions[seriesIx];
    if (!options) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options;
  };
  ScatterChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  ScatterChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      x: xAxis,
      y: yAxis
    };
  };
  ScatterChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value2, fields) {
      var point = chartPoints[pointIx++];
      var seriesAxes = this$1.seriesAxes(fields.series);
      var slotX = seriesAxes.x.getSlot(value2.x, value2.x, limit);
      var slotY = seriesAxes.y.getSlot(value2.y, value2.y, limit);
      if (point) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  ScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  ScatterChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var seriesPoints = ref2.seriesPoints;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var currentSeriesPoints = seriesPoints[seriesIx];
      if (!currentSeriesPoints) {
        seriesPoints[seriesIx] = [];
      }
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1.plotArea.bindPoint(currentSeries, pointIx);
        var value2 = ref$1.valueFields;
        var fields = ref$1.fields;
        callback(value2, deepExtend({
          pointIx,
          series: currentSeries,
          seriesIx,
          dataItem: currentSeries.data[pointIx],
          owner: this$1
        }, fields));
      }
    }
  };
  ScatterChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y);
  };
  ScatterChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  };
  return ScatterChart2;
}(chart_element_default);
setDefaultOptions(ScatterChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}"
  },
  labels: {
    format: "{0}, {1}"
  },
  clip: true
});
deepExtend(ScatterChart.prototype, clip_animation_mixin_default);
var scatter_chart_default = ScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble.js
var Bubble = function(LinePoint2) {
  function Bubble2(value2, options) {
    LinePoint2.call(this, value2, options);
    this.category = value2.category;
  }
  if (LinePoint2) Bubble2.__proto__ = LinePoint2;
  Bubble2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  Bubble2.prototype.constructor = Bubble2;
  Bubble2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var border = highlight.border;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width + border.width) / 2;
    var highlightGroup = new drawing_exports.Group();
    var shadow = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {
      stroke: {
        color: "none"
      },
      fill: this.createGradient({
        gradient: "bubbleShadow",
        color: markers.background,
        stops: [{
          offset: 0,
          color: markers.background,
          opacity: 0.3
        }, {
          offset: 1,
          color: markers.background,
          opacity: 0
        }]
      })
    });
    var overlay = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), {
      stroke: {
        color: border.color || new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),
        width: border.width,
        opacity: border.opacity
      },
      fill: createPatternFill(this.options.pattern, {
        color: markers.background,
        opacity: highlight.opacity
      })
    });
    highlightGroup.append(shadow, overlay);
    return highlightGroup;
  };
  Bubble2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var highlightOptions2 = this.options.focusHighlight;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width) / 2 + highlightOptions2.border.width / 2;
    var highlight = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), style);
    return highlight;
  };
  return Bubble2;
}(line_point_default);
Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {
  labels: {
    position: CENTER
  },
  highlight: {
    opacity: 1,
    border: {
      color: "#fff",
      width: 2,
      opacity: 1
    }
  }
});
Bubble.prototype.defaults.highlight.zIndex = void 0;
var bubble_default = Bubble;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble-chart.js
var BubbleChart = function(ScatterChart2) {
  function BubbleChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2) BubbleChart2.__proto__ = ScatterChart2;
  BubbleChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  BubbleChart2.prototype.constructor = BubbleChart2;
  BubbleChart2.prototype._initFields = function _initFields() {
    this._maxSize = MIN_VALUE;
    ScatterChart2.prototype._initFields.call(this);
  };
  BubbleChart2.prototype.addValue = function addValue(value2, fields) {
    if (value2.size !== null && (value2.size > 0 || value2.size < 0 && fields.series.negativeValues.visible)) {
      this._maxSize = Math.max(this._maxSize, Math.abs(value2.size));
      ScatterChart2.prototype.addValue.call(this, value2, fields);
    } else {
      this.points.push(null);
      this.seriesPoints[fields.seriesIx].push(null);
    }
  };
  BubbleChart2.prototype.reflow = function reflow(box) {
    this.updateBubblesSize(box);
    ScatterChart2.prototype.reflow.call(this, box);
  };
  BubbleChart2.prototype.pointType = function pointType() {
    return bubble_default;
  };
  BubbleChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointsCount = series.data.length;
    var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);
    var animationOptions = {
      delay,
      duration: INITIAL_ANIMATION_DURATION - delay,
      type: BUBBLE
    };
    var color = fields.color || series.color;
    if (value2.size < 0 && series.negativeValues.visible) {
      color = valueOrDefault(
        series.negativeValues.color,
        color
      );
    }
    var pointOptions = deepExtend({
      labels: {
        animation: {
          delay,
          duration: INITIAL_ANIMATION_DURATION - delay
        }
      }
    }, this.pointOptions(series, fields.seriesIx), {
      markers: {
        type: CIRCLE,
        border: series.border,
        opacity: series.opacity,
        animation: animationOptions
      }
    });
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.markers.background = color;
    var point = new bubble_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  BubbleChart2.prototype.updateBubblesSize = function updateBubblesSize(box) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var boxSize = Math.min(box.width(), box.height());
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesPoints = this$1.seriesPoints[seriesIx];
      var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);
      var maxSize = currentSeries.maxSize || boxSize * 0.2;
      var minR = minSize / 2;
      var maxR = maxSize / 2;
      var minArea = Math.PI * minR * minR;
      var maxArea = Math.PI * maxR * maxR;
      var areaRange = maxArea - minArea;
      var areaRatio = areaRange / this$1._maxSize;
      for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {
        var point = seriesPoints[pointIx];
        if (point) {
          var area = Math.abs(point.value.size) * areaRatio;
          var radius = Math.sqrt((minArea + area) / Math.PI);
          var baseZIndex = valueOrDefault(point.options.zIndex, 0);
          var zIndex = baseZIndex + (1 - radius / maxR);
          deepExtend(point.options, {
            zIndex,
            markers: {
              size: radius * 2,
              zIndex
            },
            labels: {
              zIndex: zIndex + 1
            }
          });
        }
      }
    }
  };
  BubbleChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.size, point.category);
  };
  BubbleChart2.prototype.createAnimation = function createAnimation() {
  };
  BubbleChart2.prototype.createVisual = function createVisual() {
  };
  return BubbleChart2;
}(scatter_chart_default);
setDefaultOptions(BubbleChart, {
  tooltip: {
    format: "{3}"
  },
  labels: {
    format: "{3}"
  }
});
var bubble_chart_default = BubbleChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/target.js
var Target = function(ShapeElement2) {
  function Target2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) Target2.__proto__ = ShapeElement2;
  Target2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  Target2.prototype.constructor = Target2;
  return Target2;
}(shape_element_default);
deepExtend(Target.prototype, point_events_mixin_default);
var target_default = Target;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet.js
var Bullet = function(ChartElement2) {
  function Bullet2(value2, options) {
    ChartElement2.call(this, options);
    this.aboveAxis = this.options.aboveAxis;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  if (ChartElement2) Bullet2.__proto__ = ChartElement2;
  Bullet2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bullet2.prototype.constructor = Bullet2;
  Bullet2.prototype.render = function render() {
    var options = this.options;
    if (!this._rendered) {
      this._rendered = true;
      if (defined(this.value.target)) {
        this.target = new target_default({
          type: options.target.shape,
          background: options.target.color || this.color,
          opacity: options.opacity,
          zIndex: options.zIndex,
          border: options.target.border,
          vAlign: TOP,
          align: RIGHT
        });
        this.target.value = this.value;
        this.target.dataItem = this.dataItem;
        this.target.series = this.series;
        this.append(this.target);
      }
      this.createLabel();
      this.createNote();
    }
  };
  Bullet2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  Bullet2.prototype.createLabelElement = function createLabelElement(options) {
    return new bar_label_default(
      this.getLabelText(options),
      options,
      this.pointData()
    );
  };
  Bullet2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  };
  Bullet2.prototype.reflow = function reflow(box) {
    this.render();
    var ref2 = this;
    var options = ref2.options;
    var target = ref2.target;
    var chart = ref2.owner;
    var invertAxes = options.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.options);
    var categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);
    var targetValueSlot = valueAxis.getSlot(this.value.target);
    var targetSlotX = invertAxes ? targetValueSlot : categorySlot;
    var targetSlotY = invertAxes ? categorySlot : targetValueSlot;
    if (target) {
      var targetSlot = new box_default(
        targetSlotX.x1,
        targetSlotY.y1,
        targetSlotX.x2,
        targetSlotY.y2
      );
      target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;
      target.options.width = invertAxes ? options.target.line.width : targetSlot.width();
      target.reflow(targetSlot);
    }
    var label = this.label;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(box);
    }
    if (this.note) {
      this.note.reflow(box);
    }
    this.box = box;
  };
  Bullet2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    var options = this.options;
    var body = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: options.border.color || this.color,
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    this.bodyVisual = body;
    alignPathToPixel(body);
    this.visual.append(body);
  };
  Bullet2.prototype.createAnimation = function createAnimation() {
    if (this.bodyVisual) {
      this.animation = drawing_exports.Animation.create(
        this.bodyVisual,
        this.options.animation
      );
    }
  };
  Bullet2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromRect(this.box.toRect(), style);
  };
  Bullet2.prototype.highlightVisual = function highlightVisual() {
    return this.bodyVisual;
  };
  Bullet2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      rect: this.box.toRect(),
      visual: this.bodyVisual,
      options: this.options
    };
  };
  Bullet2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  Bullet2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series
    };
  };
  Bullet2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bullet2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Bullet2;
}(chart_element_default);
Bullet.prototype.tooltipAnchor = bar_default.prototype.tooltipAnchor;
Bullet.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Bullet, {
  border: {
    width: 1
  },
  vertical: false,
  opacity: 1,
  target: {
    shape: "",
    border: {
      width: 0,
      color: "green"
    },
    line: {
      width: 2
    }
  },
  labels: {
    visible: false
  },
  tooltip: {
    format: "Current: {0}<br />Target: {1}"
  },
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Bullet.prototype, point_events_mixin_default);
deepExtend(Bullet.prototype, note_mixin_default);
deepExtend(Bullet.prototype, accessibility_attributes_mixin_default);
var bullet_default = Bullet;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet-chart.js
var BulletChart = function(CategoricalChart2) {
  function BulletChart2(plotArea, options) {
    wrapData(options);
    CategoricalChart2.call(this, plotArea, options);
  }
  if (CategoricalChart2) BulletChart2.__proto__ = CategoricalChart2;
  BulletChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BulletChart2.prototype.constructor = BulletChart2;
  BulletChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i36 = 0; i36 < childrenLength; i36++) {
      children[i36].reflow(categorySlots[i36]);
    }
  };
  BulletChart2.prototype.plotRange = function plotRange(point) {
    var series = point.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, point.value.current || axisCrossingValue];
  };
  BulletChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var value2 = data.valueFields;
    var bulletOptions = deepExtend({
      vertical: !options.invertAxes,
      overlay: series.overlay,
      categoryIx,
      invertAxes: options.invertAxes
    }, series);
    var color = data.fields.color || series.color;
    bulletOptions = this.evalPointOptions(bulletOptions, value2, fields);
    if (isFunction(series.color)) {
      color = bulletOptions.color;
    }
    var bullet = new bullet_default(value2, bulletOptions);
    bullet.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    cluster.append(bullet);
    return bullet;
  };
  BulletChart2.prototype.updateRange = function updateRange(value2, fields) {
    var current4 = value2.current;
    var target = value2.target;
    var axisName = fields.series.axis;
    var axisRange = this.valueAxisRanges[axisName];
    if (defined(current4) && !isNaN(current4) && defined(target && !isNaN(target))) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, current4, target);
      axisRange.max = Math.max(axisRange.max, current4, target);
    }
  };
  BulletChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value.current, point.value.target);
  };
  BulletChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.current;
  };
  BulletChart2.prototype.aboveAxis = function aboveAxis(point) {
    var value2 = point.value.current;
    return value2 > 0;
  };
  BulletChart2.prototype.createAnimation = function createAnimation() {
    var this$1 = this;
    var points = this.points;
    this._setAnimationOptions();
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      point.options.animation = this$1.options.animation;
      point.createAnimation();
    }
  };
  return BulletChart2;
}(categorical_chart_default);
BulletChart.prototype._setAnimationOptions = bar_chart_default.prototype._setAnimationOptions;
setDefaultOptions(BulletChart, {
  animation: {
    type: BAR
  }
});
function wrapData(options) {
  var series = options.series;
  for (var i36 = 0; i36 < series.length; i36++) {
    var seriesItem = series[i36];
    var data = seriesItem.data;
    if (data && !isArray(data[0]) && !isObject(data[0])) {
      seriesItem.data = [data];
    }
  }
}
var bullet_chart_default = BulletChart;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/base-tooltip.js
var BaseTooltip = function(Class) {
  function BaseTooltip2(chartService, options) {
    Class.call(this);
    this.chartService = chartService;
    this.options = deepExtend({}, this.options, options);
  }
  if (Class) BaseTooltip2.__proto__ = Class;
  BaseTooltip2.prototype = Object.create(Class && Class.prototype);
  BaseTooltip2.prototype.constructor = BaseTooltip2;
  BaseTooltip2.prototype.getStyle = function getStyle(options, point) {
    var background = options.background;
    var border = options.border.color;
    if (point) {
      var pointColor = point.color || point.options.color;
      background = valueOrDefault(background, pointColor);
      border = valueOrDefault(border, pointColor);
    }
    var padding = options.padding !== void 0 ? getSpacing(options.padding) : {};
    if (typeof options.padding === "object") {
      padding.top = options.padding.top !== void 0 ? padding.top : void 0;
      padding.right = options.padding.right !== void 0 ? padding.right : void 0;
      padding.bottom = options.padding.bottom !== void 0 ? padding.bottom : void 0;
      padding.left = options.padding.left !== void 0 ? padding.left : void 0;
    }
    return {
      backgroundColor: background,
      borderColor: border,
      font: options.font,
      color: options.color,
      opacity: options.opacity,
      borderWidth: styleValue(options.border.width),
      paddingTop: styleValue(padding.top),
      paddingBottom: styleValue(padding.bottom),
      paddingLeft: styleValue(padding.left),
      paddingRight: styleValue(padding.right)
    };
  };
  BaseTooltip2.prototype.show = function show2(options, tooltipOptions, point) {
    if (!this.chartService) {
      return;
    }
    options.format = tooltipOptions.format;
    var style = this.getStyle(tooltipOptions, point);
    options.style = style;
    var background = new color_default(style.backgroundColor);
    if (!defined(tooltipOptions.color) && !background.isDark()) {
      options.className = "k-chart-tooltip-inverse";
    }
    this.chartService.notify(SHOW_TOOLTIP, options);
    this.visible = true;
  };
  BaseTooltip2.prototype.hide = function hide2() {
    if (this.chartService) {
      this.chartService.notify(HIDE_TOOLTIP);
    }
    this.visible = false;
  };
  BaseTooltip2.prototype.destroy = function destroy() {
    delete this.chartService;
  };
  return BaseTooltip2;
}(class_default);
setDefaultOptions(BaseTooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var base_tooltip_default = BaseTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair-tooltip.js
var CrosshairTooltip = function(BaseTooltip2) {
  function CrosshairTooltip2(chartService, crosshair, options) {
    BaseTooltip2.call(this, chartService, options);
    this.crosshair = crosshair;
    this.formatService = chartService.format;
    this.initAxisName();
  }
  if (BaseTooltip2) CrosshairTooltip2.__proto__ = BaseTooltip2;
  CrosshairTooltip2.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  CrosshairTooltip2.prototype.constructor = CrosshairTooltip2;
  CrosshairTooltip2.prototype.initAxisName = function initAxisName() {
    var axis = this.crosshair.axis;
    var plotArea = axis.plotArea;
    var name2;
    if (plotArea.categoryAxis) {
      name2 = axis.getCategory ? "categoryAxis" : "valueAxis";
    } else {
      name2 = axis.options.vertical ? "yAxis" : "xAxis";
    }
    this.axisName = name2;
  };
  CrosshairTooltip2.prototype.showAt = function showAt(point) {
    var ref2 = this;
    var axis = ref2.crosshair.axis;
    var options = ref2.options;
    var value2 = axis[options.stickyMode ? "getCategory" : "getValue"](point);
    var formattedValue = value2;
    if (options.format) {
      formattedValue = this.formatService.auto(options.format, value2);
    } else if (axis.options.type === DATE) {
      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value2);
    }
    this.show({
      point,
      anchor: this.getAnchor(),
      crosshair: this.crosshair,
      value: formattedValue,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    }, this.options);
  };
  CrosshairTooltip2.prototype.hide = function hide2() {
    this.chartService.notify(HIDE_TOOLTIP, {
      crosshair: this.crosshair,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    });
  };
  CrosshairTooltip2.prototype.getAnchor = function getAnchor() {
    var ref2 = this;
    var crosshair = ref2.crosshair;
    var ref_options = ref2.options;
    var position = ref_options.position;
    var padding = ref_options.padding;
    var vertical = !crosshair.axis.options.vertical;
    var lineBox = crosshair.line.bbox();
    var horizontalAlign, verticalAlign, point;
    if (vertical) {
      horizontalAlign = CENTER;
      if (position === BOTTOM) {
        verticalAlign = TOP;
        point = lineBox.bottomLeft().translate(0, padding);
      } else {
        verticalAlign = BOTTOM;
        point = lineBox.topLeft().translate(0, -padding);
      }
    } else {
      verticalAlign = CENTER;
      if (position === LEFT) {
        horizontalAlign = RIGHT;
        point = lineBox.topLeft().translate(-padding, 0);
      } else {
        horizontalAlign = LEFT;
        point = lineBox.topRight().translate(padding, 0);
      }
    }
    return {
      point,
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  return CrosshairTooltip2;
}(base_tooltip_default);
setDefaultOptions(CrosshairTooltip, {
  padding: 10
});
var crosshair_tooltip_default = CrosshairTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair.js
var Crosshair = function(ChartElement2) {
  function Crosshair2(chartService, axis, options) {
    ChartElement2.call(this, options);
    this.axis = axis;
    this.stickyMode = axis instanceof category_axis_default;
    var tooltipOptions = this.options.tooltip;
    if (tooltipOptions.visible) {
      this.tooltip = new crosshair_tooltip_default(
        chartService,
        this,
        deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })
      );
    }
  }
  if (ChartElement2) Crosshair2.__proto__ = ChartElement2;
  Crosshair2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Crosshair2.prototype.constructor = Crosshair2;
  Crosshair2.prototype.showAt = function showAt(point) {
    this.point = point;
    this.moveLine();
    this.line.visible(true);
    if (this.tooltip) {
      this.tooltip.showAt(point);
    }
  };
  Crosshair2.prototype.hide = function hide2() {
    this.line.visible(false);
    if (this.tooltip) {
      this.tooltip.hide();
    }
  };
  Crosshair2.prototype.moveLine = function moveLine() {
    var ref2 = this;
    var axis = ref2.axis;
    var point = ref2.point;
    var vertical = axis.options.vertical;
    var box = this.getBox();
    var dim = vertical ? Y : X;
    var lineStart = new geometry_exports.Point(box.x1, box.y1);
    var lineEnd;
    if (vertical) {
      lineEnd = new geometry_exports.Point(box.x2, box.y1);
    } else {
      lineEnd = new geometry_exports.Point(box.x1, box.y2);
    }
    if (point) {
      if (this.stickyMode) {
        var slot = axis.getSlot(axis.pointCategoryIndex(point));
        lineStart[dim] = lineEnd[dim] = slot.center()[dim];
      } else {
        lineStart[dim] = lineEnd[dim] = point[dim];
      }
    }
    this.box = box;
    this.line.moveTo(lineStart).lineTo(lineEnd);
  };
  Crosshair2.prototype.getBox = function getBox() {
    var axis = this.axis;
    var axes = axis.pane.axes;
    var length = axes.length;
    var vertical = axis.options.vertical;
    var box = axis.lineBox().clone();
    var dim = vertical ? X : Y;
    var axisLineBox;
    for (var i36 = 0; i36 < length; i36++) {
      var currentAxis = axes[i36];
      if (currentAxis.options.vertical !== vertical) {
        if (!axisLineBox) {
          axisLineBox = currentAxis.lineBox().clone();
        } else {
          axisLineBox.wrap(currentAxis.lineBox());
        }
      }
    }
    box[dim + 1] = axisLineBox[dim + 1];
    box[dim + 2] = axisLineBox[dim + 2];
    return box;
  };
  Crosshair2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options = this.options;
    this.line = new drawing_exports.Path({
      stroke: {
        color: options.color,
        width: options.width,
        opacity: options.opacity,
        dashType: options.dashType
      },
      visible: false
    });
    this.moveLine();
    this.visual.append(this.line);
  };
  Crosshair2.prototype.destroy = function destroy() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    ChartElement2.prototype.destroy.call(this);
  };
  return Crosshair2;
}(chart_element_default);
setDefaultOptions(Crosshair, {
  color: BLACK,
  width: 2,
  zIndex: -1,
  tooltip: {
    visible: false
  }
});
var crosshair_default = Crosshair;

// node_modules/@progress/kendo-charts/dist/es/chart/chart-container.js
var ChartContainer = function(ChartElement2) {
  function ChartContainer2(options, pane) {
    ChartElement2.call(this, options);
    this.pane = pane;
  }
  if (ChartElement2) ChartContainer2.__proto__ = ChartElement2;
  ChartContainer2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ChartContainer2.prototype.constructor = ChartContainer2;
  ChartContainer2.prototype.shouldClip = function shouldClip() {
    var children = this.children;
    var length = children.length;
    for (var i36 = 0; i36 < length; i36++) {
      if (children[i36].options.clip === true) {
        return true;
      }
    }
    return false;
  };
  ChartContainer2.prototype._clipBox = function _clipBox() {
    return this.pane.chartsBox();
  };
  ChartContainer2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: 0
    });
    if (this.shouldClip()) {
      var clipBox = this.clipBox = this._clipBox();
      var clipRect = clipBox.toRect();
      var clipPath = drawing_exports.Path.fromRect(clipRect);
      alignPathToPixel(clipPath);
      this.visual.clip(clipPath);
      this.unclipLabels();
    }
  };
  ChartContainer2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  ChartContainer2.prototype.unclipLabels = function unclipLabels() {
    var ref2 = this;
    var charts = ref2.children;
    var clipBox = ref2.clipBox;
    for (var i36 = 0; i36 < charts.length; i36++) {
      var points = charts[i36].points || {};
      var length = points.length;
      for (var j2 = 0; j2 < length; j2++) {
        var point = points[j2];
        if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {
          if (point.unclipElements) {
            point.unclipElements();
          } else {
            var label = point.label;
            var note = point.note;
            if (label && label.options.visible) {
              if (label.alignToClipBox) {
                label.alignToClipBox(clipBox);
              }
              label.options.noclip = true;
            }
            if (note && note.options.visible) {
              note.options.noclip = true;
            }
          }
        }
      }
    }
  };
  ChartContainer2.prototype.destroy = function destroy() {
    ChartElement2.prototype.destroy.call(this);
    delete this.parent;
  };
  return ChartContainer2;
}(chart_element_default);
ChartContainer.prototype.isStackRoot = true;
var chart_container_default = ChartContainer;

// node_modules/@progress/kendo-charts/dist/es/chart/pane.js
var Pane = function(BoxElement2) {
  function Pane3(options) {
    BoxElement2.call(this, options);
    this.id = paneID();
    this.createTitle();
    this.content = new chart_element_default();
    this.chartContainer = new chart_container_default({}, this);
    this.append(this.content);
    this.axes = [];
    this.charts = [];
  }
  if (BoxElement2) Pane3.__proto__ = BoxElement2;
  Pane3.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Pane3.prototype.constructor = Pane3;
  Pane3.prototype.createTitle = function createTitle() {
    var titleOptions = this.options.title;
    if (isObject(titleOptions)) {
      titleOptions = deepExtend({}, titleOptions, {
        align: titleOptions.position,
        position: TOP
      });
    }
    this.title = title_default.buildTitle(titleOptions, Pane3.prototype.options.title);
    if (this.title) {
      this.append(this.title);
    }
  };
  Pane3.prototype.appendAxis = function appendAxis(axis) {
    this.content.append(axis);
    this.axes.push(axis);
    axis.pane = this;
  };
  Pane3.prototype.appendAxisAt = function appendAxisAt(axis, pos) {
    this.content.append(axis);
    this.axes.splice(pos, 0, axis);
    axis.pane = this;
  };
  Pane3.prototype.appendChart = function appendChart(chart) {
    if (this.chartContainer.parent !== this.content) {
      this.content.append(this.chartContainer);
    }
    this.charts.push(chart);
    this.chartContainer.append(chart);
    chart.pane = this;
  };
  Pane3.prototype.empty = function empty() {
    var this$1 = this;
    var plotArea = this.parent;
    if (plotArea) {
      for (var i36 = 0; i36 < this.axes.length; i36++) {
        plotArea.removeAxis(this$1.axes[i36]);
      }
      for (var i$1 = 0; i$1 < this.charts.length; i$1++) {
        plotArea.removeChart(this$1.charts[i$1]);
      }
    }
    this.axes = [];
    this.charts = [];
    this.content.destroy();
    this.content.children = [];
    this.chartContainer.children = [];
  };
  Pane3.prototype.reflow = function reflow(targetBox) {
    var content;
    if (last(this.children) === this.content) {
      content = this.children.pop();
    }
    BoxElement2.prototype.reflow.call(this, targetBox);
    if (content) {
      this.children.push(content);
    }
    if (this.title) {
      this.contentBox.y1 += this.title.box.height();
    }
  };
  Pane3.prototype.visualStyle = function visualStyle() {
    var style = BoxElement2.prototype.visualStyle.call(this);
    style.zIndex = -10;
    return style;
  };
  Pane3.prototype.renderComplete = function renderComplete() {
    if (this.options.visible) {
      this.createGridLines();
    }
  };
  Pane3.prototype.stackRoot = function stackRoot() {
    return this;
  };
  Pane3.prototype.clipRoot = function clipRoot() {
    return this;
  };
  Pane3.prototype.createGridLines = function createGridLines() {
    var axes = this.axes;
    var allAxes = axes.concat(this.parent.axes);
    var vGridLines = [];
    var hGridLines = [];
    for (var i36 = 0; i36 < axes.length; i36++) {
      var axis = axes[i36];
      var vertical = axis.options.vertical;
      var gridLines = vertical ? vGridLines : hGridLines;
      for (var j2 = 0; j2 < allAxes.length; j2++) {
        if (gridLines.length === 0) {
          var altAxis = allAxes[j2];
          if (vertical !== altAxis.options.vertical) {
            append(gridLines, axis.createGridLines(altAxis));
          }
        }
      }
    }
  };
  Pane3.prototype.refresh = function refresh() {
    this.visual.clear();
    this.content.parent = null;
    this.content.createGradient = this.createGradient.bind(this);
    this.content.renderVisual();
    this.content.parent = this;
    if (this.title) {
      this.visual.append(this.title.visual);
    }
    this.visual.append(this.content.visual);
    this.renderComplete();
    this.notifyRender();
  };
  Pane3.prototype.chartsBox = function chartsBox() {
    var axes = this.axes;
    var length = axes.length;
    var chartsBox2 = new box_default();
    for (var idx = 0; idx < length; idx++) {
      var axis = axes[idx];
      var axisValueField = axis.options.vertical ? Y : X;
      var lineBox = axis.lineBox();
      chartsBox2[axisValueField + 1] = lineBox[axisValueField + 1];
      chartsBox2[axisValueField + 2] = lineBox[axisValueField + 2];
    }
    if (chartsBox2.x2 === 0) {
      var allAxes = this.parent.axes;
      var length$1 = allAxes.length;
      for (var idx$1 = 0; idx$1 < length$1; idx$1++) {
        var axis$1 = allAxes[idx$1];
        if (!axis$1.options.vertical) {
          var lineBox$1 = axis$1.lineBox();
          chartsBox2.x1 = lineBox$1.x1;
          chartsBox2.x2 = lineBox$1.x2;
        }
      }
    }
    return chartsBox2;
  };
  Pane3.prototype.clipBox = function clipBox() {
    return this.chartContainer.clipBox;
  };
  Pane3.prototype.notifyRender = function notifyRender() {
    var service = this.getService();
    if (service) {
      service.notify(PANE_RENDER, {
        pane: new chart_pane_default(this),
        index: this.paneIndex,
        name: this.options.name
      });
    }
  };
  return Pane3;
}(box_element_default);
var ID2 = 1;
function paneID() {
  return "pane" + ID2++;
}
Pane.prototype.isStackRoot = true;
setDefaultOptions(Pane, {
  zIndex: -1,
  shrinkToFit: true,
  title: {
    align: LEFT
  },
  visible: true
});
var pane_default = Pane;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-base.js
var visiblePoint = function(point) {
  return point.options.visible !== false;
};
var PlotAreaBase = function(ChartElement2) {
  function PlotAreaBase2(series, options, chartService) {
    ChartElement2.call(this, options);
    this.initFields(series, options);
    this.series = series;
    this.initSeries();
    this.charts = [];
    this.options.legend = this.options.legend || {};
    this.options.legend.data = [];
    this.axes = [];
    this.crosshairs = [];
    this.chartService = chartService;
    this.originalOptions = options;
    this.originalSeries = series;
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.createPanes();
    this.render();
    this.createCrosshairs();
  }
  if (ChartElement2) PlotAreaBase2.__proto__ = ChartElement2;
  PlotAreaBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PlotAreaBase2.prototype.constructor = PlotAreaBase2;
  PlotAreaBase2.prototype.initFields = function initFields() {
  };
  PlotAreaBase2.prototype.initSeries = function initSeries() {
    var series = this.series;
    for (var i36 = 0; i36 < series.length; i36++) {
      series[i36].index = i36;
    }
  };
  PlotAreaBase2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var cached = this._bindCache.get(series);
    if (!cached) {
      cached = [];
      this._bindCache.set(series, cached);
    }
    var data = cached[pointIx];
    if (!data) {
      data = cached[pointIx] = series_binder_default.current.bindPoint(series, pointIx, item);
    }
    return data;
  };
  PlotAreaBase2.prototype.createPanes = function createPanes() {
    var this$1 = this;
    var titleOptions = this.options.title || {};
    var paneDefaults = this.options.paneDefaults;
    var paneOptions = this.options.panes || [];
    var panesLength = Math.max(paneOptions.length, 1);
    var panes = [];
    var defaults = deepExtend({
      title: {
        color: titleOptions.color
      }
    }, paneDefaults);
    for (var i36 = 0; i36 < panesLength; i36++) {
      var options = deepExtend({}, defaults, paneOptions[i36]);
      if (isString(options.title)) {
        options.title = deepExtend({ text: options.title }, defaults.title);
      }
      var currentPane = new pane_default(options);
      currentPane.paneIndex = i36;
      panes.push(currentPane);
      this$1.append(currentPane);
    }
    this.panes = panes;
  };
  PlotAreaBase2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return axis.options.crosshair;
  };
  PlotAreaBase2.prototype.createCrosshairs = function createCrosshairs(panes) {
    var this$1 = this;
    if (panes === void 0) panes = this.panes;
    for (var i36 = 0; i36 < panes.length; i36++) {
      var pane = panes[i36];
      for (var j2 = 0; j2 < pane.axes.length; j2++) {
        var axis = pane.axes[j2];
        var options = this$1.crosshairOptions(axis);
        if (options && options.visible) {
          var currentCrosshair = new crosshair_default(this$1.chartService, axis, options);
          this$1.crosshairs.push(currentCrosshair);
          pane.content.append(currentCrosshair);
        }
      }
    }
  };
  PlotAreaBase2.prototype.removeCrosshairs = function removeCrosshairs(pane) {
    var crosshairs = this.crosshairs;
    var axes = pane.axes;
    for (var i36 = crosshairs.length - 1; i36 >= 0; i36--) {
      for (var j2 = 0; j2 < axes.length; j2++) {
        if (crosshairs[i36].axis === axes[j2]) {
          crosshairs.splice(i36, 1);
          break;
        }
      }
    }
  };
  PlotAreaBase2.prototype.hideCrosshairs = function hideCrosshairs() {
    var crosshairs = this.crosshairs;
    for (var idx = 0; idx < crosshairs.length; idx++) {
      crosshairs[idx].hide();
    }
  };
  PlotAreaBase2.prototype.findPane = function findPane(name2) {
    var panes = this.panes;
    var matchingPane;
    for (var i36 = 0; i36 < panes.length; i36++) {
      if (panes[i36].options.name === name2) {
        matchingPane = panes[i36];
        break;
      }
    }
    return matchingPane || panes[0];
  };
  PlotAreaBase2.prototype.findPointPane = function findPointPane(point) {
    var panes = this.panes;
    var matchingPane;
    for (var i36 = 0; i36 < panes.length; i36++) {
      if (panes[i36].box.containsPoint(point)) {
        matchingPane = panes[i36];
        break;
      }
    }
    return matchingPane;
  };
  PlotAreaBase2.prototype.appendAxis = function appendAxis(axis) {
    var pane = this.findPane(axis.options.pane);
    pane.appendAxis(axis);
    this.axes.push(axis);
    axis.plotArea = this;
  };
  PlotAreaBase2.prototype.removeAxis = function removeAxis(axisToRemove) {
    var this$1 = this;
    var filteredAxes = [];
    for (var i36 = 0; i36 < this.axes.length; i36++) {
      var axis = this$1.axes[i36];
      if (axisToRemove !== axis) {
        filteredAxes.push(axis);
      } else {
        axis.destroy();
      }
    }
    this.axes = filteredAxes;
  };
  PlotAreaBase2.prototype.appendChart = function appendChart(chart, pane) {
    this.charts.push(chart);
    if (pane) {
      pane.appendChart(chart);
    } else {
      this.append(chart);
    }
  };
  PlotAreaBase2.prototype.removeChart = function removeChart(chartToRemove) {
    var this$1 = this;
    var filteredCharts = [];
    for (var i36 = 0; i36 < this.charts.length; i36++) {
      var chart = this$1.charts[i36];
      if (chart !== chartToRemove) {
        filteredCharts.push(chart);
      } else {
        chart.destroy();
      }
    }
    this.charts = filteredCharts;
  };
  PlotAreaBase2.prototype.addToLegend = function addToLegend(series) {
    var count = series.length;
    var legend2 = this.options.legend;
    var labels = legend2.labels || {};
    var inactiveItems = legend2.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    var data = [];
    for (var i36 = 0; i36 < count; i36++) {
      var currentSeries = series[i36];
      var seriesVisible = currentSeries.visible !== false;
      if (currentSeries.visibleInLegend === false) {
        continue;
      }
      var text = currentSeries.name;
      var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);
      if (labelTemplate) {
        text = labelTemplate({
          text: hasValue(text) ? text : "",
          series: currentSeries
        });
      }
      var defaults = currentSeries._defaults;
      var color = currentSeries.color;
      if (isFunction(color) && defaults) {
        color = defaults.color;
      }
      var itemLabelOptions = void 0, markerColor = void 0;
      if (seriesVisible) {
        itemLabelOptions = {};
        markerColor = color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = inactiveItems.markers.color;
      }
      if (hasValue(text) && text !== "") {
        data.push({
          text,
          labels: itemLabelOptions,
          markerColor,
          series: currentSeries,
          active: seriesVisible
        });
      }
    }
    append(legend2.data, data);
  };
  PlotAreaBase2.prototype.groupAxes = function groupAxes(panes) {
    var xAxes = [];
    var yAxes = [];
    for (var paneIx = 0; paneIx < panes.length; paneIx++) {
      var paneAxes = panes[paneIx].axes;
      for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {
        var axis = paneAxes[axisIx];
        if (axis.options.vertical) {
          yAxes.push(axis);
        } else {
          xAxes.push(axis);
        }
      }
    }
    return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };
  };
  PlotAreaBase2.prototype.groupSeriesByPane = function groupSeriesByPane() {
    var this$1 = this;
    var series = this.series;
    var seriesByPane = {};
    for (var i36 = 0; i36 < series.length; i36++) {
      var currentSeries = series[i36];
      var pane = this$1.seriesPaneName(currentSeries);
      if (seriesByPane[pane]) {
        seriesByPane[pane].push(currentSeries);
      } else {
        seriesByPane[pane] = [currentSeries];
      }
    }
    return seriesByPane;
  };
  PlotAreaBase2.prototype.filterVisibleSeries = function filterVisibleSeries(series) {
    var result = [];
    for (var i36 = 0; i36 < series.length; i36++) {
      var currentSeries = series[i36];
      if (currentSeries.visible !== false) {
        result.push(currentSeries);
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.reflow = function reflow(targetBox) {
    var options = this.options.plotArea;
    var panes = this.panes;
    var margin = getSpacing(options.margin);
    this.box = targetBox.clone().unpad(margin);
    this.reflowPanes();
    this.detachLabels();
    this.reflowAxes(panes);
    this.reflowCharts(panes);
  };
  PlotAreaBase2.prototype.redraw = function redraw(panes) {
    var this$1 = this;
    var panesArray = [].concat(panes);
    this.initSeries();
    var root = this.getRoot();
    if (root) {
      root.cleanGradients();
    }
    for (var i36 = 0; i36 < panesArray.length; i36++) {
      this$1.removeCrosshairs(panesArray[i36]);
      panesArray[i36].empty();
    }
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.render(panesArray);
    this.detachLabels();
    this.reflowAxes(this.panes);
    this.reflowCharts(panesArray);
    this.createCrosshairs(panesArray);
    for (var i$1 = 0; i$1 < panesArray.length; i$1++) {
      panesArray[i$1].refresh();
    }
  };
  PlotAreaBase2.prototype.axisCrossingValues = function axisCrossingValues(axis, crossingAxes) {
    var options = axis.options;
    var crossingValues = [].concat(
      options.axisCrossingValues || options.axisCrossingValue
    );
    var valuesToAdd = crossingAxes.length - crossingValues.length;
    var defaultValue = crossingValues[0] || 0;
    for (var i36 = 0; i36 < valuesToAdd; i36++) {
      crossingValues.push(defaultValue);
    }
    return crossingValues;
  };
  PlotAreaBase2.prototype.alignAxisTo = function alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
    var slot = axis.getSlot(crossingValue, crossingValue, true);
    var slotEdge = axis.options.reverse ? 2 : 1;
    var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
    var targetEdge = targetAxis.options.reverse ? 2 : 1;
    var axisBox = axis.box.translate(
      targetSlot[X + targetEdge] - slot[X + slotEdge],
      targetSlot[Y + targetEdge] - slot[Y + slotEdge]
    );
    if (axis.pane !== targetAxis.pane) {
      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
    }
    axis.reflow(axisBox);
  };
  PlotAreaBase2.prototype.alignAxes = function alignAxes(xAxes, yAxes) {
    var this$1 = this;
    var xAnchor = xAxes[0];
    var yAnchor = yAxes[0];
    var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
    var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
    var leftAnchors = {};
    var rightAnchors = {};
    var topAnchors = {};
    var bottomAnchors = {};
    for (var i36 = 0; i36 < yAxes.length; i36++) {
      var axis = yAxes[i36];
      var pane = axis.pane;
      var paneId = pane.id;
      var visible = axis.options.visible !== false;
      var anchor = paneAnchor(xAxes, pane) || xAnchor;
      var anchorCrossings = xAnchorCrossings;
      if (anchor !== xAnchor) {
        anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);
      }
      this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i36], anchorCrossings[i36]);
      if (axis.options._overlap) {
        continue;
      }
      if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {
        if (leftAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0)
          );
        }
        if (visible) {
          leftAnchors[paneId] = axis;
        }
      }
      if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i36], anchorCrossings[i36]);
        if (rightAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0)
          );
        }
        if (visible) {
          rightAnchors[paneId] = axis;
        }
      }
      var paneYAnchor = paneAnchor(yAxes, pane) || yAnchor;
      if (paneYAnchor !== axis) {
        axis.alignTo(paneYAnchor);
        axis.reflow(axis.box);
      }
    }
    for (var i$1 = 0; i$1 < xAxes.length; i$1++) {
      var axis$1 = xAxes[i$1];
      var pane$1 = axis$1.pane;
      var paneId$1 = pane$1.id;
      var visible$1 = axis$1.options.visible !== false;
      var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;
      var anchorCrossings$1 = yAnchorCrossings;
      if (anchor$1 !== yAnchor) {
        anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);
      }
      this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
      if (axis$1.options._overlap) {
        continue;
      }
      if (round(axis$1.lineBox().y1) === round(anchor$1.lineBox().y1)) {
        if (!axis$1._mirrored) {
          axis$1.options.labels.mirror = !axis$1.options.labels.mirror;
          axis$1._mirrored = true;
        }
        this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
        if (topAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(topAnchors[paneId$1].box, TOP).translate(0, -axis$1.options.margin)
          );
        }
        if (visible$1) {
          topAnchors[paneId$1] = axis$1;
        }
      }
      if (round(axis$1.lineBox().y2, COORD_PRECISION) === round(anchor$1.lineBox().y2, COORD_PRECISION)) {
        if (bottomAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(bottomAnchors[paneId$1].box, BOTTOM).translate(0, axis$1.options.margin)
          );
        }
        if (visible$1) {
          bottomAnchors[paneId$1] = axis$1;
        }
      }
      if (i$1 !== 0) {
        axis$1.alignTo(xAnchor);
        axis$1.reflow(axis$1.box);
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisWidth = function shrinkAxisWidth(panes) {
    var axes = this.groupAxes(panes).any;
    var axisBox = axisGroupBox(axes);
    var overflowX = 0;
    for (var i36 = 0; i36 < panes.length; i36++) {
      var currentPane = panes[i36];
      if (currentPane.axes.length > 0) {
        overflowX = Math.max(
          overflowX,
          axisBox.width() - currentPane.contentBox.width()
        );
      }
    }
    if (overflowX !== 0) {
      for (var i$1 = 0; i$1 < axes.length; i$1++) {
        var currentAxis = axes[i$1];
        if (!currentAxis.options.vertical) {
          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
        }
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisHeight = function shrinkAxisHeight(panes) {
    var shrinked;
    for (var i36 = 0; i36 < panes.length; i36++) {
      var currentPane = panes[i36];
      var axes = currentPane.axes;
      var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());
      if (overflowY !== 0) {
        for (var j2 = 0; j2 < axes.length; j2++) {
          var currentAxis = axes[j2];
          if (currentAxis.options.vertical) {
            currentAxis.reflow(
              currentAxis.box.shrink(0, overflowY)
            );
          }
        }
        shrinked = true;
      }
    }
    return shrinked;
  };
  PlotAreaBase2.prototype.fitAxes = function fitAxes(panes) {
    var axes = this.groupAxes(panes).any;
    var offsetX = 0;
    for (var i36 = 0; i36 < panes.length; i36++) {
      var currentPane = panes[i36];
      var paneAxes = currentPane.axes;
      var paneBox = currentPane.contentBox;
      if (paneAxes.length > 0) {
        var axisBox = axisGroupBox(paneAxes);
        var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);
        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);
        for (var j2 = 0; j2 < paneAxes.length; j2++) {
          var currentAxis = paneAxes[j2];
          currentAxis.reflow(
            currentAxis.box.translate(0, offsetY)
          );
        }
      }
    }
    for (var i$1 = 0; i$1 < axes.length; i$1++) {
      var currentAxis$1 = axes[i$1];
      currentAxis$1.reflow(
        currentAxis$1.box.translate(offsetX, 0)
      );
    }
  };
  PlotAreaBase2.prototype.reflowAxes = function reflowAxes(panes) {
    var this$1 = this;
    var axes = this.groupAxes(panes);
    for (var i36 = 0; i36 < panes.length; i36++) {
      this$1.reflowPaneAxes(panes[i36]);
    }
    if (axes.x.length > 0 && axes.y.length > 0) {
      this.alignAxes(axes.x, axes.y);
      this.shrinkAxisWidth(panes);
      this.autoRotateAxisLabels(axes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisWidth(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.shrinkAxisHeight(panes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisHeight(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.fitAxes(panes);
    }
  };
  PlotAreaBase2.prototype.autoRotateAxisLabels = function autoRotateAxisLabels(groupedAxes) {
    var this$1 = this;
    var ref2 = this;
    var panes = ref2.panes;
    var axes = allPaneAxes(panes);
    var rotated;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      if (axis.autoRotateLabels()) {
        rotated = true;
      }
    }
    if (rotated) {
      for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {
        this$1.reflowPaneAxes(panes[idx$1]);
      }
      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
        this.alignAxes(groupedAxes.x, groupedAxes.y);
        this.shrinkAxisWidth(panes);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPaneAxes = function reflowPaneAxes(pane) {
    var axes = pane.axes;
    var length = axes.length;
    if (length > 0) {
      for (var i36 = 0; i36 < length; i36++) {
        axes[i36].reflow(pane.contentBox);
      }
    }
  };
  PlotAreaBase2.prototype.reflowCharts = function reflowCharts(panes) {
    var charts = this.charts;
    var count = charts.length;
    var box = this.box;
    for (var i36 = 0; i36 < count; i36++) {
      var chartPane = charts[i36].pane;
      if (!chartPane || inArray(chartPane, panes)) {
        charts[i36].reflow(box);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPanes = function reflowPanes() {
    var ref2 = this;
    var box = ref2.box;
    var panes = ref2.panes;
    var panesLength = panes.length;
    var remainingHeight = box.height();
    var autoHeightPanes = 0;
    var top = box.y1;
    for (var i36 = 0; i36 < panesLength; i36++) {
      var currentPane = panes[i36];
      var height = currentPane.options.height;
      currentPane.options.width = box.width();
      if (!currentPane.options.height) {
        autoHeightPanes++;
      } else {
        if (height.indexOf && height.indexOf("%")) {
          var percents = parseInt(height, 10) / 100;
          currentPane.options.height = percents * box.height();
        }
        currentPane.reflow(box.clone());
        remainingHeight -= currentPane.options.height;
      }
    }
    for (var i$1 = 0; i$1 < panesLength; i$1++) {
      var currentPane$1 = panes[i$1];
      if (!currentPane$1.options.height) {
        currentPane$1.options.height = remainingHeight / autoHeightPanes;
      }
    }
    for (var i$2 = 0; i$2 < panesLength; i$2++) {
      var currentPane$2 = panes[i$2];
      var paneBox = box.clone().move(box.x1, top);
      currentPane$2.reflow(paneBox);
      top += currentPane$2.options.height;
    }
  };
  PlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    var axes = this.axes;
    var axesCount = axes.length;
    var box;
    for (var i36 = 0; i36 < axesCount; i36++) {
      var axisA = axes[i36];
      for (var j2 = 0; j2 < axesCount; j2++) {
        var axisB = axes[j2];
        if (axisA.options.vertical !== axisB.options.vertical) {
          var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());
          if (!box) {
            box = lineBox;
          } else {
            box = box.wrap(lineBox);
          }
        }
      }
    }
    return box || this.box;
  };
  PlotAreaBase2.prototype.chartsBoxes = function chartsBoxes() {
    var panes = this.panes;
    var boxes = [];
    for (var idx = 0; idx < panes.length; idx++) {
      boxes.push(panes[idx].chartsBox());
    }
    return boxes;
  };
  PlotAreaBase2.prototype.addBackgroundPaths = function addBackgroundPaths(multipath) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      multipath.paths.push(drawing_exports.Path.fromRect(boxes[idx].toRect()));
    }
  };
  PlotAreaBase2.prototype.backgroundContainsPoint = function backgroundContainsPoint(point) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      if (boxes[idx].containsPoint(point)) {
        return true;
      }
    }
  };
  PlotAreaBase2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options = this.options.plotArea;
    var opacity = options.opacity;
    var background = options.background;
    var border = options.border;
    if (border === void 0) border = {};
    if (isTransparent(background)) {
      background = WHITE;
      opacity = 0;
    }
    var bg = this._bgVisual = new drawing_exports.MultiPath({
      fill: {
        color: background,
        opacity
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      zIndex: -1
    });
    this.addBackgroundPaths(bg);
    this.appendVisual(bg);
  };
  PlotAreaBase2.prototype.pointsByCategoryIndex = function pointsByCategoryIndex(categoryIndex) {
    var charts = this.charts;
    var result = [];
    if (categoryIndex !== null) {
      for (var i36 = 0; i36 < charts.length; i36++) {
        var chart = charts[i36];
        if (chart.pane.options.name === "_navigator") {
          continue;
        }
        var points = charts[i36].categoryPoints[categoryIndex];
        if (points && points.length) {
          for (var j2 = 0; j2 < points.length; j2++) {
            var point = points[j2];
            if (point && defined(point.value) && point.value !== null) {
              result.push(point);
            }
          }
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.pointsBySeriesIndex = function pointsBySeriesIndex(seriesIndex) {
    return this.filterPoints(function(point) {
      return point.series.index === seriesIndex;
    });
  };
  PlotAreaBase2.prototype.pointsByPointIndex = function pointsByPointIndex(pointIndex) {
    return this.filterPoints(function(point) {
      return point.getIndex() === pointIndex;
    });
  };
  PlotAreaBase2.prototype.pointsBySeriesName = function pointsBySeriesName(name2) {
    return this.filterPoints(function(point) {
      return point.series.name === name2;
    });
  };
  PlotAreaBase2.prototype.filterPoints = function filterPoints(callback) {
    var charts = this.charts;
    var result = [];
    for (var i36 = 0; i36 < charts.length; i36++) {
      var chart = charts[i36];
      var points = chart.points;
      for (var j2 = 0; j2 < points.length; j2++) {
        var point = points[j2];
        if (point && point.visible !== false && callback(point)) {
          result.push(point);
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.findPoint = function findPoint(callback) {
    var charts = this.charts;
    for (var i36 = 0; i36 < charts.length; i36++) {
      var chart = charts[i36];
      var points = chart.points;
      for (var j2 = 0; j2 < points.length; j2++) {
        var point = points[j2];
        if (point && point.visible !== false && callback(point)) {
          return point;
        }
      }
    }
  };
  PlotAreaBase2.prototype.paneByPoint = function paneByPoint(point) {
    var panes = this.panes;
    for (var i36 = 0; i36 < panes.length; i36++) {
      var pane = panes[i36];
      if (pane.box.containsPoint(point)) {
        return pane;
      }
    }
  };
  PlotAreaBase2.prototype.detachLabels = function detachLabels() {
    var axes = this.groupAxes(this.panes);
    var xAxes = axes.x;
    var yAxes = axes.y;
    this.detachAxisGroupLabels(yAxes, xAxes);
    this.detachAxisGroupLabels(xAxes, yAxes);
  };
  PlotAreaBase2.prototype.detachAxisGroupLabels = function detachAxisGroupLabels(axes, crossingAxes) {
    var this$1 = this;
    var labelAxisCount = 0;
    for (var i36 = 0; i36 < axes.length; i36++) {
      var axis = axes[i36];
      var pane = axis.pane;
      var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];
      var axisIndex = i36 + labelAxisCount;
      var labelAxis = this$1.createLabelAxis(axis, axisIndex, anchor);
      if (labelAxis) {
        labelAxisCount++;
        var pos = pane.axes.indexOf(axis) + labelAxisCount;
        pane.appendAxisAt(labelAxis, pos);
      }
    }
  };
  PlotAreaBase2.prototype.createLabelAxis = function createLabelAxis(axis, axisIndex, anchor) {
    var labelOptions = axis.options.labels;
    var position = labelOptions.position;
    var onAxis = position !== END && position !== START;
    var visible = labelOptions.visible;
    if (onAxis || visible === false) {
      return null;
    }
    var allAxes = this.groupAxes(this.panes);
    var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;
    var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);
    var end = position === END;
    var range = anchor.range();
    var edge = end ? range.max : range.min;
    var crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);
    if (crossingValue - edge === 0) {
      return null;
    }
    anchorCrossings.splice(axisIndex + 1, 0, edge);
    anchor.options.axisCrossingValues = anchorCrossings;
    var labelAxis = axis.clone();
    axis.clear();
    labelAxis.options.name = void 0;
    labelAxis.options.line.visible = false;
    labelAxis.options.crosshair = void 0;
    labelAxis.options.notes = void 0;
    labelAxis.options.plotBands = void 0;
    return labelAxis;
  };
  PlotAreaBase2.prototype.isTrendline = function isTrendline(series) {
    return series && inArray(series.type, TRENDLINE_SERIES);
  };
  PlotAreaBase2.prototype.trendlineFactory = function trendlineFactory2() {
  };
  PlotAreaBase2.prototype.createTrendlineSeries = function createTrendlineSeries() {
    var this$1 = this;
    var modifiedSeries = [];
    this.series = this.series.map(function(series) {
      if (!this$1.isTrendline(series)) {
        return series;
      }
      var forSeries = this$1.seriesByName(series.for);
      if (!forSeries) {
        throw new Error('Invalid Configuration: Unable to locate linked series "' + series.for + '" for trendline "' + series.name + '".');
      }
      var valueFields = series_binder_default.current.valueFields(forSeries);
      var field = last(valueFields);
      var trendlineSeries = this$1.trendlineFactory(Object.assign({}, { field }, series), forSeries);
      if (trendlineSeries) {
        if (forSeries.visible === false) {
          trendlineSeries.visible = false;
        }
        if (trendlineSeries.color === INHERIT) {
          trendlineSeries.color = forSeries.color;
        }
        modifiedSeries.push(trendlineSeries);
      }
      return trendlineSeries;
    }).filter(function(series) {
      return series !== null;
    });
    return modifiedSeries;
  };
  PlotAreaBase2.prototype.seriesByName = function seriesByName(name2) {
    return this.series.find(function(series) {
      return series.name === name2;
    });
  };
  PlotAreaBase2.prototype.getFirstPoint = function getFirstPoint() {
    var this$1 = this;
    for (var i36 = 0; i36 < this.series.length; i36++) {
      var points = this$1.pointsBySeriesIndex(i36);
      var point = points.find(visiblePoint);
      if (point) {
        return point;
      }
    }
  };
  PlotAreaBase2.prototype.getPointBelow = function getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  };
  PlotAreaBase2.prototype.getPointAbove = function getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  };
  PlotAreaBase2.prototype.getPointToTheRight = function getPointToTheRight(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, 1);
  };
  PlotAreaBase2.prototype.getPointToTheLeft = function getPointToTheLeft(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, -1);
  };
  PlotAreaBase2.prototype._getNextPoint = function _getNextPoint(point, getPointsFunc, increment) {
    var this$1 = this;
    var points = getPointsFunc.call(this, point).filter(visiblePoint);
    var pointIndex = points.indexOf(point);
    var nextIndex = pointIndex + increment;
    var loopPoints = function(direction) {
      var result;
      var offset = 0;
      do {
        offset += direction;
        result = getPointsFunc.call(this$1, point, offset).filter(visiblePoint);
      } while (result.length === 0);
      return result;
    };
    if (nextIndex < 0) {
      points = loopPoints(-1);
      return points.at(-1);
    } else if (nextIndex >= points.length) {
      points = loopPoints(1);
      return points.at(0);
    }
    return points[nextIndex];
  };
  PlotAreaBase2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return this.pointsByPointIndex(basePoint.getIndex());
  };
  PlotAreaBase2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset) {
    if (offset === void 0) offset = 0;
    var index = cycleIndex(basePoint.series.index + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  };
  return PlotAreaBase2;
}(chart_element_default);
function isSingleAxis(axis) {
  return !axis.pane.axes.some(
    function(a38) {
      return a38.options.vertical === axis.options.vertical && a38 !== axis && a38.options.visible !== false;
    }
  );
}
function axisGroupBox(axes) {
  var length = axes.length;
  var box;
  for (var i36 = 0; i36 < length; i36++) {
    var axis = axes[i36];
    var visible = axis.options.visible !== false;
    if (visible || isSingleAxis(axis)) {
      var axisBox = visible ? axis.contentBox() : axis.lineBox();
      if (!box) {
        box = axisBox.clone();
      } else {
        box.wrap(axisBox);
      }
    }
  }
  return box || new box_default();
}
function paneAnchor(axes, pane) {
  for (var i36 = 0; i36 < axes.length; i36++) {
    var anchor = axes[i36];
    if (anchor && anchor.pane === pane) {
      return anchor;
    }
  }
}
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}
var allPaneAxes = function(panes) {
  return panes.reduce(function(acc, pane) {
    return acc.concat(pane.axes);
  }, []);
};
setDefaultOptions(PlotAreaBase, {
  series: [],
  plotArea: {
    margin: {}
  },
  background: "",
  border: {
    color: BLACK,
    width: 0
  },
  paneDefaults: {
    title: {}
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "#919191"
      },
      markers: {
        color: "#919191"
      }
    }
  }
});
var plotarea_base_default = PlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/plotarea-events-mixin.js
var PlotAreaEventsMixin = {
  hover: function(chart, e39) {
    this._dispatchEvent(chart, e39, PLOT_AREA_HOVER);
  },
  click: function(chart, e39) {
    this._dispatchEvent(chart, e39, PLOT_AREA_CLICK);
  }
};
var plotarea_events_mixin_default = PlotAreaEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/series-aggregator.js
var SeriesAggregator = function(Class) {
  function SeriesAggregator2(series, binder, defaultAggregates) {
    Class.call(this);
    var canonicalFields = binder.canonicalFields(series);
    var valueFields = binder.valueFields(series);
    var sourceFields = binder.sourceFields(series, canonicalFields);
    var seriesFields = this._seriesFields = [];
    var defaults = defaultAggregates.query(series.type);
    var rootAggregate = series.aggregate || defaults;
    this._series = series;
    this._binder = binder;
    for (var i36 = 0; i36 < canonicalFields.length; i36++) {
      var field = canonicalFields[i36];
      var fieldAggregate = void 0;
      if (isObject(rootAggregate)) {
        fieldAggregate = rootAggregate[field];
      } else if (i36 === 0 || inArray(field, valueFields)) {
        fieldAggregate = rootAggregate;
      } else {
        break;
      }
      if (fieldAggregate) {
        seriesFields.push({
          canonicalName: field,
          name: sourceFields[i36],
          transform: isFunction(fieldAggregate) ? fieldAggregate : aggregates_default[fieldAggregate]
        });
      }
    }
  }
  if (Class) SeriesAggregator2.__proto__ = Class;
  SeriesAggregator2.prototype = Object.create(Class && Class.prototype);
  SeriesAggregator2.prototype.constructor = SeriesAggregator2;
  SeriesAggregator2.prototype.aggregatePoints = function aggregatePoints(srcPoints, group) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2._series;
    var seriesFields = ref2._seriesFields;
    var data = this._bindPoints(srcPoints || []);
    var firstDataItem = data.dataItems[0];
    var result = {};
    if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {
      var fn = function() {
      };
      fn.prototype = firstDataItem;
      result = new fn();
    }
    for (var i36 = 0; i36 < seriesFields.length; i36++) {
      var field = seriesFields[i36];
      var srcValues = this$1._bindField(data.values, field.canonicalName);
      var value2 = field.transform(srcValues, series, data.dataItems, group);
      if (value2 !== null && isObject(value2) && !defined(value2.length) && !(value2 instanceof Date)) {
        result = value2;
        break;
      } else {
        if (defined(value2)) {
          setValue(field.name, result, value2);
        }
      }
    }
    return result;
  };
  SeriesAggregator2.prototype._bindPoints = function _bindPoints(points) {
    var ref2 = this;
    var binder = ref2._binder;
    var series = ref2._series;
    var values5 = [];
    var dataItems = [];
    for (var i36 = 0; i36 < points.length; i36++) {
      var pointIx = points[i36];
      values5.push(binder.bindPoint(series, pointIx));
      dataItems.push(series.data[pointIx]);
    }
    return {
      values: values5,
      dataItems
    };
  };
  SeriesAggregator2.prototype._bindField = function _bindField(data, field) {
    var values5 = [];
    var count = data.length;
    for (var i36 = 0; i36 < count; i36++) {
      var item = data[i36];
      var valueFields = item.valueFields;
      var value2 = void 0;
      if (defined(valueFields[field])) {
        value2 = valueFields[field];
      } else {
        value2 = item.fields[field];
      }
      values5.push(value2);
    }
    return values5;
  };
  return SeriesAggregator2;
}(class_default);
function setValue(fieldName, target, value2) {
  var parentObj = target;
  var field = fieldName;
  if (fieldName.indexOf(".") > -1) {
    var parts = fieldName.split(".");
    while (parts.length > 1) {
      field = parts.shift();
      if (!defined(parentObj[field])) {
        parentObj[field] = {};
      }
      parentObj = parentObj[field];
    }
    field = parts.shift();
  }
  parentObj[field] = value2;
}
var series_aggregator_default = SeriesAggregator;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/default-aggregates.js
var DefaultAggregates = function(Class) {
  function DefaultAggregates2() {
    Class.call(this);
    this._defaults = {};
  }
  if (Class) DefaultAggregates2.__proto__ = Class;
  DefaultAggregates2.prototype = Object.create(Class && Class.prototype);
  DefaultAggregates2.prototype.constructor = DefaultAggregates2;
  DefaultAggregates2.prototype.register = function register4(seriesTypes, aggregates) {
    var this$1 = this;
    for (var i36 = 0; i36 < seriesTypes.length; i36++) {
      this$1._defaults[seriesTypes[i36]] = aggregates;
    }
  };
  DefaultAggregates2.prototype.query = function query(seriesType) {
    return this._defaults[seriesType];
  };
  return DefaultAggregates2;
}(class_default);
DefaultAggregates.current = new DefaultAggregates();
var default_aggregates_default = DefaultAggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar.js
var RangeBar = function(Bar2) {
  function RangeBar2() {
    Bar2.apply(this, arguments);
  }
  if (Bar2) RangeBar2.__proto__ = Bar2;
  RangeBar2.prototype = Object.create(Bar2 && Bar2.prototype);
  RangeBar2.prototype.constructor = RangeBar2;
  RangeBar2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var fromOptions = deepExtend({}, labels, labels.from);
    var toOptions = deepExtend({}, labels, labels.to);
    if (fromOptions.visible) {
      this.labelFrom = this.createLabelElement(fromOptions);
      this.append(this.labelFrom);
    }
    if (toOptions.visible) {
      this.labelTo = this.createLabelElement(toOptions);
      this.append(this.labelTo);
    }
  };
  RangeBar2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var ref2 = this;
    var labelFrom = ref2.labelFrom;
    var labelTo = ref2.labelTo;
    var value2 = ref2.value;
    this.box = targetBox;
    if (labelFrom) {
      labelFrom.options.aboveAxis = value2.from > value2.to;
      labelFrom.reflow(targetBox);
    }
    if (labelTo) {
      labelTo.options.aboveAxis = value2.to > value2.from;
      labelTo.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
  };
  return RangeBar2;
}(bar_default);
RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {
  labels: {
    format: "{0} - {1}"
  },
  tooltip: {
    format: "{1}"
  }
});
var range_bar_default = RangeBar;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar-chart.js
var RangeBarChart = function(BarChart2) {
  function RangeBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2) RangeBarChart2.__proto__ = BarChart2;
  RangeBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RangeBarChart2.prototype.constructor = RangeBarChart2;
  RangeBarChart2.prototype.pointType = function pointType() {
    return range_bar_default;
  };
  RangeBarChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields;
  };
  RangeBarChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    if (point.value.from === null && point.value.to === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value.from, point.value.to);
  };
  RangeBarChart2.prototype.plotRange = function plotRange(point) {
    if (!point) {
      return 0;
    }
    return [point.value.from, point.value.to];
  };
  RangeBarChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var from = value2.from;
    var to = value2.to;
    var axisRange = this.valueAxisRanges[axisName];
    if (value2 !== null && isNumber(from) && isNumber(to)) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, from);
      axisRange.max = Math.max(axisRange.max, from);
      axisRange.min = Math.min(axisRange.min, to);
      axisRange.max = Math.max(axisRange.max, to);
    }
  };
  RangeBarChart2.prototype.aboveAxis = function aboveAxis(point) {
    var value2 = point.value;
    return value2.from < value2.to;
  };
  return RangeBarChart2;
}(bar_chart_default);
RangeBarChart.prototype.plotLimits = categorical_chart_default.prototype.plotLimits;
var range_bar_chart_default = RangeBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-line-point.js
var RangeLinePoint = function(LinePoint2) {
  function RangeLinePoint2() {
    LinePoint2.apply(this, arguments);
  }
  if (LinePoint2) RangeLinePoint2.__proto__ = LinePoint2;
  RangeLinePoint2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  RangeLinePoint2.prototype.constructor = RangeLinePoint2;
  RangeLinePoint2.prototype.aliasFor = function aliasFor() {
    return this.parent;
  };
  return RangeLinePoint2;
}(line_point_default);
var range_line_point_default = RangeLinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-point.js
var AUTO2 = "auto";
var DEFAULT_FROM_FORMAT = "{0}";
var DEFAULT_TO_FORMAT = "{1}";
var RangeAreaPoint = function(ChartElement2) {
  function RangeAreaPoint2(value2, options) {
    ChartElement2.call(this);
    this.value = value2;
    this.options = options;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
    this.initLabelsFormat();
  }
  if (ChartElement2) RangeAreaPoint2.__proto__ = ChartElement2;
  RangeAreaPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RangeAreaPoint2.prototype.constructor = RangeAreaPoint2;
  RangeAreaPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    var ref2 = this.options;
    var markers = ref2.markers;
    var labels = ref2.labels;
    var value2 = this.value;
    var fromPoint = this.fromPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.from,
      markers: markers.from
    }));
    var toPoint = this.toPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.to,
      markers: markers.to
    }));
    this.copyFields(fromPoint);
    this.copyFields(toPoint);
    this.append(fromPoint);
    this.append(toPoint);
  };
  RangeAreaPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var fromBox = targetBox.from;
    var toBox = targetBox.to;
    this.positionLabels(fromBox, toBox);
    this.fromPoint.reflow(fromBox);
    this.toPoint.reflow(toBox);
    this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());
  };
  RangeAreaPoint2.prototype.createHighlight = function createHighlight() {
    var group = new drawing_exports.Group();
    group.append(this.fromPoint.createHighlight());
    group.append(this.toPoint.createHighlight());
    return group;
  };
  RangeAreaPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.visual;
  };
  RangeAreaPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      from: this.fromPoint.highlightVisualArgs(),
      to: this.toPoint.highlightVisualArgs()
    };
  };
  RangeAreaPoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var group = new drawing_exports.Group();
    group.append(this.fromPoint.createFocusHighlight());
    group.append(this.toPoint.createFocusHighlight());
    return group;
  };
  RangeAreaPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(this.box);
    if (showTooltip) {
      var box = this.box;
      var center = box.center();
      var horizontalAlign = LEFT;
      var x5, y, verticalAlign;
      if (this.options.vertical) {
        x5 = center.x;
        y = box.y1 - TOOLTIP_OFFSET;
        verticalAlign = BOTTOM;
      } else {
        x5 = box.x2 + TOOLTIP_OFFSET;
        y = center.y;
        verticalAlign = CENTER;
      }
      return {
        point: new point_default(x5, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  RangeAreaPoint2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  RangeAreaPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  RangeAreaPoint2.prototype.unclipElements = function unclipElements() {
    this.fromPoint.unclipElements();
    this.toPoint.unclipElements();
  };
  RangeAreaPoint2.prototype.initLabelsFormat = function initLabelsFormat() {
    var labels = this.options.labels;
    if (!labels.format) {
      if (!labels.from || !labels.from.format) {
        labels.from = Object.assign({}, labels.from, {
          format: DEFAULT_FROM_FORMAT
        });
      }
      if (!labels.to || !labels.to.format) {
        labels.to = Object.assign({}, labels.to, {
          format: DEFAULT_TO_FORMAT
        });
      }
    }
  };
  RangeAreaPoint2.prototype.positionLabels = function positionLabels(fromBox, toBox) {
    var ref2 = this.options;
    var labels = ref2.labels;
    var vertical = ref2.vertical;
    if (labels.position === AUTO2) {
      var fromLabelPosition, toLabelPosition;
      if (vertical) {
        if (toBox.y1 <= fromBox.y1) {
          toLabelPosition = ABOVE;
          fromLabelPosition = BELOW;
        } else {
          toLabelPosition = BELOW;
          fromLabelPosition = ABOVE;
        }
      } else {
        if (toBox.x1 <= fromBox.x1) {
          toLabelPosition = LEFT;
          fromLabelPosition = RIGHT;
        } else {
          toLabelPosition = RIGHT;
          fromLabelPosition = LEFT;
        }
      }
      if (!labels.from || !labels.from.position) {
        this.fromPoint.options.labels.position = fromLabelPosition;
      }
      if (!labels.to || !labels.to.position) {
        this.toPoint.options.labels.position = toLabelPosition;
      }
    }
  };
  RangeAreaPoint2.prototype.copyFields = function copyFields(point) {
    point.dataItem = this.dataItem;
    point.category = this.category;
    point.series = this.series;
    point.color = this.color;
    point.owner = this.owner;
  };
  RangeAreaPoint2.prototype.focusVisual = function focusVisual2() {
    this.fromPoint.focusVisual();
  };
  RangeAreaPoint2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    this.toPoint.clearFocusFromVisual();
  };
  RangeAreaPoint2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return RangeAreaPoint2;
}(chart_element_default);
deepExtend(RangeAreaPoint.prototype, point_events_mixin_default);
deepExtend(RangeAreaPoint.prototype, note_mixin_default);
RangeAreaPoint.prototype.defaults = {
  markers: {
    visible: false,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    },
    position: AUTO2
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: WHITE,
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  tooltip: {
    format: "{0} - {1}"
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var range_area_point_default = RangeAreaPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-segment.js
var RangeAreaSegment = function(AreaSegment2) {
  function RangeAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) RangeAreaSegment2.__proto__ = AreaSegment2;
  RangeAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RangeAreaSegment2.prototype.constructor = RangeAreaSegment2;
  RangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));
  };
  RangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));
    }
    return fromSegments;
  };
  RangeAreaSegment2.prototype.createStroke = function createStroke(style) {
    var toPath = new drawing_exports.Path(style);
    var fromPath = new drawing_exports.Path(style);
    toPath.segments.push.apply(toPath.segments, this.strokeSegments());
    fromPath.segments.push.apply(fromPath.segments, this.stackSegments());
    this.visual.append(toPath);
    this.visual.append(fromPath);
  };
  RangeAreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return true;
  };
  RangeAreaSegment2.prototype.fromPoints = function fromPoints() {
    return this.linePoints.map(function(point) {
      return point.fromPoint;
    });
  };
  RangeAreaSegment2.prototype.toPoints = function toPoints() {
    return this.linePoints.map(function(point) {
      return point.toPoint;
    });
  };
  return RangeAreaSegment2;
}(area_segment_default);
var range_area_segment_default = RangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/spline-range-area-segment.js
var SplineRangeAreaSegment = function(RangeAreaSegment2) {
  function SplineRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2) SplineRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  SplineRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  SplineRangeAreaSegment2.prototype.constructor = SplineRangeAreaSegment2;
  SplineRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.createCurveSegments(this.toPoints());
  };
  SplineRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());
    }
    return fromSegments;
  };
  SplineRangeAreaSegment2.prototype.createCurveSegments = function createCurveSegments(points) {
    var curveProcessor = new curve_processor_default();
    return curveProcessor.process(this.toGeometryPoints(points));
  };
  return SplineRangeAreaSegment2;
}(range_area_segment_default);
var spline_range_area_segment_default = SplineRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/step-range-area-segment.js
var StepRangeAreaSegment = function(RangeAreaSegment2) {
  function StepRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2) StepRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  StepRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  StepRangeAreaSegment2.prototype.constructor = StepRangeAreaSegment2;
  StepRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));
  };
  StepRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));
      fromSegments.reverse();
    }
    return fromSegments;
  };
  return StepRangeAreaSegment2;
}(range_area_segment_default);
deepExtend(StepRangeAreaSegment.prototype, step_line_mixin_default);
var step_range_area_segment_default = StepRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-chart.js
var RangeAreaChart = function(CategoricalChart2) {
  function RangeAreaChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) RangeAreaChart2.__proto__ = CategoricalChart2;
  RangeAreaChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  RangeAreaChart2.prototype.constructor = RangeAreaChart2;
  RangeAreaChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.renderSegments();
  };
  RangeAreaChart2.prototype.pointType = function pointType() {
    return range_area_point_default;
  };
  RangeAreaChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var value2 = data.valueFields;
    if (!hasValue(value2.from) && !hasValue(value2.to)) {
      if (this.seriesMissingValues(series) === ZERO) {
        value2 = {
          from: 0,
          to: 0
        };
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    var color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var point = new range_area_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  RangeAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segmentType;
    if (style === "smooth") {
      segmentType = spline_range_area_segment_default;
    } else if (style === "step") {
      segmentType = step_range_area_segment_default;
    } else {
      segmentType = range_area_segment_default;
    }
    return new segmentType(linePoints, currentSeries, seriesIx);
  };
  RangeAreaChart2.prototype.plotRange = function plotRange(point, startValue) {
    if (!point) {
      return [startValue, startValue];
    }
    return [point.value.from, point.value.to];
  };
  RangeAreaChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);
    var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);
    if (fromSlot && toSlot) {
      return {
        from: fromSlot,
        to: toSlot
      };
    }
  };
  RangeAreaChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var from = valueSlot.from;
    var to = valueSlot.to;
    var fromSlot, toSlot;
    if (this.options.invertAxes) {
      fromSlot = new box_default(from.x1, categorySlot.y1, from.x2, categorySlot.y2);
      toSlot = new box_default(to.x1, categorySlot.y1, to.x2, categorySlot.y2);
    } else {
      fromSlot = new box_default(categorySlot.x1, from.y1, categorySlot.x2, from.y2);
      toSlot = new box_default(categorySlot.x1, to.y1, categorySlot.x2, to.y2);
    }
    return {
      from: fromSlot,
      to: toSlot
    };
  };
  RangeAreaChart2.prototype.addValue = function addValue(data, fields) {
    var valueFields = data.valueFields;
    if (!isNumber(valueFields.from)) {
      valueFields.from = valueFields.to;
    }
    if (!isNumber(valueFields.to)) {
      valueFields.to = valueFields.from;
    }
    CategoricalChart2.prototype.addValue.call(this, data, fields);
  };
  RangeAreaChart2.prototype.updateRange = function updateRange(value2, fields) {
    if (value2 !== null && isNumber(value2.from) && isNumber(value2.to)) {
      var axisName = fields.series.axis;
      var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
      var from = value2.from;
      var to = value2.to;
      axisRange.min = Math.min(axisRange.min, from, to);
      axisRange.max = Math.max(axisRange.max, from, to);
    }
  };
  RangeAreaChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.from, value2.to);
  };
  RangeAreaChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      if (point) {
        result.push((point.fromPoint || {}).marker);
        result.push((point.toPoint || {}).marker);
      }
    }
    return result.concat(this._segments);
  };
  return RangeAreaChart2;
}(categorical_chart_default);
deepExtend(RangeAreaChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var range_area_chart_default = RangeAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-point.js
var OHLCPoint = function(Candlestick2) {
  function OHLCPoint2() {
    Candlestick2.apply(this, arguments);
  }
  if (Candlestick2) OHLCPoint2.__proto__ = Candlestick2;
  OHLCPoint2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  OHLCPoint2.prototype.constructor = OHLCPoint2;
  OHLCPoint2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options);
    var oPoints = [];
    var cPoints = [];
    var lhPoints = [];
    var lhSlot = valueAxis.getSlot(value2.low, value2.high);
    var oSlot = valueAxis.getSlot(value2.open, value2.open);
    var cSlot = valueAxis.getSlot(value2.close, value2.close);
    oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;
    oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;
    var mid = lhSlot.center().x;
    oPoints.push([oSlot.x1, oSlot.y1]);
    oPoints.push([mid, oSlot.y1]);
    cPoints.push([mid, cSlot.y1]);
    cPoints.push([cSlot.x2, cSlot.y1]);
    lhPoints.push([mid, lhSlot.y1]);
    lhPoints.push([mid, lhSlot.y2]);
    this.lines = [
      oPoints,
      cPoints,
      lhPoints
    ];
    this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));
    this.reflowNote();
  };
  OHLCPoint2.prototype.createBody = function createBody() {
  };
  return OHLCPoint2;
}(candlestick_default);
var ohlc_point_default = OHLCPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-chart.js
var OHLCChart = function(CandlestickChart2) {
  function OHLCChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2) OHLCChart2.__proto__ = CandlestickChart2;
  OHLCChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  OHLCChart2.prototype.constructor = OHLCChart2;
  OHLCChart2.prototype.pointType = function pointType() {
    return ohlc_point_default;
  };
  return OHLCChart2;
}(candlestick_chart_default);
var ohlc_chart_default = OHLCChart;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-segment.js
var WaterfallSegment = function(ChartElement2) {
  function WaterfallSegment2(from, to, series) {
    ChartElement2.call(this);
    this.from = from;
    this.to = to;
    this.series = series;
  }
  if (ChartElement2) WaterfallSegment2.__proto__ = ChartElement2;
  WaterfallSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  WaterfallSegment2.prototype.constructor = WaterfallSegment2;
  WaterfallSegment2.prototype.linePoints = function linePoints() {
    var from = this.from;
    var ref2 = this;
    var fromBox = ref2.from.box;
    var toBox = ref2.to.box;
    var points = [];
    if (from.isVertical) {
      var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;
      points.push(
        [fromBox.x1, y],
        [toBox.x2, y]
      );
    } else {
      var x5 = from.aboveAxis ? fromBox.x2 : fromBox.x1;
      points.push(
        [x5, fromBox.y1],
        [x5, toBox.y2]
      );
    }
    return points;
  };
  WaterfallSegment2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var line = this.series.line || {};
    var path = drawing_exports.Path.fromPoints(this.linePoints(), {
      stroke: {
        color: line.color,
        width: line.width,
        opacity: line.opacity,
        dashType: line.dashType
      }
    });
    alignPathToPixel(path);
    this.visual.append(path);
  };
  return WaterfallSegment2;
}(chart_element_default);
setDefaultOptions(WaterfallSegment, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  }
});
var waterfall_segment_default = WaterfallSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-chart.js
var WaterfallChart = function(BarChart2) {
  function WaterfallChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2) WaterfallChart2.__proto__ = BarChart2;
  WaterfallChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  WaterfallChart2.prototype.constructor = WaterfallChart2;
  WaterfallChart2.prototype.render = function render() {
    BarChart2.prototype.render.call(this);
    this.createSegments();
  };
  WaterfallChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var totalCategories = categoriesCount(series);
    var isVertical = !this.options.invertAxes;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var total3 = 0;
      var runningTotal = 0;
      for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {
        var data = series_binder_default.current.bindPoint(currentSeries, categoryIx);
        var value2 = data.valueFields.value;
        var summary = data.fields.summary;
        var from = total3;
        var to = void 0;
        if (summary) {
          if (summary.toLowerCase() === "total") {
            data.valueFields.value = total3;
            from = 0;
            to = total3;
          } else {
            data.valueFields.value = runningTotal;
            to = from - runningTotal;
            runningTotal = 0;
          }
        } else if (isNumber(value2)) {
          runningTotal += value2;
          total3 += value2;
          to = total3;
        }
        callback(data, {
          category: this$1.categoryAxis.categoryAt(categoryIx),
          categoryIx,
          series: currentSeries,
          seriesIx,
          total: total3,
          runningTotal,
          from,
          to,
          isVertical
        });
      }
    }
  };
  WaterfallChart2.prototype.updateRange = function updateRange(value2, fields) {
    BarChart2.prototype.updateRange.call(this, { value: fields.to }, fields);
  };
  WaterfallChart2.prototype.aboveAxis = function aboveAxis(point) {
    return point.value >= 0;
  };
  WaterfallChart2.prototype.plotRange = function plotRange(point) {
    return [point.from, point.to];
  };
  WaterfallChart2.prototype.createSegments = function createSegments() {
    var this$1 = this;
    var series = this.options.series;
    var seriesPoints = this.seriesPoints;
    var segments = this.segments = [];
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var points = seriesPoints[seriesIx];
      if (points) {
        var prevPoint = void 0;
        for (var pointIx = 0; pointIx < points.length; pointIx++) {
          var point = points[pointIx];
          if (point && prevPoint) {
            var segment = new waterfall_segment_default(prevPoint, point, currentSeries);
            segments.push(segment);
            this$1.append(segment);
          }
          prevPoint = point;
        }
      }
    }
  };
  return WaterfallChart2;
}(bar_chart_default);
var waterfall_chart_default = WaterfallChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-factory.js
function trendlineFactory(registry2, type, context) {
  var impl = registry2[String(type)];
  if (impl) {
    return impl(context);
  }
  return null;
}
var trendline_factory_default = trendlineFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-slope.js
function calculateSlope(sourceValues, valueGetter10) {
  var x5 = 0;
  var y = 0;
  var x22 = 0;
  var xy = 0;
  var count = 0;
  var slope, intercept;
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  for (var i36 = 0; i36 < sourceValues.length; i36++) {
    var value2 = sourceValues[i36];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      x5 += xValue;
      y += yValue;
      x22 += Math.pow(xValue, 2);
      xy += xValue * yValue;
    }
  }
  if (count > 0) {
    slope = (count * xy - x5 * y) / (count * x22 - Math.pow(x5, 2));
    intercept = (y - slope * x5) / count;
  }
  return { slope, intercept, count, xMin, xMax };
}
var calculate_slope_default = calculateSlope;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/check-all-positive.js
var checkAllPositive = function(sourceValues, fieldName) {
  return sourceValues.every(function(ref2) {
    var valueFields = ref2.valueFields;
    return !hasValue(valueFields[fieldName]) || valueFields[fieldName] > 0;
  });
};
var check_all_positive_default = checkAllPositive;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-trendline-data.js
function getTrendlineData(valueMapper, categoryAxis) {
  var data = [];
  var totalRange = categoryAxis.totalRangeIndices();
  var currentRange = categoryAxis.currentRangeIndices();
  var range = {
    min: Math.floor(Math.max(currentRange.min - 1, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + 2, totalRange.max))
  };
  for (var i36 = range.min; i36 < range.max; i36++) {
    var x5 = i36 + 1;
    data[i36] = {
      category: categoryAxis.categoryAt(i36, true),
      value: valueMapper(x5)
    };
  }
  return data;
}
var get_trendline_data_default = getTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/exponential-trendline.js
function exponentialTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx + 1, yValue: Math.log(valueFields[fieldName]) };
    ;
  };
};
function getData(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a38 = Math.exp(intercept);
    var b2 = slope;
    return get_trendline_data_default(function(x5) {
      return a38 * Math.exp(b2 * x5);
    }, categoryAxis);
  }
  return null;
}
var exponential_trendline_default = exponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/linear-trendline.js
function linearTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData2({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter2 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx + 1, yValue: valueFields[fieldName] };
    ;
  };
};
function getData2(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var ref$1 = calculate_slope_default(seriesValues(), valueGetter2(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    return get_trendline_data_default(function(x5) {
      return slope * x5 + intercept;
    }, categoryAxis);
  }
  return null;
}
var linear_trendline_default = linearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/logarithmic-trendline.js
function logarithmicTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData3({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter3 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(categoryIx + 1), yValue: valueFields[fieldName] };
    ;
  };
};
function getData3(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var ref$1 = calculate_slope_default(seriesValues(), valueGetter3(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a38 = slope;
    var b2 = intercept;
    return get_trendline_data_default(function(x5) {
      return a38 * Math.log(x5) + b2;
    }, categoryAxis);
  }
  return null;
}
var logarithmic_trendline_default = logarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-moving-average.js
function calculateMovingAverage(sourceValues, valueGetter10, period) {
  var averagePoints = [];
  var values5 = [];
  var start = Math.max(MIN_MOVING_AVERAGE_PERIOD, period) - 1;
  var end = 0;
  var sum2 = 0;
  for (var i36 = 0; i36 < sourceValues.length; i36++) {
    var value2 = sourceValues[i36];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(yValue) && yValue !== null) {
      values5.push(yValue);
      sum2 += yValue;
      end = Math.max(i36, end);
    } else {
      values5.push(null);
    }
    if (i36 >= start) {
      var count = values5.filter(function(value3) {
        return value3 !== null;
      }).length;
      var lastValue = values5.shift() || 0;
      if (count > 0) {
        var average = sum2 / count;
        averagePoints.push([xValue, average]);
        sum2 -= lastValue;
        continue;
      }
    }
    averagePoints.push([xValue, null]);
  }
  return averagePoints.slice(0, end + 1);
}
var calculate_moving_average_default = calculateMovingAverage;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/moving-average.js
function movingAverageTrendline(context) {
  var options = context.options;
  var data = getData4(context);
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter4 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx, yValue: valueFields[fieldName] };
    ;
  };
};
function calculatePoints(ref2) {
  var options = ref2.options;
  var categoryAxis = ref2.categoryAxis;
  var seriesValues = ref2.seriesValues;
  var period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  var totalRange = categoryAxis.totalRangeIndices();
  var currentRange = categoryAxis.currentRangeIndices();
  var range = {
    min: Math.floor(Math.max(currentRange.min - period, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + period + 2, totalRange.max))
  };
  return calculate_moving_average_default(seriesValues(range), valueGetter4(options.field), period);
}
function getData4(context) {
  var categoryAxis = context.categoryAxis;
  var points = calculatePoints(context);
  var data = [];
  points.forEach(function(ref2) {
    var categoryIx = ref2[0];
    var value2 = ref2[1];
    data[categoryIx] = {
      category: categoryAxis.categoryAt(categoryIx, true),
      value: value2
    };
  });
  if (data.length > 0) {
    return data;
  }
  return null;
}
var moving_average_default = movingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-polynomial.js
var MIN_ORDER = 1;
var MAX_ORDER = 6;
function calculatePolynomial(sourceValues, valueGetter10, order) {
  var k = Math.min(Math.max(order || MIN_ORDER, MIN_ORDER), MAX_ORDER) + 1;
  var X2 = new matrix_default();
  var Y2 = new matrix_default();
  var count = 0;
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  var valueMapper = function(x5) {
    return x5;
  };
  var coefficients = [];
  for (var i36 = 0; i36 < sourceValues.length; i36++) {
    var value2 = sourceValues[i36];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      Y2.set(i36, 0, yValue);
      X2.set(i36, 0, 1);
      X2.set(i36, 1, xValue);
      for (var pow3 = 2; pow3 <= k; pow3++) {
        X2.set(i36, pow3, Math.pow(X2.get(i36, 1), pow3));
      }
    } else {
      X2.set(i36, 0, 0);
    }
  }
  X2.width = Math.min(k, count);
  if (count > 0) {
    coefficients = linearRegression(X2, Y2);
    valueMapper = function(x5) {
      return coefficients.reduce(function(y, a38, n20) {
        return y + a38 * Math.pow(x5, n20);
      }, 0);
    };
  }
  return {
    coefficients,
    count,
    valueMapper,
    xMin,
    xMax
  };
}
function linearRegression(X2, Y2) {
  var Xt = X2.transpose();
  var B = Xt.multiply(X2).inverse().multiply(Xt).multiply(Y2);
  var coefficients = [];
  for (var i36 = 0; i36 < B.height; i36++) {
    coefficients.push(B.get(i36, 0));
  }
  return coefficients;
}
var calculate_polynomial_default = calculatePolynomial;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/polynomial-trendline.js
function polynomialTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData5({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter5 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: categoryIx + 1, yValue: valueFields[fieldName] };
    ;
  };
};
function getData5(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var order = (options.trendline || {}).order;
  var ref$1 = calculate_polynomial_default(seriesValues(), valueGetter5(options.field), order);
  var count = ref$1.count;
  var valueMapper = ref$1.valueMapper;
  if (count > 0) {
    return get_trendline_data_default(function(x5) {
      return valueMapper(x5);
    }, categoryAxis);
  }
  return null;
}
var polynomial_trendline_default = polynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/power-trendline.js
function powerTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData6({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter6 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(categoryIx + 1), yValue: Math.log(valueFields[fieldName]) };
    ;
  };
};
function getData6(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter6(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a38 = Math.exp(intercept);
    var b2 = slope;
    return get_trendline_data_default(function(x5) {
      return a38 * Math.pow(x5, b2);
    }, categoryAxis);
  }
  return null;
}
var power_trendline_default = powerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-registry.js
var registry = {};
registry[TRENDLINE_EXPONENTIAL] = exponential_trendline_default;
registry[TRENDLINE_LINEAR] = linear_trendline_default;
registry[TRENDLINE_LOGARITHMIC] = logarithmic_trendline_default;
registry[TRENDLINE_MOVING_AVERAGE] = moving_average_default;
registry[TRENDLINE_POLYNOMIAL] = polynomial_trendline_default;
registry[TRENDLINE_POWER] = power_trendline_default;
var trendline_registry_default = registry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/categorical-plotarea.js
var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];
var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);
var CategoricalPlotArea = function(PlotAreaBase2) {
  function CategoricalPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) CategoricalPlotArea2.__proto__ = PlotAreaBase2;
  CategoricalPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  CategoricalPlotArea2.prototype.constructor = CategoricalPlotArea2;
  CategoricalPlotArea2.prototype.initFields = function initFields(series) {
    var this$1 = this;
    this.namedCategoryAxes = {};
    this.namedValueAxes = {};
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
    this._seriesPointsCache = {};
    this._currentPointsCache = {};
    if (series.length > 0) {
      this.invertAxes = inArray(
        series[0].type,
        [
          BAR,
          BULLET,
          VERTICAL_LINE,
          VERTICAL_AREA,
          VERTICAL_RANGE_AREA,
          RANGE_BAR,
          HORIZONTAL_WATERFALL,
          VERTICAL_BOX_PLOT
        ]
      );
      for (var i36 = 0; i36 < series.length; i36++) {
        var stack = series[i36].stack;
        if (stack && stack.type === "100%") {
          this$1.stack100 = true;
          break;
        }
      }
    }
  };
  CategoricalPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0) panes = this.panes;
    this.series = [].concat(this.originalSeries);
    this.createCategoryAxes(panes);
    this.aggregateCategories(panes);
    this.createTrendlineSeries(panes);
    this.createCategoryAxesLabels(panes);
    this.createCharts(panes);
    this.createValueAxes(panes);
  };
  CategoricalPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis instanceof category_axis_default) {
      delete this.namedCategoryAxes[axisName];
    } else {
      this.valueAxisRangeTracker.reset(axisName);
      delete this.namedValueAxes[axisName];
    }
    if (axis === this.categoryAxis) {
      delete this.categoryAxis;
    }
    if (axis === this.valueAxis) {
      delete this.valueAxis;
    }
  };
  CategoricalPlotArea2.prototype.trendlineFactory = function trendlineFactory$1(options, series) {
    var categoryAxis = this.seriesCategoryAxis(options);
    var seriesValues = this.seriesValues.bind(this, series.index);
    var trendline = trendline_factory_default(trendline_registry_default, options.type, {
      options,
      categoryAxis,
      seriesValues
    });
    if (trendline) {
      trendline.categoryAxis = series.categoryAxis;
      trendline.valueAxis = series.valueAxis;
      return this.filterSeries(trendline, categoryAxis);
    }
    return trendline;
  };
  CategoricalPlotArea2.prototype.trendlineAggregateForecast = function trendlineAggregateForecast() {
    return this.series.map(function(series) {
      return (series.trendline || {}).forecast;
    }).filter(function(forecast) {
      return forecast !== void 0;
    }).reduce(function(result, forecast) {
      return {
        before: Math.max(result.before, forecast.before || 0),
        after: Math.max(result.after, forecast.after || 0)
      };
    }, { before: 0, after: 0 });
  };
  CategoricalPlotArea2.prototype.seriesValues = function seriesValues(seriesIx, range) {
    var this$1 = this;
    var result = [];
    var series = this.srcSeries[seriesIx];
    var categoryAxis = this.seriesCategoryAxis(series);
    var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
    if (dateAxis) {
      this._seriesPointsCache = {};
      this._currentPointsCache = {};
      categoryAxis.options.dataItems = [];
      series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());
    }
    var min4 = range ? range.min : 0;
    var max3 = range ? range.max : series.data.length;
    for (var categoryIx = min4; categoryIx < max3; categoryIx++) {
      var data = this$1.bindPoint(series, categoryIx);
      result.push({ categoryIx, category: data.fields.category, valueFields: data.valueFields });
    }
    return result;
  };
  CategoricalPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i36 = 0; i36 < panes.length; i36++) {
      var pane = panes[i36];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var visibleSeries = this$1.filterVisibleSeries(paneSeries);
      if (!visibleSeries) {
        continue;
      }
      var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);
      for (var groupIx = 0; groupIx < groups.length; groupIx++) {
        this$1.createChartGroup(groups[groupIx], pane);
      }
    }
  };
  CategoricalPlotArea2.prototype.createChartGroup = function createChartGroup(series, pane) {
    this.createAreaChart(
      filterSeriesByType(series, [AREA, VERTICAL_AREA]),
      pane
    );
    this.createRangeAreaChart(
      filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [COLUMN, BAR]),
      pane
    );
    this.createRangeBarChart(
      filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]),
      pane
    );
    this.createBulletChart(
      filterSeriesByType(series, [BULLET, VERTICAL_BULLET]),
      pane
    );
    this.createCandlestickChart(
      filterSeriesByType(series, CANDLESTICK),
      pane
    );
    this.createBoxPlotChart(
      filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]),
      pane
    );
    this.createOHLCChart(
      filterSeriesByType(series, OHLC),
      pane
    );
    this.createWaterfallChart(
      filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [LINE, VERTICAL_LINE]),
      pane
    );
  };
  CategoricalPlotArea2.prototype.aggregateCategories = function aggregateCategories(panes) {
    var this$1 = this;
    var series = [].concat(this.series);
    var processedSeries = [];
    this._currentPointsCache = {};
    this._seriesPointsCache = this._seriesPointsCache || {};
    for (var i36 = 0; i36 < series.length; i36++) {
      var currentSeries = series[i36];
      if (!this$1.isTrendline(currentSeries)) {
        var categoryAxis = this$1.seriesCategoryAxis(currentSeries);
        var axisPane = this$1.findPane(categoryAxis.options.pane);
        var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
        if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {
          currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());
        } else {
          currentSeries = this$1.filterSeries(currentSeries, categoryAxis);
        }
      }
      processedSeries.push(currentSeries);
    }
    this._seriesPointsCache = this._currentPointsCache;
    this._currentPointsCache = null;
    this.srcSeries = series;
    this.series = processedSeries;
  };
  CategoricalPlotArea2.prototype.filterSeries = function filterSeries(series, categoryAxis) {
    var dataLength = (series.data || {}).length;
    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);
    if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {
      return series;
    }
    var range = categoryAxis.currentRangeIndices();
    var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);
    var currentSeries = deepExtend({}, series);
    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);
    if (outOfRangePoints) {
      createOutOfRangePoints(currentSeries, range, dataLength, function(idx) {
        return {
          item: series.data[idx],
          category: categoryAxis.categoryAt(idx, true),
          categoryIx: idx - range.min
        };
      }, function(idx) {
        return defined(series.data[idx]);
      });
    }
    return currentSeries;
  };
  CategoricalPlotArea2.prototype.clearSeriesPointsCache = function clearSeriesPointsCache() {
    this._seriesPointsCache = {};
  };
  CategoricalPlotArea2.prototype.seriesSourcePoints = function seriesSourcePoints(series, categoryAxis) {
    var this$1 = this;
    var key = series.index + ";" + categoryAxis.categoriesHash();
    if (this._seriesPointsCache && this._seriesPointsCache[key]) {
      this._currentPointsCache[key] = this._seriesPointsCache[key];
      return this._seriesPointsCache[key];
    }
    var axisOptions2 = categoryAxis.options;
    var srcCategories = axisOptions2.srcCategories;
    var dateAxis = equalsIgnoreCase(axisOptions2.type, DATE);
    var srcData = series.data;
    var result = [];
    if (!dateAxis) {
      categoryAxis.indexCategories();
    }
    for (var idx = 0; idx < srcData.length; idx++) {
      var category = series_binder_default.current.bindPoint(series, idx).fields.category;
      if (dateAxis) {
        category = parseDateCategory(category, srcData[idx], this$1.chartService.intl);
      }
      if (!defined(category)) {
        category = srcCategories[idx];
      }
      if (defined(category) && category !== null) {
        var categoryIx = categoryAxis.totalIndex(category);
        result[categoryIx] = result[categoryIx] || { items: [], category };
        result[categoryIx].items.push(idx);
      }
    }
    this._currentPointsCache[key] = result;
    return result;
  };
  CategoricalPlotArea2.prototype.aggregateSeries = function aggregateSeries(series, categoryAxis, range) {
    var srcData = series.data;
    if (!srcData.length) {
      return series;
    }
    var srcPoints = this.seriesSourcePoints(series, categoryAxis);
    var result = deepExtend({}, series);
    var aggregator = new series_aggregator_default(deepExtend({}, series), series_binder_default.current, default_aggregates_default.current);
    var data = result.data = [];
    var dataItems = categoryAxis.options.dataItems || [];
    var categoryItem = function(idx2) {
      var categoryIdx = idx2 - range.min;
      var point2 = srcPoints[idx2];
      if (!point2) {
        point2 = srcPoints[idx2] = {};
      }
      point2.categoryIx = categoryIdx;
      if (!point2.item) {
        var category = categoryAxis.categoryAt(idx2, true);
        point2.category = category;
        point2.item = aggregator.aggregatePoints(point2.items, category);
      }
      return point2;
    };
    for (var idx = range.min; idx <= range.max; idx++) {
      var point = categoryItem(idx);
      data[point.categoryIx] = point.item;
      if (point.items && point.items.length) {
        dataItems[point.categoryIx] = point.item;
      }
    }
    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {
      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function(idx2) {
        return srcPoints[idx2];
      });
    }
    categoryAxis.options.dataItems = dataItems;
    return result;
  };
  CategoricalPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    var series = chart.options.series;
    var categoryAxis = this.seriesCategoryAxis(series[0]);
    var categories = categoryAxis.options.categories;
    var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);
    if (categoriesToAdd > 0) {
      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);
      while (categoriesToAdd--) {
        categories.push("");
      }
    }
    this.valueAxisRangeTracker.update(chart.valueAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  CategoricalPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options = this.options;
    var axisName = series.axis;
    var axisOptions2 = [].concat(options.valueAxis);
    var axis = grep(axisOptions2, function(a38) {
      return a38.name === axisName;
    })[0];
    var panes = options.panes || [{}];
    var defaultPaneName = (panes[0] || {}).name || "default";
    var paneName = (axis || {}).pane || defaultPaneName;
    return paneName;
  };
  CategoricalPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis(series) {
    var axisName = series.categoryAxis;
    var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;
    if (!axis) {
      throw new Error("Unable to locate category axis with name " + axisName);
    }
    return axis;
  };
  CategoricalPlotArea2.prototype.stackableChartOptions = function stackableChartOptions(series, pane) {
    var anyStackedSeries = series.some(function(s10) {
      return s10.stack;
    });
    var isStacked100 = series.some(function(s10) {
      return s10.stack && s10.stack.type === "100%";
    });
    var clip = pane.options.clip;
    return {
      defaultStack: series[0].stack,
      isStacked: anyStackedSeries,
      isStacked100,
      clip
    };
  };
  CategoricalPlotArea2.prototype.groupSeriesByCategoryAxis = function groupSeriesByCategoryAxis(series) {
    var categoryAxes = [];
    var unique = {};
    for (var idx = 0; idx < series.length; idx++) {
      var name2 = series[idx].categoryAxis || "$$default$$";
      if (!hasOwnProperty(unique, name2)) {
        unique[name2] = true;
        categoryAxes.push(name2);
      }
    }
    var groups = [];
    for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
      var axis = categoryAxes[axisIx];
      var axisSeries = groupSeries(series, axis, axisIx);
      if (axisSeries.length === 0) {
        continue;
      }
      groups.push(axisSeries);
    }
    return groups;
  };
  CategoricalPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var barChart = new bar_chart_default(this, Object.assign({
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(barChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeBarChart = function createRangeBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var rangeColumnChart = new range_bar_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(rangeColumnChart, pane);
  };
  CategoricalPlotArea2.prototype.createBulletChart = function createBulletChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var bulletChart = new bullet_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(bulletChart, pane);
  };
  CategoricalPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new line_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(lineChart, pane);
  };
  CategoricalPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new area_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(areaChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeAreaChart = function createRangeAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var rangeAreaChart = new range_area_chart_default(this, {
      invertAxes: this.invertAxes,
      series,
      clip: pane.options.clip
    });
    this.appendChart(rangeAreaChart, pane);
  };
  CategoricalPlotArea2.prototype.createOHLCChart = function createOHLCChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new ohlc_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createCandlestickChart = function createCandlestickChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new candlestick_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createBoxPlotChart = function createBoxPlotChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new box_plot_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createWaterfallChart = function createWaterfallChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var waterfallChart = new waterfall_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(waterfallChart, pane);
  };
  CategoricalPlotArea2.prototype.axisRequiresRounding = function axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
    var this$1 = this;
    var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);
    for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
      var currentSeries = this$1.series[seriesIx];
      if (inArray(currentSeries.type, AREA_SERIES)) {
        var line = currentSeries.line;
        if (line && line.style === STEP) {
          centeredSeries.push(currentSeries);
        }
      }
    }
    for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {
      var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || "";
      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.aggregatedAxis = function aggregatedAxis(categoryAxisName, categoryAxisIndex) {
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var seriesAxis = series[seriesIx].categoryAxis || "";
      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    var axes = this.axes;
    for (var i36 = 0; i36 < axes.length; i36++) {
      if (axes[i36] instanceof category_axis_default) {
        axes[i36].createLabels();
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxes = function createCategoryAxes(panes) {
    var this$1 = this;
    var invertAxes = this.invertAxes;
    var definitions = [].concat(this.options.categoryAxis);
    var axes = [];
    for (var i36 = 0; i36 < definitions.length; i36++) {
      var axisOptions2 = definitions[i36];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var categories = axisOptions2.categories;
        if (categories === void 0) categories = [];
        axisOptions2 = deepExtend({
          vertical: invertAxes,
          reverse: !invertAxes && this$1.chartService.rtl,
          axisCrossingValue: invertAxes ? MAX_VALUE : 0
        }, axisOptions2);
        if (!defined(axisOptions2.justified)) {
          axisOptions2.justified = this$1.isJustified();
        }
        if (this$1.axisRequiresRounding(name2, i36)) {
          axisOptions2.justified = false;
        }
        var categoryAxis = void 0;
        if (isDateAxis(axisOptions2, categories[0])) {
          axisOptions2._forecast = this$1.trendlineAggregateForecast();
          categoryAxis = new date_category_axis_default(axisOptions2, this$1.chartService);
        } else {
          categoryAxis = new category_axis_default(axisOptions2, this$1.chartService);
        }
        definitions[i36].categories = categoryAxis.options.srcCategories;
        if (name2) {
          if (this$1.namedCategoryAxes[name2]) {
            throw new Error("Category axis with name " + name2 + " is already defined");
          }
          this$1.namedCategoryAxes[name2] = categoryAxis;
        }
        categoryAxis.axisIndex = i36;
        axes.push(categoryAxis);
        this$1.appendAxis(categoryAxis);
      }
    }
    var primaryAxis = this.categoryAxis || axes[0];
    this.categoryAxis = primaryAxis;
    if (invertAxes) {
      this.axisY = primaryAxis;
    } else {
      this.axisX = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype.isJustified = function isJustified() {
    var series = this.series;
    for (var i36 = 0; i36 < series.length; i36++) {
      var currentSeries = series[i36];
      if (!inArray(currentSeries.type, AREA_SERIES)) {
        return false;
      }
    }
    return true;
  };
  CategoricalPlotArea2.prototype.createValueAxes = function createValueAxes(panes) {
    var this$1 = this;
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var definitions = [].concat(this.options.valueAxis);
    var invertAxes = this.invertAxes;
    var baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };
    var axes = [];
    if (this.stack100) {
      baseOptions.roundToMajorUnit = false;
      baseOptions.labels = { format: "P0" };
    }
    for (var i36 = 0; i36 < definitions.length; i36++) {
      var axisOptions2 = definitions[i36];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var defaultAxisRange = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
        var range = tracker.query(name2) || defaultRange || defaultAxisRange;
        if (i36 === 0 && range && defaultRange) {
          range.min = Math.min(range.min, defaultRange.min);
          range.max = Math.max(range.max, defaultRange.max);
        }
        var axisType = void 0;
        if (equalsIgnoreCase(axisOptions2.type, LOGARITHMIC)) {
          axisType = logarithmic_axis_default;
        } else {
          axisType = numeric_axis_default;
        }
        var valueAxis = new axisType(
          range.min,
          range.max,
          deepExtend({}, baseOptions, axisOptions2),
          this$1.chartService
        );
        if (name2) {
          if (this$1.namedValueAxes[name2]) {
            throw new Error("Value axis with name " + name2 + " is already defined");
          }
          this$1.namedValueAxes[name2] = valueAxis;
        }
        valueAxis.axisIndex = i36;
        axes.push(valueAxis);
        this$1.appendAxis(valueAxis);
      }
    }
    var primaryAxis = this.valueAxis || axes[0];
    this.valueAxis = primaryAxis;
    if (invertAxes) {
      this.axisX = primaryAxis;
    } else {
      this.axisY = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e39, eventType) {
    var coords = chart._eventCoordinates(e39);
    var point = new point_default(coords.x, coords.y);
    var pane = this.pointPane(point);
    var categories = [];
    var values5 = [];
    if (!pane) {
      return;
    }
    var allAxes = pane.axes;
    for (var i36 = 0; i36 < allAxes.length; i36++) {
      var axis = allAxes[i36];
      if (axis.getValue) {
        appendIfNotNull(values5, axis.getValue(point));
      } else {
        appendIfNotNull(categories, axis.getCategory(point));
      }
    }
    if (categories.length === 0) {
      appendIfNotNull(categories, this.categoryAxis.getCategory(point));
    }
    if (categories.length > 0 && values5.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e39),
        originalEvent: e39,
        category: singleItemOrArray(categories),
        value: singleItemOrArray(values5)
      });
    }
  };
  CategoricalPlotArea2.prototype.pointPane = function pointPane(point) {
    var panes = this.panes;
    for (var i36 = 0; i36 < panes.length; i36++) {
      var currentPane = panes[i36];
      if (currentPane.contentBox.containsPoint(point)) {
        return currentPane;
      }
    }
  };
  CategoricalPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {
    updateAxisOptions(this.options, axis, options);
    updateAxisOptions(this.originalOptions, axis, options);
  };
  CategoricalPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint, offset) {
    if (offset === void 0) offset = 0;
    if (this.invertAxes) {
      return this._siblingsBySeriesIndex(basePoint.series.index, offset);
    }
    return this._siblingsByPointIndex(basePoint.getIndex());
  };
  CategoricalPlotArea2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset) {
    if (offset === void 0) offset = 0;
    if (this.invertAxes) {
      return this._siblingsByPointIndex(basePoint.getIndex());
    }
    var siblings = this._siblingsBySeriesIndex(basePoint.series.index, offset);
    if (this.chartService.rtl) {
      return siblings.reverse();
    }
    return siblings;
  };
  CategoricalPlotArea2.prototype._siblingsByPointIndex = function _siblingsByPointIndex(pointIndex) {
    var this$1 = this;
    var charts = this.charts;
    var result = [];
    for (var i36 = 0; i36 < charts.length; i36++) {
      var chart = charts[i36];
      if (chart.pane && chart.pane.options.name === "_navigator") {
        continue;
      }
      var chartPoints = chart.points.filter(
        function(point) {
          return point && point.visible !== false && point.getIndex() === pointIndex;
        }
      );
      result.push.apply(result, chartPoints.sort(this$1._getSeriesCompareFn(chartPoints[0])));
    }
    return result;
  };
  CategoricalPlotArea2.prototype._siblingsBySeriesIndex = function _siblingsBySeriesIndex(seriesIndex, offset) {
    var index = cycleIndex(seriesIndex + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  };
  CategoricalPlotArea2.prototype._getSeriesCompareFn = function _getSeriesCompareFn(point) {
    var isStacked = this._isInStackedSeries(point);
    if (isStacked && this.invertAxes || !isStacked && !this.invertAxes) {
      return function(a38, b2) {
        return a38.box.center().x - b2.box.center().x;
      };
    }
    return function(a38, b2) {
      return a38.box.center().y - b2.box.center().y;
    };
  };
  CategoricalPlotArea2.prototype._isInStackedSeries = function _isInStackedSeries(point) {
    var sortableSeries = inArray(
      point.series.type,
      [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, LINE, VERTICAL_LINE, RADAR_LINE, RADAR_AREA]
    );
    var stackableSeries = inArray(point.series.type, [COLUMN, BAR]);
    return sortableSeries || stackableSeries && point.options.isStacked;
  };
  return CategoricalPlotArea2;
}(plotarea_base_default);
function updateAxisOptions(targetOptions, axis, options) {
  var axesOptions = axis instanceof category_axis_default ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);
  deepExtend(axesOptions[axis.axisIndex], options);
}
function groupSeries(series, axis, axisIx) {
  return grep(series, function(s10) {
    return axisIx === 0 && !s10.categoryAxis || s10.categoryAxis === axis;
  });
}
setDefaultOptions(CategoricalPlotArea, {
  categoryAxis: {},
  valueAxis: {}
});
deepExtend(CategoricalPlotArea.prototype, plotarea_events_mixin_default);
var categorical_plotarea_default = CategoricalPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/highlight.js
var Highlight = function(Class) {
  function Highlight2() {
    Class.call(this);
    this._points = [];
  }
  if (Class) Highlight2.__proto__ = Class;
  Highlight2.prototype = Object.create(Class && Class.prototype);
  Highlight2.prototype.constructor = Highlight2;
  Highlight2.prototype.destroy = function destroy() {
    this._points = [];
  };
  Highlight2.prototype.show = function show2(points, opacity) {
    var this$1 = this;
    var arrayPoints = [].concat(points);
    this.hide();
    for (var i36 = 0; i36 < arrayPoints.length; i36++) {
      var point = arrayPoints[i36];
      if (point && point.toggleHighlight && point.hasHighlight()) {
        this$1.togglePointHighlight(point, true, opacity);
        this$1._points.push(point);
      }
    }
  };
  Highlight2.prototype.togglePointHighlight = function togglePointHighlight(point, show2, opacity) {
    var toggleHandler = (point.options.highlight || {}).toggle;
    if (toggleHandler) {
      var eventArgs = {
        category: point.category,
        series: point.series,
        dataItem: point.dataItem,
        value: point.value,
        stackValue: point.stackValue,
        preventDefault: preventDefault3,
        visual: point.highlightVisual(),
        show: show2
      };
      toggleHandler(eventArgs);
      if (!eventArgs._defaultPrevented) {
        point.toggleHighlight(show2, opacity);
      }
    } else {
      point.toggleHighlight(show2, opacity);
    }
  };
  Highlight2.prototype.hide = function hide2() {
    var this$1 = this;
    var points = this._points;
    while (points.length) {
      this$1.togglePointHighlight(points.pop(), false);
    }
  };
  Highlight2.prototype.isHighlighted = function isHighlighted(element) {
    var points = this._points;
    for (var i36 = 0; i36 < points.length; i36++) {
      var point = points[i36];
      if (element === point) {
        return true;
      }
    }
    return false;
  };
  return Highlight2;
}(class_default);
function preventDefault3() {
  this._defaultPrevented = true;
}
var highlight_default = Highlight;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/accept-key.js
function acceptKey(e39, mouseKey) {
  var key = (mouseKey || "").toLowerCase();
  var event = e39.event;
  var accept = key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + "Key"];
  return accept;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/to-chart-axis-ranges.js
function toChartAxisRanges(axisRanges2) {
  var ranges = {};
  for (var idx = 0; idx < axisRanges2.length; idx++) {
    var axisRange = axisRanges2[idx];
    if (axisRange.axis.options.name) {
      ranges[axisRange.axis.options.name] = {
        min: axisRange.range.min,
        max: axisRange.range.max
      };
    }
  }
  return ranges;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/pannable.js
var Pannable = function(Class) {
  function Pannable2(plotArea, options) {
    Class.call(this);
    this.plotArea = plotArea;
    this.options = deepExtend({}, this.options, options);
  }
  if (Class) Pannable2.__proto__ = Class;
  Pannable2.prototype = Object.create(Class && Class.prototype);
  Pannable2.prototype.constructor = Pannable2;
  Pannable2.prototype.start = function start(e39) {
    this._active = acceptKey(e39, this.options.key);
    return this._active;
  };
  Pannable2.prototype.move = function move(e39) {
    if (this._active) {
      var axisRanges2 = this.axisRanges = this._panAxes(e39, X).concat(this._panAxes(e39, Y));
      if (axisRanges2.length) {
        this.axisRanges = axisRanges2;
        return toChartAxisRanges(axisRanges2);
      }
    }
  };
  Pannable2.prototype.end = function end() {
    var active = this._active;
    this._active = false;
    return active;
  };
  Pannable2.prototype.pan = function pan() {
    var ref2 = this;
    var plotArea = ref2.plotArea;
    var axisRanges2 = ref2.axisRanges;
    if (axisRanges2.length) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var range = axisRanges2[idx];
        plotArea.updateAxisOptions(range.axis, range.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  Pannable2.prototype.destroy = function destroy() {
    delete this.plotArea;
  };
  Pannable2.prototype._panAxes = function _panAxes(e39, position) {
    var plotArea = this.plotArea;
    var delta = -e39[position].delta;
    var lock = (this.options.lock || "").toLowerCase();
    var updatedAxes = [];
    if (delta !== 0 && (lock || "").toLowerCase() !== position) {
      var axes = plotArea.axes;
      for (var idx = 0; idx < axes.length; idx++) {
        var axis = axes[idx];
        if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {
          var range = axis.pan(delta);
          if (range) {
            range.limitRange = true;
            updatedAxes.push({
              axis,
              range
            });
          }
        }
      }
    }
    return updatedAxes;
  };
  return Pannable2;
}(class_default);
Pannable.prototype.options = {
  key: "none",
  lock: "none"
};
var pannable_default = Pannable;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/zoom-selection.js
var ZoomSelection = function(Class) {
  function ZoomSelection2(chart, options) {
    Class.call(this);
    this.chart = chart;
    this.options = deepExtend({}, this.options, options);
    this.createElement();
  }
  if (Class) ZoomSelection2.__proto__ = Class;
  ZoomSelection2.prototype = Object.create(Class && Class.prototype);
  ZoomSelection2.prototype.constructor = ZoomSelection2;
  ZoomSelection2.prototype.createElement = function createElement93() {
    var marquee = this._marquee = document.createElement("div");
    marquee.className = "k-marquee";
    var marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
  };
  ZoomSelection2.prototype.removeElement = function removeElement() {
    if (this._marquee.parentNode) {
      this._marquee.parentNode.removeChild(this._marquee);
    }
  };
  ZoomSelection2.prototype.setStyles = function setStyles(styles) {
    elementStyles(this._marquee, styles);
  };
  ZoomSelection2.prototype.start = function start(e39) {
    if (acceptKey(e39, this.options.key)) {
      var chart = this.chart;
      var point = chart._eventCoordinates(e39);
      var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);
      var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;
      if (zoomPane && clipBox) {
        var offset = this._elementOffset();
        clipBox.translate(offset.left, offset.top);
        this._zoomPaneClipBox = clipBox;
        document.body.appendChild(this._marquee);
        this.setStyles({
          left: e39.pageX + 1,
          top: e39.pageY + 1,
          width: 0,
          height: 0
        });
        return true;
      }
    }
    return false;
  };
  ZoomSelection2.prototype._elementOffset = function _elementOffset() {
    var chartElement = this.chart.element;
    var ref2 = elementStyles(chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref2.paddingLeft;
    var paddingTop = ref2.paddingTop;
    var offset = elementOffset(chartElement);
    return {
      left: paddingLeft + offset.left,
      top: paddingTop + offset.top
    };
  };
  ZoomSelection2.prototype.move = function move(e39) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      this.setStyles(this._selectionPosition(e39));
    }
  };
  ZoomSelection2.prototype.end = function end(e39) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      var elementOffset2 = this._elementOffset();
      var selectionPosition = this._selectionPosition(e39);
      selectionPosition.left -= elementOffset2.left;
      selectionPosition.top -= elementOffset2.top;
      var start = { x: selectionPosition.left, y: selectionPosition.top };
      var end2 = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };
      this._updateAxisRanges(start, end2);
      this.removeElement();
      delete this._zoomPane;
      return toChartAxisRanges(this.axisRanges);
    }
  };
  ZoomSelection2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    if (axisRanges2 && axisRanges2.length) {
      var plotArea = this.chart._plotArea;
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  ZoomSelection2.prototype.destroy = function destroy() {
    this.removeElement();
    delete this._marquee;
    delete this.chart;
  };
  ZoomSelection2.prototype._updateAxisRanges = function _updateAxisRanges(start, end) {
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this._zoomPane.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {
        var range = axis.pointsRange(start, end);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
  };
  ZoomSelection2.prototype._selectionPosition = function _selectionPosition(e39) {
    var clipBox = this._zoomPaneClipBox;
    var startLocation = {
      x: e39.x.startLocation,
      y: e39.y.startLocation
    };
    var pageX = e39.x.location;
    var pageY = e39.y.location;
    var lock = (this.options.lock || "").toLowerCase();
    var left = Math.min(startLocation.x, pageX);
    var top = Math.min(startLocation.y, pageY);
    var width = Math.abs(startLocation.x - pageX);
    var height = Math.abs(startLocation.y - pageY);
    if (lock === X) {
      left = clipBox.x1;
      width = clipBox.width();
    }
    if (lock === Y) {
      top = clipBox.y1;
      height = clipBox.height();
    }
    if (pageX > clipBox.x2) {
      width = clipBox.x2 - startLocation.x;
    }
    if (pageX < clipBox.x1) {
      width = startLocation.x - clipBox.x1;
    }
    if (pageY > clipBox.y2) {
      height = clipBox.y2 - startLocation.y;
    }
    if (pageY < clipBox.y1) {
      height = startLocation.y - clipBox.y1;
    }
    return {
      left: Math.max(left, clipBox.x1),
      top: Math.max(top, clipBox.y1),
      width,
      height
    };
  };
  return ZoomSelection2;
}(class_default);
ZoomSelection.prototype.options = {
  key: "shift",
  lock: "none"
};
var zoom_selection_default = ZoomSelection;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/mousewheel-zoom.js
var MIN_RATE = 0.01;
var MAX_RATE = 0.9;
var DEFAULT_RATE = 0.3;
var MousewheelZoom = function(Class) {
  function MousewheelZoom2(chart, options) {
    Class.call(this);
    this.chart = chart;
    this.options = deepExtend({
      rate: DEFAULT_RATE
    }, this.options, options);
  }
  if (Class) MousewheelZoom2.__proto__ = Class;
  MousewheelZoom2.prototype = Object.create(Class && Class.prototype);
  MousewheelZoom2.prototype.constructor = MousewheelZoom2;
  MousewheelZoom2.prototype.updateRanges = function updateRanges(delta, coords) {
    var this$1 = this;
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this.chart._plotArea.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {
        var rate = limitValue(this$1.options.rate, MIN_RATE, MAX_RATE);
        var range = axis.zoomRange(-delta * rate, coords);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
    return toChartAxisRanges(axisRanges2);
  };
  MousewheelZoom2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    var plotArea = this.chart._plotArea;
    if (axisRanges2 && axisRanges2.length && plotArea.updateAxisOptions) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  MousewheelZoom2.prototype.destroy = function destroy() {
    delete this.chart;
  };
  return MousewheelZoom2;
}(class_default);
var mousewheel_zoom_default = MousewheelZoom;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-layout.js
var alignItems = function(rtl) {
  return rtl ? END : START;
};
var LegendLayout = function(ChartElement2) {
  function LegendLayout2(options, chartService) {
    ChartElement2.call(this, options);
    this.chartService = chartService;
  }
  if (ChartElement2) LegendLayout2.__proto__ = ChartElement2;
  LegendLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LegendLayout2.prototype.constructor = LegendLayout2;
  LegendLayout2.prototype.render = function render() {
    var ref2 = this;
    var children = ref2.children;
    var options = ref2.options;
    var vertical = options.vertical;
    this.visual = new drawing_exports.Layout(null, {
      spacing: vertical ? 0 : options.spacing,
      lineSpacing: vertical ? options.spacing : 0,
      orientation: vertical ? VERTICAL : HORIZONTAL,
      reverse: options.rtl,
      alignItems: vertical ? alignItems(options.rtl) : CENTER
    });
    for (var idx = 0; idx < children.length; idx++) {
      var legendItem = children[idx];
      legendItem.reflow(new box_default());
      legendItem.renderVisual();
    }
  };
  LegendLayout2.prototype.reflow = function reflow(box) {
    this.visual.rect(box.toRect());
    this.visual.reflow();
    var bbox = this.visual.clippedBBox();
    if (bbox) {
      this.box = rectToBox(bbox);
    } else {
      this.box = new box_default();
    }
  };
  LegendLayout2.prototype.renderVisual = function renderVisual() {
    this.addVisual();
  };
  LegendLayout2.prototype.createVisual = function createVisual() {
  };
  return LegendLayout2;
}(chart_element_default);
var legend_layout_default = LegendLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-marker.js
var DEFAULT_MARKER_SIZE = 10;
var DEFAULT_MARKER_BORDER_WIDTH = 2;
var LegendItemMarker = function(ShapeElement2) {
  function LegendItemMarker2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) LegendItemMarker2.__proto__ = ShapeElement2;
  LegendItemMarker2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemMarker2.prototype.constructor = LegendItemMarker2;
  LegendItemMarker2.prototype.visualStyle = function visualStyle() {
    var options = this.markerOptions();
    var border = options.border;
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      cursor: options.cursor
    };
  };
  LegendItemMarker2.prototype.markerOptions = function markerOptions() {
    return this.options;
  };
  LegendItemMarker2.prototype.markerHighlightOptions = function markerHighlightOptions() {
    var options = this.markerOptions();
    var borderWidth = options.highlight.border.width;
    return deepExtend(
      {},
      options,
      { background: options.border.color },
      options.highlight,
      options.type === CROSS ? {
        background: options.highlight.border.color,
        border: { color: options.highlight.background, width: borderWidth / 2 },
        width: options.width,
        height: options.height,
        margin: { top: 0, left: 0 }
      } : {}
    );
  };
  LegendItemMarker2.prototype.createHighlight = function createHighlight() {
    var highlight = new ShapeElement2(this.markerHighlightOptions());
    var box = this.paddingBox.clone();
    highlight.reflow(box.pad(highlight.options.border.width));
    this.highlight = [highlight.getElement()];
    return this.highlight;
  };
  return LegendItemMarker2;
}(shape_element_default);
setDefaultOptions(LegendItemMarker, {
  border: {
    width: DEFAULT_MARKER_BORDER_WIDTH
  },
  width: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  height: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  background: WHITE,
  margin: {
    top: -1,
    left: -1
  },
  vAlign: TOP,
  align: LEFT,
  highlight: {
    width: DEFAULT_MARKER_SIZE,
    height: DEFAULT_MARKER_SIZE,
    border: {
      color: WHITE,
      width: DEFAULT_MARKER_BORDER_WIDTH
    }
  }
});
var legend_item_marker_default = LegendItemMarker;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line-area.js
var MarkerLineArea = function(ShapeElement2) {
  function MarkerLineArea2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) MarkerLineArea2.__proto__ = ShapeElement2;
  MarkerLineArea2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  MarkerLineArea2.prototype.constructor = MarkerLineArea2;
  MarkerLineArea2.prototype.getElement = function getElement() {
    var group = new drawing_exports.Group();
    var element = new drawing_exports.MultiPath(this.visualStyle());
    var ref2 = this;
    var box = ref2.paddingBox;
    var halfHeight = box.height() / 2;
    element.moveTo(box.x1, box.y1 + halfHeight).lineTo(box.x1, box.y2).lineTo(box.x2, box.y2);
    group.append(element);
    return group;
  };
  return MarkerLineArea2;
}(shape_element_default);
setDefaultOptions(MarkerLineArea, {
  width: 15,
  height: 15,
  align: RIGHT,
  vAlign: BOTTOM,
  margin: {
    right: -2,
    bottom: 2
  }
});
var legend_item_line_area_default = MarkerLineArea;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line.js
var LegendItemLine = function(ShapeElement2) {
  function LegendItemLine2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) LegendItemLine2.__proto__ = ShapeElement2;
  LegendItemLine2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemLine2.prototype.constructor = LegendItemLine2;
  LegendItemLine2.prototype.getElement = function getElement() {
    var group = new drawing_exports.Group();
    var element = new drawing_exports.MultiPath({
      stroke: {
        color: this.options.border.color,
        opacity: this.options.opacity,
        width: this.options.height,
        dashType: this.options.dashType
      }
    });
    var box = this.paddingBox;
    var centerY = box.center().y;
    element.moveTo(box.x1, centerY).lineTo(box.x2, centerY);
    group.append(element);
    return group;
  };
  LegendItemLine2.prototype.createHighlight = function createHighlight() {
    this.highlight = [this.createHighlightLine(), this.createHighlightMarker()];
    return this.highlight;
  };
  LegendItemLine2.prototype.createHighlightLine = function createHighlightLine() {
    var options = deepExtend({}, {
      border: {
        color: this.options.border.color,
        opacity: this.options.border.opacity,
        dashType: this.options.border.dashType
      }
    }, this.options.highlight);
    var highlightLine = new legend_item_line_area_default(options);
    highlightLine.reflow(this.parent.paddingBox.clone());
    this.highlightLine = highlightLine.getElement();
    return this.highlightLine;
  };
  LegendItemLine2.prototype.createHighlightMarker = function createHighlightMarker() {
    var options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    var highlightMarker = new ShapeElement2(options);
    var paddingBox = this.parent.paddingBox;
    var borderWidth = options.border.width;
    var box = this.parent.box.clone();
    box.pad({
      left: borderWidth - paddingBox.x1,
      top: borderWidth - paddingBox.y1
    });
    highlightMarker.reflow(box);
    this.highlightMarker = highlightMarker.getElement();
    return this.highlightMarker;
  };
  return LegendItemLine2;
}(shape_element_default);
setDefaultOptions(LegendItemLine, {
  border: {
    width: 0
  },
  type: RECT,
  align: LEFT,
  vAlign: CENTER,
  highlight: {
    border: {
      width: DEFAULT_MARKER_BORDER_WIDTH
    },
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      align: LEFT,
      vAlign: TOP
    }
  }
});
var legend_item_line_default = LegendItemLine;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-square.js
var LegendItemSquare = function(ShapeElement2) {
  function LegendItemSquare2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) LegendItemSquare2.__proto__ = ShapeElement2;
  LegendItemSquare2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemSquare2.prototype.constructor = LegendItemSquare2;
  LegendItemSquare2.prototype.createHighlight = function createHighlight() {
    var options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    var highlight = new ShapeElement2(options);
    var box = this.paddingBox.clone();
    var targetBox = this.parent.box.clone();
    box.align(targetBox, X, LEFT);
    box.align(targetBox, Y, TOP);
    highlight.reflow(box);
    this.highlight = [highlight.getElement()];
    return this.highlight;
  };
  return LegendItemSquare2;
}(shape_element_default);
setDefaultOptions(LegendItemSquare, {
  highlight: {
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      margin: {
        top: -3,
        left: -3
      }
    }
  }
});
var legend_item_square_default = LegendItemSquare;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item.js
var LegendItem = function(BoxElement2) {
  function LegendItem2(options) {
    BoxElement2.call(this, options);
    this.createContainer();
    if (!options.rtl) {
      this.createMarker();
      this.createLabel();
    } else {
      this.createLabel();
      this.createMarker();
    }
    this._id = guid();
    this.options.accessibility.ariaChecked = options.active;
  }
  if (BoxElement2) LegendItem2.__proto__ = BoxElement2;
  LegendItem2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  LegendItem2.prototype.constructor = LegendItem2;
  LegendItem2.prototype.createContainer = function createContainer() {
    this.container = new float_element_default({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });
    this.append(this.container);
  };
  LegendItem2.prototype.createMarker = function createMarker() {
    this.markerWrap = new BoxElement2({ vertical: false, shrinkToFit: true, wrap: false, margin: 1, width: 22, height: 22 });
    this.container.append(this.markerWrap);
    this.createMarkerArea();
    if (this.options.markers.visible) {
      this._marker = this._createMarker();
      this.markerWrap.append(this._marker);
    }
  };
  LegendItem2.prototype.createMarkerArea = function createMarkerArea() {
    var options = this.options;
    var markerColor = options.markerColor;
    var line = options.line;
    if (line === void 0) line = {};
    var lineOptions = {
      border: {
        color: line.color || markerColor,
        opacity: line.opacity,
        dashType: line.dashType
      }
    };
    return this._createLine(lineOptions) || this._createMarkerLine(lineOptions, line) || this._createSquare();
  };
  LegendItem2.prototype.markerOptions = function markerOptions() {
    var options = this.options;
    var markers = options.markers;
    if (markers === void 0) markers = {};
    var markerColor = options.markerColor;
    var border = markers.border;
    if (border === void 0) border = {};
    markers.zIndex = void 0;
    return deepExtend({}, markers, {
      border: { color: border.color || markerColor },
      highlight: options.highlight.markers
    });
  };
  LegendItem2.prototype._highlightOptions = function _highlightOptions() {
    var options = this.options;
    return deepExtend(
      { markers: { type: options.markers.type } },
      options.highlight
    );
  };
  LegendItem2.prototype._createLine = function _createLine(lineOptions) {
    var options = this.options;
    if (options.type === LINE && !options.markers.visible) {
      this._line = new legend_item_line_default(deepExtend({}, {
        background: options.markerColor,
        highlight: this._highlightOptions()
      }, lineOptions, options.line));
      this.markerWrap.append(this._line);
    }
    return this._line;
  };
  LegendItem2.prototype._createMarkerLine = function _createMarkerLine(lineOptions, line) {
    var options = this.options;
    if (options.type === LINE) {
      this._markerLineArea = new legend_item_line_area_default(deepExtend({}, {
        border: {
          width: line.height
        }
      }, lineOptions));
      this.markerWrap.append(this._markerLineArea);
    }
    return this._markerLineArea;
  };
  LegendItem2.prototype._reduceSize = function _reduceSize(object, prop, factor) {
    if (factor === void 0) factor = 0.6;
    if (typeof object[prop] === "number") {
      object[prop] = object[prop] * factor;
    }
  };
  LegendItem2.prototype._createSquare = function _createSquare() {
    var options = this.options;
    if (options.type === AREA) {
      var pattern = options.pattern || (options.series || {}).pattern;
      if (pattern) {
        if (typeof pattern === "function") {
          pattern = pattern(options.series);
        }
        pattern = structuredClone(pattern);
        this._reduceSize(pattern, "gap");
        this._reduceSize(pattern, "width");
        this._reduceSize(pattern, "radius");
      }
      this._square = new legend_item_square_default(Object.assign(
        {},
        {
          border: options.border,
          vAlign: options.markers.visible ? BOTTOM : CENTER,
          highlight: this._highlightOptions()
        },
        options.area,
        {
          pattern,
          background: options.area.background || options.markerColor
        }
      ));
      this.markerWrap.append(this._square);
    }
    return this._square;
  };
  LegendItem2.prototype._createMarker = function _createMarker() {
    return new legend_item_marker_default(this.markerOptions());
  };
  LegendItem2.prototype._highlightMarkers = function _highlightMarkers() {
    if (this.options.active) {
      this._toggleHighlight(true);
    }
  };
  LegendItem2.prototype._restoreMarkers = function _restoreMarkers() {
    this._toggleHighlight(false);
  };
  LegendItem2.prototype._toggleHighlight = function _toggleHighlight(show2) {
    var this$1 = this;
    if (!this.options.highlight.visible) {
      return;
    }
    var element = this._marker || this._square || this._line;
    if (element && element === this._line) {
      this._line.visual.visible(!show2);
    }
    if (element) {
      var highlight = element.highlight;
      if (!highlight) {
        highlight = element.createHighlight();
        highlight.forEach(function(h5) {
          return h5 && this$1.markerWrap.appendVisual(h5);
        });
      }
      highlight.forEach(function(h5) {
        return h5 && h5.visible(show2);
      });
    }
  };
  LegendItem2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labelOptions = deepExtend({}, options.labels);
    this.container.append(new text_box_default(options.text, labelOptions));
  };
  LegendItem2.prototype.getAriaLabelText = function getAriaLabelText2() {
    return this.options.text;
  };
  LegendItem2.prototype.focusVisual = function focusVisual2() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
    this._highlightMarkers();
  };
  LegendItem2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
    this._restoreMarkers();
  };
  LegendItem2.prototype.renderComplete = function renderComplete() {
    BoxElement2.prototype.renderComplete.call(this);
    var cursor = this.options.cursor || {};
    var eventSink = this._itemOverlay = drawing_exports.Path.fromRect(this.container.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null,
      cursor: cursor.style || cursor
    });
    this.appendVisual(eventSink);
  };
  LegendItem2.prototype.click = function click(widget, e39) {
    var args = this.eventArgs(e39);
    if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e39 && e39.type === "contextmenu") {
      e39.preventDefault();
    }
  };
  LegendItem2.prototype.over = function over(widget, e39) {
    var args = this.eventArgs(e39);
    if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {
      widget._legendItemHover(args.seriesIndex, args.pointIndex);
      this._highlightMarkers();
    }
    return true;
  };
  LegendItem2.prototype.out = function out(widget, e39) {
    widget._unsetActivePoint();
    this._restoreMarkers();
    widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e39));
  };
  LegendItem2.prototype.eventArgs = function eventArgs(e39) {
    var options = this.options;
    return {
      element: eventElement(e39),
      text: options.text,
      series: options.series,
      seriesIndex: options.series.index,
      pointIndex: options.pointIndex
    };
  };
  LegendItem2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    var options = this.options;
    if (this.options.visible) {
      var accessibilityOptions = deepExtend({
        ariaLabel: options.accessibility.ariaLabel !== void 0 ? options.accessibility.ariaLabel : options.text
      }, options.accessibility);
      addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
    }
  };
  LegendItem2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options = this.options;
    var customVisual = options.visual;
    if (customVisual) {
      this.visual = customVisual({
        active: options.active,
        series: options.series,
        sender: this.getSender(),
        pointIndex: options.pointIndex,
        options: {
          type: options.type,
          // Passing the markerColor as a background option for backwards compatibility.
          // Example in jq docs - https://docs.telerik.com/kendo-ui/api/javascript/dataviz/ui/chart/configuration/legend.item#legenditemvisual
          markers: deepExtend({ background: this.options.markerColor }, this.markerOptions()),
          labels: options.labels
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          this$1.renderComplete();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
      this._marker = this._markerLineArea = this._square = this._line = null;
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  LegendItem2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = style.stroke.width;
    return drawing_exports.Path.fromRect(this.container.box.pad(borderWidth / 2).toRect(), style);
  };
  return LegendItem2;
}(box_element_default);
setDefaultOptions(LegendItem, {
  accessibility: {
    role: LEGEND_ITEM_ROLE,
    className: LEGEND_ITEM_CLASSNAME,
    ariaRoleDescription: LEGEND_ITEM_ARIA_ROLE_DESCRIPTION
  },
  markers: {},
  highlight: {
    visible: true,
    markers: {}
  }
});
var legend_item_default = LegendItem;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend.js
var CUSTOM = "custom";
var Legend = function(ChartElement2) {
  function Legend3(options, chartService) {
    if (chartService === void 0) chartService = {};
    ChartElement2.call(this, options);
    this.chartService = chartService;
    if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {
      this.options.position = RIGHT;
    }
    this.createContainers();
    this.createLegendTitle(options.title);
    this.createItems();
  }
  if (ChartElement2) Legend3.__proto__ = ChartElement2;
  Legend3.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Legend3.prototype.constructor = Legend3;
  Legend3.prototype.createContainers = function createContainers() {
    var options = this.options;
    var position = options.position;
    var userAlign = options.align;
    var align = position;
    var vAlign = CENTER;
    if (position === CUSTOM) {
      align = LEFT;
    } else if (inArray(position, [TOP, BOTTOM])) {
      if (userAlign === START) {
        align = LEFT;
      } else if (userAlign === END) {
        align = RIGHT;
      } else {
        align = CENTER;
      }
      vAlign = position;
    } else if (userAlign) {
      if (userAlign === START) {
        vAlign = TOP;
      } else if (userAlign === END) {
        vAlign = BOTTOM;
      }
    }
    this.container = new box_element_default({
      margin: options.margin,
      padding: options.padding,
      background: options.background,
      border: options.border,
      vAlign,
      align,
      zIndex: options.zIndex,
      shrinkToFit: true
    });
    if (this.hasTitle()) {
      this.itemsContainer = new box_element_default({
        vAlign,
        align,
        zIndex: options.zIndex,
        shrinkToFit: true
      });
    } else {
      this.itemsContainer = this.container;
    }
    this.append(this.container);
  };
  Legend3.prototype.createItems = function createItems() {
    var chartService = this.getService();
    var options = this.options;
    var vertical = this.isVertical();
    var innerElement = new legend_layout_default({
      vertical,
      spacing: options.spacing,
      rtl: chartService.rtl
    }, chartService);
    var data = options.data;
    if (options.reverse) {
      data = data.slice(0).reverse();
    }
    var count = data.length;
    for (var i36 = 0; i36 < count; i36++) {
      var dataItem = data[i36];
      var ref2 = dataItem.series || {};
      var markers = ref2.markers;
      if (markers === void 0) markers = {};
      var dashType = ref2.dashType;
      var legendItem = ref2.legendItem;
      var opacity = ref2.opacity;
      var markersOptions = deepExtend({ visible: markers.visible !== false, type: CIRCLE }, markers);
      delete markersOptions.size;
      var itemOptions = deepExtend(
        {},
        {
          markers: markersOptions,
          labels: options.labels,
          rtl: chartService.rtl,
          line: Object.assign(
            {},
            { dashType },
            options.line
          ),
          area: Object.assign(
            {},
            { opacity },
            options.area
          ),
          opacity,
          accessibility: options.accessibility,
          focusHighlight: options.focusHighlight
        },
        options.item,
        legendItem,
        dataItem,
        { markers: options.markers }
      );
      innerElement.append(new legend_item_default(itemOptions));
    }
    innerElement.render();
    this.itemsContainer.append(innerElement);
  };
  Legend3.prototype.isVertical = function isVertical() {
    var ref2 = this.options;
    var orientation = ref2.orientation;
    var position = ref2.position;
    var vertical = position === CUSTOM && orientation !== HORIZONTAL || (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [LEFT, RIGHT]));
    return vertical;
  };
  Legend3.prototype.hasItems = function hasItems() {
    return this.container.children[0].children.length > 0;
  };
  Legend3.prototype.getItems = function getItems() {
    return this.itemsContainer.children[0].children;
  };
  Legend3.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var legendBox = targetBox.clone();
    if (!this.hasItems()) {
      this.box = legendBox;
      return;
    }
    if (options.position === CUSTOM) {
      this.containerCustomReflow(legendBox);
      this.box = legendBox;
    } else {
      this.containerReflow(legendBox);
    }
    if (this.hasTitle()) {
      this.title.reflow(new box_default(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));
    }
  };
  Legend3.prototype.containerReflow = function containerReflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var container = ref2.container;
    var position = options.position;
    var width = options.width;
    var height = options.height;
    var pos = position === TOP || position === BOTTOM ? X : Y;
    var vertical = this.isVertical();
    var alignTarget = targetBox.clone();
    var containerBox = targetBox.clone();
    if (position === LEFT || position === RIGHT) {
      containerBox.y1 = alignTarget.y1 = 0;
    }
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
      containerBox.align(alignTarget, Y, container.options.vAlign);
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
      containerBox.align(alignTarget, X, container.options.align);
    }
    container.reflow(containerBox);
    containerBox = container.box;
    var box = containerBox.clone();
    if (options.offsetX || options.offsetY) {
      containerBox.translate(options.offsetX, options.offsetY);
      container.reflow(containerBox);
    }
    box[pos + 1] = targetBox[pos + 1];
    box[pos + 2] = targetBox[pos + 2];
    this.box = box;
  };
  Legend3.prototype.containerCustomReflow = function containerCustomReflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var container = ref2.container;
    var offsetX = options.offsetX;
    var offsetY = options.offsetY;
    var width = options.width;
    var height = options.height;
    var vertical = this.isVertical();
    var containerBox = targetBox.clone();
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
    }
    container.reflow(containerBox);
    containerBox = container.box;
    container.reflow(new box_default(
      offsetX,
      offsetY,
      offsetX + containerBox.width(),
      offsetY + containerBox.height()
    ));
  };
  Legend3.prototype.renderVisual = function renderVisual() {
    if (this.hasItems()) {
      ChartElement2.prototype.renderVisual.call(this);
    }
  };
  Legend3.prototype.createLegendTitle = function createLegendTitle(title3) {
    var titleOptions = deepExtend({}, {
      color: BLACK,
      position: TOP,
      align: CENTER
    }, title3);
    var text = titleOptions.text;
    if (!title3 || title3.visible === false || !title3.text) {
      return;
    }
    if (defined(titleOptions) && titleOptions.visible) {
      var labelTemplate = getTemplate(titleOptions);
      if (labelTemplate) {
        text = labelTemplate({ text });
      } else if (titleOptions.format) {
        text = this.chartService.format.auto(titleOptions.format, text);
      }
    }
    this.title = new text_box_default(text, titleOptions);
    this.createTitleLayout();
    this.appendTitleLayoutContent();
  };
  Legend3.prototype.createTitleLayout = function createTitleLayout() {
    this.layout = new float_element_default({
      vertical: true,
      wrap: false
    });
    this.container.append(this.layout);
  };
  Legend3.prototype.hasTitle = function hasTitle() {
    return Boolean(this.options.title && this.options.title.visible !== false && this.options.title.text);
  };
  Legend3.prototype.appendTitleLayoutContent = function appendTitleLayoutContent() {
    var options = this.options;
    if (options.title.position === BOTTOM) {
      this.layout.append(this.itemsContainer);
      this.layout.append(this.title);
    } else {
      this.layout.append(this.title);
      this.layout.append(this.itemsContainer);
    }
  };
  return Legend3;
}(chart_element_default);
setDefaultOptions(Legend, {
  position: RIGHT,
  data: [],
  offsetX: 0,
  offsetY: 0,
  margin: getSpacing(2),
  padding: getSpacing(5),
  border: {
    color: BLACK,
    width: 0
  },
  item: {
    cursor: POINTER,
    spacing: 6
  },
  spacing: 6,
  background: "",
  zIndex: 1,
  markers: {},
  line: {
    width: 20,
    height: 2,
    cursor: POINTER,
    opacity: 1
  },
  area: {
    type: SQUARE,
    align: RIGHT,
    width: 15,
    height: 15
  }
});
var legend_default = Legend;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-factory.js
var PlotAreaFactory = function(Class) {
  function PlotAreaFactory2() {
    Class.call(this);
    this._registry = [];
  }
  if (Class) PlotAreaFactory2.__proto__ = Class;
  PlotAreaFactory2.prototype = Object.create(Class && Class.prototype);
  PlotAreaFactory2.prototype.constructor = PlotAreaFactory2;
  PlotAreaFactory2.prototype.register = function register4(type, seriesTypes) {
    this._registry.push({
      type,
      seriesTypes
    });
  };
  PlotAreaFactory2.prototype.create = function create2(srcSeries, options, chartService) {
    var registry2 = this._registry;
    var match = registry2[0];
    var series;
    for (var idx = 0; idx < registry2.length; idx++) {
      var entry = registry2[idx];
      series = filterSeriesByType(srcSeries, entry.seriesTypes);
      var trendlines = filterSeriesByType(srcSeries, TRENDLINE_SERIES);
      if (series.length - trendlines.length > 0) {
        match = entry;
        break;
      }
    }
    return new match.type(series, options, chartService);
  };
  return PlotAreaFactory2;
}(class_default);
PlotAreaFactory.current = new PlotAreaFactory();
var plotarea_factory_default = PlotAreaFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/selection.js
var ZOOM_ACCELERATION = 3;
var SELECTOR_HEIGHT_ADJUST = 0.1;
function createDiv(classNames) {
  var element = document.createElement("div");
  if (classNames) {
    element.className = classNames;
  }
  return element;
}
function closestHandle(element) {
  var current4 = element;
  while (current4 && !hasClasses(current4, "k-handle")) {
    current4 = current4.parentNode;
  }
  return current4;
}
var Selection = function(Class) {
  function Selection2(chart, categoryAxis, options, observer) {
    Class.call(this);
    var chartElement = chart.element;
    this.options = deepExtend({}, this.options, options);
    this.chart = chart;
    this.observer = observer;
    this.chartElement = chartElement;
    this.categoryAxis = categoryAxis;
    this._dateAxis = this.categoryAxis instanceof date_category_axis_default;
    this.initOptions();
    this.visible = this.options.visible && chartElement.offsetHeight;
    if (this.visible) {
      this.createElements();
      this.set(this._index(this.options.from), this._index(this.options.to));
      this.bindEvents();
    }
  }
  if (Class) Selection2.__proto__ = Class;
  Selection2.prototype = Object.create(Class && Class.prototype);
  Selection2.prototype.constructor = Selection2;
  Selection2.prototype.onPane = function onPane(pane) {
    return this.categoryAxis.pane === pane;
  };
  Selection2.prototype.createElements = function createElements() {
    var options = this.options;
    var wrapper2 = this.wrapper = createDiv("k-selector k-pointer-events-none");
    elementStyles(wrapper2, {
      top: options.offset.top,
      left: options.offset.left,
      width: options.width,
      height: options.height,
      direction: "ltr"
    });
    var selection = this.selection = createDiv("k-selection k-pointer-events-none");
    this.leftMask = createDiv("k-mask k-pointer-events-none");
    this.rightMask = createDiv("k-mask k-pointer-events-none");
    wrapper2.appendChild(this.leftMask);
    wrapper2.appendChild(this.rightMask);
    wrapper2.appendChild(selection);
    var body = this.body = createDiv("k-selection-bg k-pointer-events-none");
    selection.appendChild(body);
    var leftHandle = this.leftHandle = createDiv("k-handle k-left-handle k-pointer-events-auto");
    var rightHandle = this.rightHandle = createDiv("k-handle k-right-handle k-pointer-events-auto");
    leftHandle.appendChild(createDiv());
    rightHandle.appendChild(createDiv());
    selection.appendChild(leftHandle);
    selection.appendChild(rightHandle);
    this.chartElement.appendChild(wrapper2);
    var selectionStyles = elementStyles(selection, ["borderLeftWidth", "borderRightWidth", "height"]);
    var leftHandleHeight = elementStyles(leftHandle, "height").height;
    var rightHandleHeight = elementStyles(rightHandle, "height").height;
    options.selection = {
      border: {
        left: selectionStyles.borderLeftWidth,
        right: selectionStyles.borderRightWidth
      }
    };
    elementStyles(leftHandle, {
      top: (selectionStyles.height - leftHandleHeight) / 2
    });
    elementStyles(rightHandle, {
      top: (selectionStyles.height - rightHandleHeight) / 2
    });
    wrapper2.style.cssText = wrapper2.style.cssText;
  };
  Selection2.prototype.bindEvents = function bindEvents$1() {
    var obj;
    if (this.options.mousewheel !== false) {
      this._mousewheelHandler = this._mousewheel.bind(this);
      bindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
    }
    this._domEvents = dom_events_builder_default.create(this.chartElement, {
      stopPropagation: true,
      // applicable for the jQuery UserEvents
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      press: this._press.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
  };
  Selection2.prototype.initOptions = function initOptions() {
    var ref2 = this;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var box = categoryAxis.pane.chartsBox();
    var intlService = this.chart.chartService.intl;
    if (this._dateAxis) {
      deepExtend(options, {
        min: parseDate(intlService, options.min),
        max: parseDate(intlService, options.max),
        from: parseDate(intlService, options.from),
        to: parseDate(intlService, options.to)
      });
    }
    var ref$1 = elementStyles(this.chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref$1.paddingLeft;
    var paddingTop = ref$1.paddingTop;
    this.options = deepExtend({}, {
      width: box.width(),
      height: box.height() + SELECTOR_HEIGHT_ADJUST,
      //workaround for sub-pixel hover on the paths in chrome
      padding: {
        left: paddingLeft,
        top: paddingTop
      },
      offset: {
        left: box.x1 + paddingLeft,
        top: box.y1 + paddingTop
      },
      from: options.min,
      to: options.max
    }, options);
  };
  Selection2.prototype.destroy = function destroy() {
    var obj;
    if (this._domEvents) {
      this._domEvents.destroy();
      delete this._domEvents;
    }
    clearTimeout(this._mwTimeout);
    this._state = null;
    if (this.wrapper) {
      if (this._mousewheelHandler) {
        unbindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
        this._mousewheelHandler = null;
      }
      this.chartElement.removeChild(this.wrapper);
      this.wrapper = null;
    }
  };
  Selection2.prototype._rangeEventArgs = function _rangeEventArgs(range) {
    return {
      axis: this.categoryAxis.options,
      from: this._value(range.from),
      to: this._value(range.to)
    };
  };
  Selection2.prototype._pointInPane = function _pointInPane(x5, y) {
    var paneBox = this.categoryAxis.pane.box;
    var modelCoords = this.chart._toModelCoordinates(x5, y);
    return paneBox.containsPoint(modelCoords);
  };
  Selection2.prototype._start = function _start(e39) {
    var options = this.options;
    var target = eventElement(e39);
    if (this._state || !target) {
      return;
    }
    var coords = eventCoordinates(e39);
    var inPane = this._pointInPane(coords.x, coords.y);
    if (!inPane) {
      return;
    }
    var handle = closestHandle(target);
    var bodyRect = this.body.getBoundingClientRect();
    var inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;
    this.chart._unsetActivePoint();
    this._state = {
      moveTarget: handle,
      startLocation: e39.x ? e39.x.location : 0,
      inBody,
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    var args = this._rangeEventArgs({
      from: this._index(options.from),
      to: this._index(options.to)
    });
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    }
  };
  Selection2.prototype._press = function _press(e39) {
    var handle;
    if (this._state) {
      handle = this._state.moveTarget;
    } else {
      handle = closestHandle(eventElement(e39));
    }
    if (handle) {
      addClass(handle, "k-handle-active");
    }
  };
  Selection2.prototype._move = function _move(e39) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var state = ref2._state;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var target = state.moveTarget;
    var reverse = categoryAxis.options.reverse;
    var from = this._index(options.from);
    var to = this._index(options.to);
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var delta = state.startLocation - e39.x.location;
    var oldRange = { from: range.from, to: range.to };
    var span = range.to - range.from;
    var scale = elementStyles(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);
    var offset = Math.round(delta / scale) * (reverse ? -1 : 1);
    if (!target && !state.inBody) {
      return;
    }
    var leftHandle = target && hasClasses(target, "k-left-handle");
    var rightHandle = target && hasClasses(target, "k-right-handle");
    if (state.inBody) {
      range.from = Math.min(
        Math.max(min4, from - offset),
        max3 - span
      );
      range.to = Math.min(
        range.from + span,
        max3
      );
    } else if (leftHandle && !reverse || rightHandle && reverse) {
      range.from = Math.min(
        Math.max(min4, from - offset),
        max3 - 1
      );
      range.to = Math.max(range.from + 1, range.to);
    } else if (leftHandle && reverse || rightHandle && !reverse) {
      range.to = Math.min(
        Math.max(min4 + 1, to - offset),
        max3
      );
      range.from = Math.min(range.to - 1, range.from);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.move(range.from, range.to);
      this.trigger(SELECT2, this._rangeEventArgs(range));
    }
  };
  Selection2.prototype._end = function _end() {
    if (this._state) {
      var moveTarget = this._state.moveTarget;
      if (moveTarget) {
        removeClass(moveTarget, "k-handle-active");
      }
      var range = this._state.range;
      this.set(range.from, range.to);
      this.trigger(SELECT_END, this._rangeEventArgs(range));
      delete this._state;
    }
  };
  Selection2.prototype._tap = function _tap(e39) {
    var ref2 = this;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var coords = this.chart._eventCoordinates(e39);
    var categoryIx = categoryAxis.pointCategoryIndex(new point_default(coords.x, categoryAxis.box.y1));
    var from = this._index(options.from);
    var to = this._index(options.to);
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var span = to - from;
    var mid = from + span / 2;
    var range = {};
    var rightClick = e39.event.which === 3;
    var offset = Math.round(mid - categoryIx);
    if (this._state || rightClick) {
      return;
    }
    this.chart._unsetActivePoint();
    if (!categoryAxis.options.justified) {
      offset--;
    }
    range.from = Math.min(
      Math.max(min4, from - offset),
      max3 - span
    );
    range.to = Math.min(range.from + span, max3);
    this._start(e39);
    if (this._state) {
      this._state.range = range;
      this.trigger(SELECT2, this._rangeEventArgs(range));
      this._end();
    }
  };
  Selection2.prototype._mousewheel = function _mousewheel(e39) {
    var this$1 = this;
    var delta = mousewheelDelta(e39);
    this._start(e39);
    if (this._state) {
      var range = this._state.range;
      e39.preventDefault();
      e39.stopPropagation();
      if (Math.abs(delta) > 1) {
        delta *= ZOOM_ACCELERATION;
      }
      if (this.options.mousewheel.reverse) {
        delta *= -1;
      }
      if (this.expand(delta)) {
        this.trigger(SELECT2, {
          axis: this.categoryAxis.options,
          delta,
          originalEvent: e39,
          from: this._value(range.from),
          to: this._value(range.to)
        });
      }
      if (this._mwTimeout) {
        clearTimeout(this._mwTimeout);
      }
      this._mwTimeout = setTimeout(function() {
        this$1._end();
      }, MOUSEWHEEL_DELAY);
    }
  };
  Selection2.prototype._gesturestart = function _gesturestart(e39) {
    var options = this.options;
    var touch = e39.touches[0];
    var inPane = this._pointInPane(touch.pageX, touch.pageY);
    if (!inPane) {
      return;
    }
    this._state = {
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    var args = this._rangeEventArgs(this._state.range);
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    } else {
      e39.preventDefault();
    }
  };
  Selection2.prototype._gestureend = function _gestureend() {
    if (this._state) {
      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));
      delete this._state;
    }
  };
  Selection2.prototype._gesturechange = function _gesturechange(e39) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var chart = ref2.chart;
    var state = ref2._state;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var p0 = chart._toModelCoordinates(e39.touches[0].x.location).x;
    var p1 = chart._toModelCoordinates(e39.touches[1].x.location).x;
    var left = Math.min(p0, p1);
    var right = Math.max(p0, p1);
    e39.preventDefault();
    range.from = categoryAxis.pointCategoryIndex(new point_default(left)) || options.min;
    range.to = categoryAxis.pointCategoryIndex(new point_default(right)) || options.max;
    this.move(range.from, range.to);
    this.trigger(SELECT2, this._rangeEventArgs(range));
  };
  Selection2.prototype._index = function _index(value2) {
    var index = value2;
    if (value2 instanceof Date) {
      index = this.categoryAxis.categoryIndex(value2);
    }
    return index;
  };
  Selection2.prototype._value = function _value(index) {
    var value2 = index;
    if (this._dateAxis) {
      value2 = this.categoryAxis.categoryAt(index);
      if (value2 > this.options.max) {
        value2 = this.options.max;
      }
    }
    return value2;
  };
  Selection2.prototype._slot = function _slot(value2) {
    var categoryAxis = this.categoryAxis;
    var index = this._index(value2);
    return categoryAxis.getSlot(index, index, true);
  };
  Selection2.prototype.move = function move(from, to) {
    var options = this.options;
    var reverse = this.categoryAxis.options.reverse;
    var offset = options.offset;
    var padding = options.padding;
    var border = options.selection.border;
    var left = reverse ? to : from;
    var right = reverse ? from : to;
    var edge = "x" + (reverse ? 2 : 1);
    var box = this._slot(left);
    var leftMaskWidth = round(box[edge] - offset.left + padding.left);
    elementStyles(this.leftMask, {
      width: leftMaskWidth
    });
    elementStyles(this.selection, {
      left: leftMaskWidth
    });
    box = this._slot(right);
    var rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));
    elementStyles(this.rightMask, {
      width: rightMaskWidth
    });
    var distance = options.width - rightMaskWidth;
    if (distance !== options.width) {
      distance += border.right;
    }
    elementStyles(this.rightMask, {
      left: distance
    });
    elementStyles(this.selection, {
      width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)
    });
  };
  Selection2.prototype.set = function set3(from, to) {
    var options = this.options;
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var fromValue = limitValue(this._index(from), min4, max3);
    var toValue = limitValue(this._index(to), fromValue + 1, max3);
    if (options.visible) {
      this.move(fromValue, toValue);
    }
    options.from = this._value(fromValue);
    options.to = this._value(toValue);
  };
  Selection2.prototype.expand = function expand(delta) {
    var options = this.options;
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var zDir = options.mousewheel.zoom;
    var from = this._index(options.from);
    var to = this._index(options.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    if (this._state) {
      range = this._state.range;
    }
    if (zDir !== RIGHT) {
      range.from = limitValue(
        limitValue(from - delta, 0, to - 1),
        min4,
        max3
      );
    }
    if (zDir !== LEFT) {
      range.to = limitValue(
        limitValue(to + delta, range.from + 1, max3),
        min4,
        max3
      );
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.zoom = function zoom(delta, coords) {
    var options = this.options;
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var from = this._index(options.from);
    var to = this._index(options.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    var ref2 = this.categoryAxis.options;
    var reverse = ref2.reverse;
    var origin = X + (reverse ? "2" : "1");
    var lineBox = this.categoryAxis.lineBox();
    var relative = Math.abs(lineBox[origin] - coords[X]);
    var size = lineBox.width();
    var position = round(relative / size, 2);
    var minDelta = round(position * delta);
    var maxDelta = round((1 - position) * delta);
    if (this._state) {
      range = this._state.range;
    }
    range.from = limitValue(
      limitValue(from - minDelta, 0, to - 1),
      min4,
      max3
    );
    range.to = limitValue(
      limitValue(to + maxDelta, range.from + 1, max3),
      min4,
      max3
    );
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.trigger = function trigger2(name2, args) {
    return (this.observer || this.chart).trigger(name2, args);
  };
  return Selection2;
}(class_default);
setDefaultOptions(Selection, {
  visible: true,
  mousewheel: {
    zoom: "both"
  },
  min: MIN_VALUE,
  max: MAX_VALUE
});
var selection_default = Selection;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/tooltip.js
var Tooltip = function(BaseTooltip2) {
  function Tooltip3() {
    BaseTooltip2.apply(this, arguments);
  }
  if (BaseTooltip2) Tooltip3.__proto__ = BaseTooltip2;
  Tooltip3.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  Tooltip3.prototype.show = function show2(point) {
    if (!point || !point.tooltipAnchor || this._current && this._current === point) {
      return;
    }
    var options = deepExtend({}, this.options, point.options.tooltip);
    var anchor = point.tooltipAnchor();
    if (anchor) {
      this._current = point;
      BaseTooltip2.prototype.show.call(this, {
        point,
        anchor
      }, options, point);
    } else {
      this.hide();
    }
  };
  Tooltip3.prototype.hide = function hide2() {
    delete this._current;
    BaseTooltip2.prototype.hide.call(this);
  };
  return Tooltip3;
}(base_tooltip_default);
var tooltip_default = Tooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/shared-tooltip.js
var SharedTooltip = function(BaseTooltip2) {
  function SharedTooltip3(plotArea, options) {
    BaseTooltip2.call(this, plotArea.chartService, options);
    this.plotArea = plotArea;
    this.formatService = plotArea.chartService.format;
  }
  if (BaseTooltip2) SharedTooltip3.__proto__ = BaseTooltip2;
  SharedTooltip3.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype.showAt = function showAt(points, coords) {
    var tooltipPoints = grep(points, function(point2) {
      var tooltip = point2.series.tooltip;
      var excluded = tooltip && tooltip.visible === false;
      return !excluded;
    });
    if (tooltipPoints.length > 0) {
      var point = tooltipPoints[0];
      var slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);
      var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);
      this.show({
        anchor,
        shared: true,
        points,
        category: point.category,
        categoryText: this.formatService.auto(this.options.categoryFormat, point.category),
        series: this.plotArea.series
      }, this.options);
    }
  };
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(point, slot) {
    var axis = this.plotArea.categoryAxis;
    var align = {
      horizontal: "left",
      vertical: "center"
    };
    if (!axis.options.vertical) {
      point.x = slot.center().x;
    }
    return {
      point,
      align
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point, slot) {
    var box = point.owner.pane.chartsBox();
    var vertical = this.plotArea.categoryAxis.options.vertical;
    var center = box.center();
    var slotCenter = slot.center();
    var align = {
      horizontal: "center",
      vertical: "center"
    };
    var centerPoint;
    if (vertical) {
      centerPoint = new point_default(center.x, slotCenter.y);
    } else {
      centerPoint = new point_default(slotCenter.x, center.y);
    }
    return {
      point: centerPoint,
      align
    };
  };
  return SharedTooltip3;
}(base_tooltip_default);
setDefaultOptions(SharedTooltip, {
  categoryFormat: "{0:d}"
});
var shared_tooltip_default = SharedTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bar-chart-animation.js
var BarChartAnimation = function(superclass) {
  function BarChartAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) BarChartAnimation2.__proto__ = superclass;
  BarChartAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarChartAnimation2.prototype.constructor = BarChartAnimation2;
  BarChartAnimation2.prototype.setup = function setup() {
    var ref2 = this;
    var element = ref2.element;
    var options = ref2.options;
    var bbox = element.bbox();
    if (bbox) {
      this.origin = options.origin;
      var axis = options.vertical ? Y : X;
      var fromScale = this.fromScale = new geometry_exports.Point(1, 1);
      fromScale[axis] = START_SCALE;
      element.transform(
        geometry_exports.transform().scale(fromScale.x, fromScale.y)
      );
    } else {
      this.abort();
    }
  };
  BarChartAnimation2.prototype.step = function step(pos) {
    var scaleX = interpolateValue(this.fromScale.x, 1, pos);
    var scaleY = interpolateValue(this.fromScale.y, 1, pos);
    this.element.transform(
      geometry_exports.transform().scale(scaleX, scaleY, this.origin)
    );
  };
  BarChartAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    this.element.transform(null);
  };
  return BarChartAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarChartAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(BAR, BarChartAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bubble-animation.js
var BubbleAnimation = function(superclass) {
  function BubbleAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) BubbleAnimation2.__proto__ = superclass;
  BubbleAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BubbleAnimation2.prototype.constructor = BubbleAnimation2;
  BubbleAnimation2.prototype.setup = function setup() {
    var center = this.center = this.element.bbox().center();
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, center)
    );
  };
  BubbleAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.center)
    );
  };
  return BubbleAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BubbleAnimation, {
  easing: "easeOutElastic"
});
drawing_exports.AnimationFactory.current.register(BUBBLE, BubbleAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/fade-in-animation.js
var FadeInAnimation = function(superclass) {
  function FadeInAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) FadeInAnimation2.__proto__ = superclass;
  FadeInAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeInAnimation2.prototype.constructor = FadeInAnimation2;
  FadeInAnimation2.prototype.setup = function setup() {
    this.fadeTo = this.element.opacity();
    this.element.opacity(0);
  };
  FadeInAnimation2.prototype.step = function step(pos) {
    this.element.opacity(pos * this.fadeTo);
  };
  return FadeInAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(FadeInAnimation, {
  duration: 200,
  easing: "linear"
});
drawing_exports.AnimationFactory.current.register(FADEIN, FadeInAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/pie-animation.js
var PieAnimation = function(superclass) {
  function PieAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) PieAnimation2.__proto__ = superclass;
  PieAnimation2.prototype = Object.create(superclass && superclass.prototype);
  PieAnimation2.prototype.constructor = PieAnimation2;
  PieAnimation2.prototype.setup = function setup() {
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, this.options.center)
    );
  };
  PieAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.options.center)
    );
  };
  return PieAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(PieAnimation, {
  easing: "easeOutElastic",
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(PIE, PieAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-line-chart.js
var ScatterLineChart = function(ScatterChart2) {
  function ScatterLineChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2) ScatterLineChart2.__proto__ = ScatterChart2;
  ScatterLineChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  ScatterLineChart2.prototype.constructor = ScatterLineChart2;
  ScatterLineChart2.prototype.render = function render() {
    ScatterChart2.prototype.render.call(this);
    this.renderSegments();
  };
  ScatterLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  ScatterLineChart2.prototype.animationPoints = function animationPoints() {
    var points = ScatterChart2.prototype.animationPoints.call(this);
    return points.concat(this._segments);
  };
  ScatterLineChart2.prototype.createMissingValue = function createMissingValue(value2, missingValues) {
    if (missingValues === ZERO) {
      var missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (!hasValue(missingValue.x)) {
        missingValue.x = 0;
      }
      if (!hasValue(missingValue.y)) {
        missingValue.y = 0;
      }
      return missingValue;
    }
  };
  return ScatterLineChart2;
}(scatter_chart_default);
deepExtend(ScatterLineChart.prototype, line_chart_mixin_default);
var scatter_line_chart_default = ScatterLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-scatter-trendline-data.js
function getScatterTrendlineData(valueMapper, range, options) {
  var data = [];
  var xMin = range.xMin;
  var xMax = range.xMax;
  var forecast = (options || {}).forecast;
  if (forecast) {
    if (forecast.before > 0) {
      xMin -= forecast.before;
    }
    if (forecast.after > 0) {
      xMax += forecast.after;
    }
  }
  var samplingInterval = (options || {}).samplingInterval;
  var delta = valueOrDefault(samplingInterval, autoMajorUnit(xMin, xMax) / 10);
  if (samplingInterval <= 0) {
    delta = xMax - xMin;
  }
  for (var x5 = xMin; x5 <= xMax; x5 += delta) {
    data.push([
      x5,
      valueMapper(x5)
    ]);
  }
  return data;
}
var get_scatter_trendline_data_default = getScatterTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-exponential-trendline.js
function scatterExponentialTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData7({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter7 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: valueFields.x, yValue: Math.log(valueFields[fieldName]) };
    ;
  };
};
function getData7(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter7(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = { xMin, xMax };
  if (count > 0) {
    var a38 = Math.exp(intercept);
    var b2 = slope;
    return get_scatter_trendline_data_default(function(x5) {
      return a38 * Math.exp(b2 * x5);
    }, range, options.trendline);
  }
  return null;
}
var scatter_exponential_trendline_default = scatterExponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-value-getter.js
var scatterValueGetter = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: valueFields.x, yValue: valueFields[fieldName] };
    ;
  };
};
var scatter_value_getter_default = scatterValueGetter;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-linear-trendline.js
function scatterLinearTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData8({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData8(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var ref$1 = calculate_slope_default(seriesValues(), scatter_value_getter_default(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = { xMin, xMax };
  if (count > 0) {
    return get_scatter_trendline_data_default(function(x5) {
      return slope * x5 + intercept;
    }, range, options.trendline);
  }
  return null;
}
var scatter_linear_trendline_default = scatterLinearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/x-value-limits.js
function xValueLimits(sourceValues, valueGetter10) {
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  for (var i36 = 0; i36 < sourceValues.length; i36++) {
    var value2 = sourceValues[i36];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
    }
  }
  return { xMin, xMax };
}
var x_value_limits_default = xValueLimits;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-logarithmic-trendline.js
function scatterLogarithmicTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData9({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter8 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: valueFields.x, yValue: valueFields[fieldName] };
    ;
  };
};
var logValueGetter = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(valueFields.x), yValue: valueFields[fieldName] };
    ;
  };
};
function getData9(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, logValueGetter(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var range = x_value_limits_default(sourceValues, valueGetter8(options.field));
  if (count > 0) {
    var a38 = slope;
    var b2 = intercept;
    return get_scatter_trendline_data_default(function(x5) {
      return a38 * Math.log(x5) + b2;
    }, range, options.trendline);
  }
  return null;
}
var scatter_logarithmic_trendline_default = scatterLogarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-moving-average.js
function scatterMovingAverageTrendline(context) {
  var options = context.options;
  var data = getData10(context);
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData10(ref2) {
  var options = ref2.options;
  var seriesValues = ref2.seriesValues;
  var period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  var range = { before: period, after: period };
  var data = calculate_moving_average_default(seriesValues(range), scatter_value_getter_default(options.field), period);
  if (data.length > 0) {
    return data;
  }
  return null;
}
var scatter_moving_average_default = scatterMovingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-polynomial-trendline.js
function scatterPolynomialTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData11({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData11(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var order = (options.trendline || {}).order;
  var valueGetter10 = scatter_value_getter_default(options.field);
  var ref$1 = calculate_polynomial_default(seriesValues(), valueGetter10, order);
  var count = ref$1.count;
  var valueMapper = ref$1.valueMapper;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = { xMin, xMax };
  if (count > 0) {
    return get_scatter_trendline_data_default(valueMapper, range, options.trendline);
  }
  return null;
}
var scatter_polynomial_trendline_default = scatterPolynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-power-trendline.js
function scatterPowerTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData12({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter9 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return { xValue: Math.log(valueFields.x), yValue: Math.log(valueFields[fieldName]) };
    ;
  };
};
function getData12(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter9(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var range = x_value_limits_default(sourceValues, scatter_value_getter_default(options.field));
  if (count > 0) {
    var a38 = Math.exp(intercept);
    var b2 = slope;
    return get_scatter_trendline_data_default(function(x5) {
      return a38 * Math.pow(x5, b2);
    }, range, options.trendline);
  }
  return null;
}
var scatter_power_trendline_default = scatterPowerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-trendline-registry.js
var scatterRegistry = {};
scatterRegistry[TRENDLINE_EXPONENTIAL] = scatter_exponential_trendline_default;
scatterRegistry[TRENDLINE_LINEAR] = scatter_linear_trendline_default;
scatterRegistry[TRENDLINE_LOGARITHMIC] = scatter_logarithmic_trendline_default;
scatterRegistry[TRENDLINE_MOVING_AVERAGE] = scatter_moving_average_default;
scatterRegistry[TRENDLINE_POLYNOMIAL] = scatter_polynomial_trendline_default;
scatterRegistry[TRENDLINE_POWER] = scatter_power_trendline_default;
var scatter_trendline_registry_default = scatterRegistry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/xy-plotarea.js
var XYPlotArea = function(PlotAreaBase2) {
  function XYPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) XYPlotArea2.__proto__ = PlotAreaBase2;
  XYPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  XYPlotArea2.prototype.constructor = XYPlotArea2;
  XYPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
    this.xAxisRangeTracker = new axis_group_range_tracker_default();
    this.yAxisRangeTracker = new axis_group_range_tracker_default();
  };
  XYPlotArea2.prototype.render = function render(panes) {
    var this$1 = this;
    if (panes === void 0) panes = this.panes;
    this.series = [].concat(this.originalSeries);
    this.createTrendlineSeries();
    var seriesByPane = this.groupSeriesByPane();
    for (var i36 = 0; i36 < panes.length; i36++) {
      var pane = panes[i36];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createScatterChart(
        filterSeriesByType(filteredSeries, SCATTER),
        pane
      );
      this$1.createScatterLineChart(
        filterSeriesByType(filteredSeries, SCATTER_LINE),
        pane
      );
      this$1.createBubbleChart(
        filterSeriesByType(filteredSeries, BUBBLE),
        pane
      );
    }
    this.createAxes(panes);
  };
  XYPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.xAxisRangeTracker.update(chart.xAxisRanges);
    this.yAxisRangeTracker.update(chart.yAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  XYPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      this.yAxisRangeTracker.reset(axisName);
      delete this.namedYAxes[axisName];
    } else {
      this.xAxisRangeTracker.reset(axisName);
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  XYPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options.xAxis);
    var xAxis = grep(xAxisOptions, function(a38) {
      return a38.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options.yAxis);
    var yAxis = grep(yAxisOptions, function(a38) {
      return a38.name === yAxisName;
    })[0];
    var panes = options.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  XYPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createScatterLineChart = function createScatterLineChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_line_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createBubbleChart = function createBubbleChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new bubble_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createXYAxis = function createXYAxis(options, vertical, axisIndex) {
    var axisName = options.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;
    var axisOptions2 = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical });
    var isLog = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC);
    var defaultRange = tracker.query();
    var defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
    var range = tracker.query(axisName) || defaultRange || defaultAxisRange;
    var typeSamples = [axisOptions2.min, axisOptions2.max];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    if (axisIndex === 0 && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var inferredDate;
    for (var i36 = 0; i36 < typeSamples.length; i36++) {
      if (typeSamples[i36] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_value_axis_default;
    } else if (isLog) {
      axisType = logarithmic_axis_default;
    } else {
      axisType = numeric_axis_default;
    }
    var axis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    return axis;
  };
  XYPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options = this.options;
    var xAxesOptions = [].concat(options.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  XYPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e39, eventType) {
    var coords = chart._eventCoordinates(e39);
    var point = new point_default(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i36 = 0; i36 < length; i36++) {
      var axis = allAxes[i36];
      var values5 = axis.options.vertical ? yValues : xValues;
      var currentValue = axis.getValue(point);
      if (currentValue !== null) {
        values5.push(currentValue);
      }
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e39),
        originalEvent: e39,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  XYPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions2(this.options, index, vertical, options);
    updateAxisOptions2(this.originalOptions, index, vertical, options);
  };
  XYPlotArea2.prototype.trendlineFactory = function trendlineFactory$1(options, series) {
    var seriesValues = this.seriesValues.bind(this, series.index);
    var trendline = trendline_factory_default(scatter_trendline_registry_default, options.type, {
      options,
      seriesValues
    });
    if (trendline) {
      trendline.xAxis = series.xAxis;
      trendline.yAxis = series.yAxis;
    }
    return trendline;
  };
  XYPlotArea2.prototype.seriesValues = function seriesValues(seriesIx) {
    var this$1 = this;
    var result = [];
    var currentSeries = this.series[seriesIx];
    for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
      var data = this$1.bindPoint(currentSeries, pointIx);
      result.push({ pointIx, valueFields: data.valueFields });
    }
    return result;
  };
  return XYPlotArea2;
}(plotarea_base_default);
function updateAxisOptions2(targetOptions, axisIndex, vertical, options) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(XYPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(XYPlotArea.prototype, plotarea_events_mixin_default);
var xy_plotarea_default = XYPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-segment.js
var PieSegment = function(ChartElement2) {
  function PieSegment2(value2, sector, options) {
    ChartElement2.call(this, options);
    this.value = value2;
    this.sector = sector;
  }
  if (ChartElement2) PieSegment2.__proto__ = ChartElement2;
  PieSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieSegment2.prototype.constructor = PieSegment2;
  PieSegment2.prototype.render = function render() {
    if (this._rendered || this.visible === false) {
      return;
    }
    this._rendered = true;
    this.createLabel();
  };
  PieSegment2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var chartService = this.owner.chartService;
    var labelText = this.getLabelText(labels);
    if (labels.visible && (labelText || labelText === 0)) {
      if (labels.position === CENTER || labels.position === INSIDE_END) {
        if (!labels.color) {
          labels.color = auto_text_color_default(this.options.color);
        }
        if (!labels.background) {
          labels.background = this.options.color;
        }
      } else {
        var themeLabels = chartService.theme.seriesDefaults.labels;
        labels.color = labels.color || themeLabels.color;
        labels.background = labels.background || themeLabels.background;
      }
      this.label = new text_box_default(labelText, deepExtend({}, labels, {
        align: CENTER,
        vAlign: "",
        animation: {
          type: FADEIN,
          delay: this.animationDelay
        }
      }), this.pointData());
      this.append(this.label);
    }
  };
  PieSegment2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.owner.chartService.format.auto(options.format, this.value);
  };
  PieSegment2.prototype.reflow = function reflow(targetBox) {
    this.render();
    this.box = targetBox;
    this.reflowLabel();
  };
  PieSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var labelsDistance = labelsOptions.distance;
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      var labelWidth = label.box.width();
      var lp;
      if (labelsOptions.position === CENTER) {
        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else if (labelsOptions.position === INSIDE_END) {
        sector.radius = sector.radius - labelHeight / 2;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        var x1;
        lp = sector.clone().expand(labelsDistance).point(angle);
        if (lp.x >= sector.center.x) {
          x1 = lp.x + labelWidth;
          label.orientation = RIGHT;
        } else {
          x1 = lp.x - labelWidth;
          label.orientation = LEFT;
        }
        label.reflow(new box_default(x1, lp.y - labelHeight, lp.x, lp.y));
      }
    }
  };
  PieSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var sector = ref2.sector;
    var options = ref2.options;
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    if (this.value) {
      if (options.visual) {
        var startAngle = (sector.startAngle + 180) % 360;
        var visual = options.visual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          series: this.series,
          percentage: this.percentage,
          center: new geometry_exports.Point(sector.center.x, sector.center.y),
          radius: sector.radius,
          innerRadius: sector.innerRadius,
          startAngle,
          endAngle: startAngle + sector.angle,
          options,
          sender: this.getSender(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createSegmentVisual(group);
            return group;
          }
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else {
        this.createSegmentVisual(this.visual);
      }
    }
  };
  PieSegment2.prototype.createSegmentVisual = function createSegmentVisual(group) {
    var ref2 = this;
    var sector = ref2.sector;
    var options = ref2.options;
    var borderOptions = options.border || {};
    var border = borderOptions.width > 0 ? {
      stroke: {
        color: borderOptions.color,
        width: borderOptions.width,
        opacity: borderOptions.opacity,
        dashType: borderOptions.dashType
      }
    } : {};
    var color = options.color;
    var fill = createPatternFill(options.pattern, {
      color,
      opacity: options.opacity
    });
    var visual = this.createSegment(sector, deepExtend({
      fill,
      stroke: {
        opacity: options.opacity
      },
      zIndex: options.zIndex
    }, border));
    group.append(visual);
    if (hasGradientOverlay(options)) {
      group.append(this.createGradientOverlay(visual, {
        baseColor: color,
        fallbackFill: fill
      }, deepExtend({
        center: [sector.center.x, sector.center.y],
        innerRadius: sector.innerRadius,
        radius: sector.radius,
        userSpace: true
      }, options.overlay)));
    }
  };
  PieSegment2.prototype.createSegment = function createSegment(sector, options) {
    if (options.singleSegment) {
      return new drawing_exports.Circle(new geometry_exports.Circle(new geometry_exports.Point(sector.center.x, sector.center.y), sector.radius), options);
    }
    return shape_builder_default.current.createRing(sector, options);
  };
  PieSegment2.prototype.createAnimation = function createAnimation() {
    var ref2 = this;
    var options = ref2.options;
    var center = ref2.sector.center;
    deepExtend(options, {
      animation: {
        center: [center.x, center.y],
        delay: this.animationDelay
      }
    });
    ChartElement2.prototype.createAnimation.call(this);
  };
  PieSegment2.prototype.createHighlight = function createHighlight(options) {
    var highlight = this.options.highlight || {};
    var border = highlight.border || {};
    return this.createSegment(this.sector, deepExtend({}, options, {
      fill: {
        color: highlight.color,
        opacity: highlight.opacity
      },
      stroke: {
        opacity: border.opacity,
        width: border.width,
        color: border.color
      }
    }));
  };
  PieSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  PieSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var sector = this.sector;
    return {
      options: this.options,
      radius: sector.radius,
      innerRadius: sector.innerRadius,
      center: new geometry_exports.Point(sector.center.x, sector.center.y),
      startAngle: sector.startAngle,
      endAngle: sector.angle + sector.startAngle,
      visual: this.visual
    };
  };
  PieSegment2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = this.options.focusHighlight.border.width;
    var result = this.createSegment(this.sector, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    }));
    var clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(result.bbox()));
    clipPath.paths.push(this.createSegment(this.sector, {}));
    result.clip(clipPath);
    return result;
  };
  PieSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var sector = this.sector.clone().expand(TOOLTIP_OFFSET);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    return {
      point: midPoint,
      align: tooltipAlignment(midAndle + 180)
    };
  };
  PieSegment2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  PieSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  PieSegment2.prototype.getIndex = function getIndex() {
    return this.index;
  };
  return PieSegment2;
}(chart_element_default);
var RAD_30 = round(rad(30), DEFAULT_PRECISION);
var RAD_60 = round(rad(60), DEFAULT_PRECISION);
function tooltipAlignment(angle) {
  var radians = rad(angle);
  var sine = round(Math.sin(radians), DEFAULT_PRECISION);
  var cosine = round(Math.cos(radians), DEFAULT_PRECISION);
  var horizontal;
  if (Math.abs(sine) > RAD_60) {
    horizontal = CENTER;
  } else if (cosine < 0) {
    horizontal = RIGHT;
  } else {
    horizontal = LEFT;
  }
  var vertical;
  if (Math.abs(sine) < RAD_30) {
    vertical = CENTER;
  } else if (sine < 0) {
    vertical = BOTTOM;
  } else {
    vertical = TOP;
  }
  return {
    horizontal,
    vertical
  };
}
setDefaultOptions(PieSegment, {
  color: WHITE,
  overlay: {
    gradient: "roundedBevel"
  },
  border: {
    width: 0.5
  },
  labels: {
    visible: false,
    distance: 35,
    font: DEFAULT_FONT,
    margin: getSpacing(0.5),
    align: CIRCLE,
    zIndex: 1,
    position: OUTSIDE_END
  },
  animation: {
    type: PIE
  },
  highlight: {
    visible: true,
    border: {
      width: 1
    }
  },
  visible: true,
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(PieSegment.prototype, point_events_mixin_default);
deepExtend(PieSegment.prototype, accessibility_attributes_mixin_default);
var pie_segment_default = PieSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/pie-chart-mixin.js
var PieChartMixin = {
  createLegendItem: function(value2, point, options) {
    var legendOptions = this.options.legend || {};
    var labelsOptions = legendOptions.labels || {};
    var inactiveItems = legendOptions.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    if (options && options.visibleInLegend !== false) {
      var pointVisible = options.visible !== false;
      var labelTemplate = pointVisible ? getTemplate(labelsOptions) : getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);
      var text = options.category;
      if (labelTemplate) {
        text = labelTemplate({
          text,
          series: options.series,
          dataItem: options.dataItem,
          percentage: options.percentage,
          value: value2
        });
      }
      var itemLabelOptions, markerColor;
      if (pointVisible) {
        itemLabelOptions = {};
        markerColor = point.color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = (inactiveItems.markers || {}).color;
      }
      if (hasValue(text) && text !== "") {
        this.legendItems.push({
          active: pointVisible,
          pointIndex: options.index,
          text,
          series: options.series,
          markerColor,
          pattern: point.pattern,
          labels: itemLabelOptions
        });
      }
    }
  }
};
var pie_chart_mixin_default = PieChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js
var PIE_SECTOR_ANIM_DELAY = 70;
var PieChart = function(ChartElement2) {
  function PieChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2) PieChart2.__proto__ = ChartElement2;
  PieChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieChart2.prototype.constructor = PieChart2;
  PieChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  PieChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0) seriesColors = [];
    var colorsCount = seriesColors.length;
    var series = options.series;
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var data = currentSeries.data;
      var ref$1 = bindSegments(currentSeries);
      var total3 = ref$1.total;
      var points = ref$1.points;
      var count = ref$1.count;
      var anglePerValue = 360 / total3;
      var constantAngle = void 0;
      if (!isFinite(anglePerValue)) {
        constantAngle = 360 / count;
      }
      var currentAngle = void 0;
      if (defined(currentSeries.startAngle)) {
        currentAngle = currentSeries.startAngle;
      } else {
        currentAngle = options.startAngle;
      }
      if (seriesIx !== seriesCount - 1) {
        if (currentSeries.labels.position === OUTSIDE_END) {
          currentSeries.labels.position = CENTER;
        }
      }
      for (var i36 = 0; i36 < points.length; i36++) {
        var pointData = points[i36];
        if (!pointData) {
          continue;
        }
        var fields = pointData.fields;
        var value2 = pointData.value;
        var visible = pointData.visible;
        var angle = value2 !== 0 ? constantAngle || value2 * anglePerValue : 0;
        var explode = data.length !== 1 && Boolean(fields.explode);
        if (!isFunction(currentSeries.color)) {
          currentSeries.color = fields.color || seriesColors[i36 % colorsCount];
        }
        callback(value2, new ring_default(null, 0, 0, currentAngle, angle), {
          owner: this$1,
          category: defined(fields.category) ? fields.category : "",
          pattern: defined(fields.pattern) ? fields.pattern : currentSeries.pattern,
          index: i36,
          series: currentSeries,
          seriesIx,
          dataItem: data[i36],
          percentage: total3 !== 0 ? value2 / total3 : 0,
          explode,
          visibleInLegend: fields.visibleInLegend,
          visible,
          zIndex: seriesCount - seriesIx,
          animationDelay: this$1.animationDelay(i36, seriesIx, seriesCount)
        });
        if (visible !== false) {
          currentAngle += angle;
        }
      }
    }
  };
  PieChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options, value2, fields) {
    var series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      category: fields.category,
      percentage: fields.percentage
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "visual",
      "toggle",
      "ariaTemplate",
      "ariaContent"
    ] });
  };
  PieChart2.prototype.addValue = function addValue(value2, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    segmentOptions.pattern = fields.pattern || segmentOptions.pattern;
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new pie_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  PieChart2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var points = ref2.points;
    var seriesConfigs = ref2.seriesConfigs;
    if (seriesConfigs === void 0) seriesConfigs = [];
    var count = points.length;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var newBox = new box_default(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
    var newBoxCenter = newBox.center();
    var boxCenter = box.center();
    var seriesCount = options.series.length;
    var leftSideLabels = [];
    var rightSideLabels = [];
    var padding = valueOrDefault(options.padding, defaultPadding);
    this.targetBox = targetBox;
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);
    var radius = halfMinWidth - padding;
    var center = new point_default(
      radius + newBox.x1 + padding,
      radius + newBox.y1 + padding
    );
    for (var i36 = 0; i36 < count; i36++) {
      var segment = points[i36];
      var sector = segment.sector;
      var seriesIndex = segment.seriesIx;
      sector.radius = radius;
      sector.center = center;
      if (seriesConfigs.length) {
        var seriesConfig = seriesConfigs[seriesIndex];
        sector.innerRadius = seriesConfig.innerRadius;
        sector.radius = seriesConfig.radius;
      }
      if (seriesIndex === seriesCount - 1 && segment.explode) {
        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
      }
      segment.reflow(newBox);
      var label = segment.label;
      if (label) {
        if (label.options.position === OUTSIDE_END) {
          if (seriesIndex === seriesCount - 1) {
            if (label.orientation === RIGHT) {
              rightSideLabels.push(label);
            } else {
              leftSideLabels.push(label);
            }
          }
        }
      }
    }
    if (leftSideLabels.length > 0) {
      leftSideLabels.sort(this.labelComparator(true));
      this.leftLabelsReflow(leftSideLabels);
    }
    if (rightSideLabels.length > 0) {
      rightSideLabels.sort(this.labelComparator(false));
      this.rightLabelsReflow(rightSideLabels);
    }
    this.box = newBox;
  };
  PieChart2.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {
    var segment = last(this.points);
    var sector = segment.sector;
    var count = labels.length - 1;
    var lr = sector.radius + segment.options.labels.distance;
    var distances = [];
    var firstBox = labels[0].box;
    var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));
    distances.push(distance);
    for (var i36 = 0; i36 < count; i36++) {
      var secondBox = labels[i36 + 1].box;
      firstBox = labels[i36].box;
      distance = round(secondBox.y1 - firstBox.y2);
      distances.push(distance);
    }
    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
    distances.push(distance);
    return distances;
  };
  PieChart2.prototype.distributeLabels = function distributeLabels(distances, labels) {
    var this$1 = this;
    var count = distances.length;
    var left, right, remaining;
    for (var i36 = 0; i36 < count; i36++) {
      remaining = -distances[i36];
      left = right = i36;
      while (remaining > 0 && (left >= 0 || right < count)) {
        remaining = this$1._takeDistance(distances, i36, --left, remaining);
        remaining = this$1._takeDistance(distances, i36, ++right, remaining);
      }
    }
    this.reflowLabels(distances, labels);
  };
  PieChart2.prototype._takeDistance = function _takeDistance(distances, anchor, position, amount) {
    var result = amount;
    if (distances[position] > 0) {
      var available = Math.min(distances[position], result);
      result -= available;
      distances[position] -= available;
      distances[anchor] += available;
    }
    return result;
  };
  PieChart2.prototype.reflowLabels = function reflowLabels(distances, labels) {
    var this$1 = this;
    var segment = last(this.points);
    var sector = segment.sector;
    var labelOptions = segment.options.labels;
    var labelsCount = labels.length;
    var labelDistance = labelOptions.distance;
    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
    var boxX;
    distances[0] += 2;
    for (var i36 = 0; i36 < labelsCount; i36++) {
      var label = labels[i36];
      var box = label.box;
      boxY += distances[i36];
      boxX = this$1.hAlignLabel(
        box.x2,
        sector.clone().expand(labelDistance),
        boxY,
        boxY + box.height(),
        label.orientation === RIGHT
      );
      if (label.orientation === RIGHT) {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.radius + sector.center.x + labelDistance;
        }
        label.reflow(new box_default(boxX + box.width(), boxY, boxX, boxY));
      } else {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.center.x - sector.radius - labelDistance;
        }
        label.reflow(new box_default(boxX - box.width(), boxY, boxX, boxY));
      }
      boxY += box.height();
    }
  };
  PieChart2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var connectors = ref2.options.connectors;
    var points = ref2.points;
    var count = points.length;
    var space = 4;
    ChartElement2.prototype.createVisual.call(this);
    this._connectorLines = [];
    for (var i36 = 0; i36 < count; i36++) {
      var segment = points[i36];
      var sector = segment.sector;
      var label = segment.label;
      var angle = sector.middle();
      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;
      if (label) {
        var connectorLine = new drawing_exports.Path({
          stroke: {
            color: connectorsColor,
            width: connectors.width
          },
          animation: {
            type: FADEIN,
            delay: segment.animationDelay
          }
        });
        if (label.options.position === OUTSIDE_END) {
          var box = label.box;
          var centerPoint = sector.center;
          var start = sector.point(angle);
          var middle = new point_default(box.x1, box.center().y);
          var sr = void 0, end = void 0, crossing = void 0;
          start = sector.clone().expand(connectors.padding).point(angle);
          connectorLine.moveTo(start.x, start.y);
          if (label.orientation === RIGHT) {
            end = new point_default(box.x1 - connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x - space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.min(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
              sr = sector.center.x + sector.radius + space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr < middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x + space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          } else {
            end = new point_default(box.x2 + connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x + space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.max(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
              sr = sector.center.x - sector.radius - space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr > middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x - space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          }
          connectorLine.lineTo(end.x, end.y);
          this$1._connectorLines.push(connectorLine);
          this$1.visual.append(connectorLine);
        }
      }
    }
  };
  PieChart2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    if (find(this.options.series, function(options) {
      return options.autoFit;
    })) {
      var targetBox = this.targetBox;
      var pieCenter = this.box.center();
      var bbox = this.visual.bbox();
      if (!bbox) {
        return;
      }
      var bboxBottom = bbox.bottomRight();
      var scale = Math.min(
        (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),
        (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),
        (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),
        (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)
      );
      if (scale < 1) {
        this.visual.transform(geometry_exports.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));
      }
    }
  };
  PieChart2.prototype.labelComparator = function labelComparator(reverse) {
    var reverseValue = reverse ? -1 : 1;
    return function(a38, b2) {
      var first = (a38.parent.sector.middle() + 270) % 360;
      var second = (b2.parent.sector.middle() + 270) % 360;
      return (first - second) * reverseValue;
    };
  };
  PieChart2.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y2, direction) {
    var radius = sector.radius;
    var sector_center = sector.center;
    var cx = sector_center.x;
    var cy = sector_center.y;
    var t38 = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));
    if (t38 > radius) {
      return originalX;
    }
    return cx + Math.sqrt(radius * radius - t38 * t38) * (direction ? 1 : -1);
  };
  PieChart2.prototype.pointInCircle = function pointInCircle(point, center, radius) {
    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);
  };
  PieChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value);
  };
  PieChart2.prototype.animationDelay = function animationDelay(categoryIndex) {
    return categoryIndex * PIE_SECTOR_ANIM_DELAY;
  };
  PieChart2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  return PieChart2;
}(chart_element_default);
function intersection(a1, a210, b1, b2) {
  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  var ub = (b2.y - b1.y) * (a210.x - a1.x) - (b2.x - b1.x) * (a210.y - a1.y);
  var result;
  if (ub !== 0) {
    var ua = uat / ub;
    result = new point_default(
      a1.x + ua * (a210.x - a1.x),
      a1.y + ua * (a210.y - a1.y)
    );
  }
  return result;
}
setDefaultOptions(PieChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  },
  inactiveItems: {
    markers: {},
    labels: {}
  }
});
deepExtend(PieChart.prototype, pie_chart_mixin_default);
PieChart.prototype.isStackRoot = true;
var pie_chart_default = PieChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/pie-plotarea.js
var PiePlotArea = function(PlotAreaBase2) {
  function PiePlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) PiePlotArea2.__proto__ = PlotAreaBase2;
  PiePlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PiePlotArea2.prototype.constructor = PiePlotArea2;
  PiePlotArea2.prototype.render = function render() {
    this.createPieChart(this.series);
  };
  PiePlotArea2.prototype.createPieChart = function createPieChart(series) {
    var firstSeries = series[0];
    var pieChart = new pie_chart_default(this, {
      series,
      padding: firstSeries.padding,
      startAngle: firstSeries.startAngle,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(pieChart);
  };
  PiePlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append(this.options.legend.data, chart.legendItems);
  };
  PiePlotArea2.prototype.getPointBelow = function getPointBelow(point) {
    return this.getPointToTheRight(point);
  };
  PiePlotArea2.prototype.getPointAbove = function getPointAbove(point) {
    return this.getPointToTheLeft(point);
  };
  return PiePlotArea2;
}(plotarea_base_default);
var pie_plotarea_default = PiePlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-segment.js
var DonutSegment = function(PieSegment2) {
  function DonutSegment2() {
    PieSegment2.apply(this, arguments);
  }
  if (PieSegment2) DonutSegment2.__proto__ = PieSegment2;
  DonutSegment2.prototype = Object.create(PieSegment2 && PieSegment2.prototype);
  DonutSegment2.prototype.constructor = DonutSegment2;
  DonutSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      if (labelsOptions.position === CENTER) {
        sector.radius -= (sector.radius - sector.innerRadius) / 2;
        var lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        PieSegment2.prototype.reflowLabel.call(this);
      }
    }
  };
  DonutSegment2.prototype.createSegment = function createSegment(sector, options) {
    return shape_builder_default.current.createRing(sector, options);
  };
  return DonutSegment2;
}(pie_segment_default);
setDefaultOptions(DonutSegment, {
  overlay: {
    gradient: "roundedGlass"
  },
  labels: {
    position: CENTER
  },
  animation: {
    type: PIE
  }
});
deepExtend(DonutSegment.prototype, point_events_mixin_default);
var donut_segment_default = DonutSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-chart.js
var DONUT_SECTOR_ANIM_DELAY = 50;
var DonutChart = function(PieChart2) {
  function DonutChart2() {
    PieChart2.apply(this, arguments);
  }
  if (PieChart2) DonutChart2.__proto__ = PieChart2;
  DonutChart2.prototype = Object.create(PieChart2 && PieChart2.prototype);
  DonutChart2.prototype.constructor = DonutChart2;
  DonutChart2.prototype.addValue = function addValue(value2, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    segmentOptions.pattern = fields.pattern || segmentOptions.pattern;
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new donut_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  DonutChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options = this.options;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var series = options.series;
    var seriesCount = series.length;
    var padding = valueOrDefault(options.padding, defaultPadding);
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    var totalSize = halfMinWidth - padding;
    var seriesWithoutSize = 0;
    var holeSize;
    for (var i36 = 0; i36 < seriesCount; i36++) {
      var currentSeries = series[i36];
      if (i36 === 0) {
        if (defined(currentSeries.holeSize)) {
          holeSize = currentSeries.holeSize;
          totalSize -= currentSeries.holeSize;
        }
      }
      if (defined(currentSeries.size)) {
        totalSize -= currentSeries.size;
      } else {
        seriesWithoutSize++;
      }
      if (defined(currentSeries.margin) && i36 !== seriesCount - 1) {
        totalSize -= currentSeries.margin;
      }
    }
    if (!defined(holeSize)) {
      var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);
      holeSize = currentSize * 0.75;
      totalSize -= holeSize;
    }
    var innerRadius = holeSize;
    var margin = 0;
    var size, radius;
    this.seriesConfigs = [];
    for (var i$1 = 0; i$1 < seriesCount; i$1++) {
      var currentSeries$1 = series[i$1];
      size = valueOrDefault(currentSeries$1.size, totalSize / seriesWithoutSize);
      innerRadius += margin;
      radius = innerRadius + size;
      this$1.seriesConfigs.push({ innerRadius, radius });
      margin = currentSeries$1.margin || 0;
      innerRadius = radius;
    }
    PieChart2.prototype.reflow.call(this, targetBox);
  };
  DonutChart2.prototype.animationDelay = function animationDelay(categoryIndex, seriesIndex, seriesCount) {
    return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);
  };
  return DonutChart2;
}(pie_chart_default);
setDefaultOptions(DonutChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  }
});
var donut_chart_default = DonutChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/donut-plotarea.js
var DonutPlotArea = function(PiePlotArea2) {
  function DonutPlotArea2() {
    PiePlotArea2.apply(this, arguments);
  }
  if (PiePlotArea2) DonutPlotArea2.__proto__ = PiePlotArea2;
  DonutPlotArea2.prototype = Object.create(PiePlotArea2 && PiePlotArea2.prototype);
  DonutPlotArea2.prototype.constructor = DonutPlotArea2;
  DonutPlotArea2.prototype.render = function render() {
    this.createDonutChart(this.series);
  };
  DonutPlotArea2.prototype.createDonutChart = function createDonutChart(series) {
    var firstSeries = series[0];
    var donutChart = new donut_chart_default(this, {
      series,
      padding: firstSeries.padding,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(donutChart);
  };
  DonutPlotArea2.prototype.getPointBelow = function getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  };
  DonutPlotArea2.prototype.getPointAbove = function getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  };
  return DonutPlotArea2;
}(pie_plotarea_default);
var donut_plotarea_default = DonutPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea-base.js
var DEFAULT_PADDING = 0.15;
var PolarPlotAreaBase = function(PlotAreaBase2) {
  function PolarPlotAreaBase2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) PolarPlotAreaBase2.__proto__ = PlotAreaBase2;
  PolarPlotAreaBase2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PolarPlotAreaBase2.prototype.constructor = PolarPlotAreaBase2;
  PolarPlotAreaBase2.prototype.initFields = function initFields() {
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
  };
  PolarPlotAreaBase2.prototype.render = function render() {
    this.addToLegend(this.series);
    this.createPolarAxis();
    this.createCharts();
    this.createValueAxis();
  };
  PolarPlotAreaBase2.prototype.alignAxes = function alignAxes() {
    var axis = this.valueAxis;
    var range = axis.range();
    var crossingValue = axis.options.reverse ? range.max : range.min;
    var slot = axis.getSlot(crossingValue);
    var center = this.polarAxis.getSlot(0).center;
    var axisBox = axis.box.translate(
      center.x - slot.x1,
      center.y - slot.y1
    );
    axis.reflow(axisBox);
  };
  PolarPlotAreaBase2.prototype.createValueAxis = function createValueAxis() {
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var axisOptions2 = this.valueAxisOptions({
      roundToMajorUnit: false,
      zIndex: -1
    });
    var axisType, axisDefaultRange;
    if (axisOptions2.type === LOGARITHMIC) {
      axisType = radar_logarithmic_axis_default;
      axisDefaultRange = { min: 0.1, max: 1 };
    } else {
      axisType = radar_numeric_axis_default;
      axisDefaultRange = { min: 0, max: 1 };
    }
    var range = tracker.query(name) || defaultRange || axisDefaultRange;
    if (range && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var valueAxis = new axisType(
      range.min,
      range.max,
      axisOptions2,
      this.chartService
    );
    this.valueAxis = valueAxis;
    this.appendAxis(valueAxis);
  };
  PolarPlotAreaBase2.prototype.reflowAxes = function reflowAxes() {
    var ref2 = this;
    var options = ref2.options.plotArea;
    var valueAxis = ref2.valueAxis;
    var polarAxis = ref2.polarAxis;
    var box = ref2.box;
    var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;
    var padding = getSpacing(options.padding || {}, defaultPadding);
    var paddingBox = box.clone().unpad(padding);
    var axisBox = paddingBox.clone();
    axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());
    axisBox.align(paddingBox, Y, CENTER);
    var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);
    polarAxis.reflow(axisBox);
    valueAxis.reflow(valueAxisBox);
    var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();
    valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));
    this.axisBox = axisBox;
    this.alignAxes(axisBox);
  };
  PolarPlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    return this.box;
  };
  PolarPlotAreaBase2.prototype.detachLabels = function detachLabels() {
  };
  return PolarPlotAreaBase2;
}(plotarea_base_default);
var polar_plotarea_base_default = PolarPlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-scatter-chart/polar-scatter-chart.js
var PolarScatterChart = function(ScatterChart2) {
  function PolarScatterChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2) PolarScatterChart2.__proto__ = ScatterChart2;
  PolarScatterChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  PolarScatterChart2.prototype.constructor = PolarScatterChart2;
  PolarScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    var valueRadius = slotX.center.y - slotY.y1;
    var slot = point_default.onCircle(slotX.center, slotX.startAngle, valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  return PolarScatterChart2;
}(scatter_chart_default);
setDefaultOptions(PolarScatterChart, {
  clip: false
});
var polar_scatter_chart_default = PolarScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-line-chart/polar-line-chart.js
var PolarLineChart = function(ScatterLineChart2) {
  function PolarLineChart2() {
    ScatterLineChart2.apply(this, arguments);
  }
  if (ScatterLineChart2) PolarLineChart2.__proto__ = ScatterLineChart2;
  PolarLineChart2.prototype = Object.create(ScatterLineChart2 && ScatterLineChart2.prototype);
  PolarLineChart2.prototype.constructor = PolarLineChart2;
  return PolarLineChart2;
}(scatter_line_chart_default);
PolarLineChart.prototype.pointSlot = polar_scatter_chart_default.prototype.pointSlot;
setDefaultOptions(PolarLineChart, {
  clip: false
});
var polar_line_chart_default = PolarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/spline-polar-area-segment.js
var SplinePolarAreaSegment = function(SplineAreaSegment2) {
  function SplinePolarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2) SplinePolarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplinePolarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplinePolarAreaSegment2.prototype.constructor = SplinePolarAreaSegment2;
  SplinePolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var center = this._polarAxisCenter();
    fillPath.lineTo(center.x, center.y);
  };
  SplinePolarAreaSegment2.prototype._polarAxisCenter = function _polarAxisCenter() {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    return center;
  };
  SplinePolarAreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      var center = this._polarAxisCenter();
      var curveProcessor = new curve_processor_default(false);
      var linePoints = this.points();
      linePoints.push(center);
      segments = this._strokeSegments = curveProcessor.process(linePoints);
      segments.pop();
    }
    return segments;
  };
  return SplinePolarAreaSegment2;
}(spline_area_segment_default);
var spline_polar_area_segment_default = SplinePolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-segment.js
var PolarAreaSegment = function(AreaSegment2) {
  function PolarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) PolarAreaSegment2.__proto__ = AreaSegment2;
  PolarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  PolarAreaSegment2.prototype.constructor = PolarAreaSegment2;
  PolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    var centerSegment = new geometry_exports.Segment([center.x, center.y]);
    fillPath.segments.unshift(centerSegment);
    fillPath.segments.push(centerSegment);
  };
  return PolarAreaSegment2;
}(area_segment_default);
var polar_area_segment_default = PolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-chart.js
var PolarAreaChart = function(PolarLineChart2) {
  function PolarAreaChart2() {
    PolarLineChart2.apply(this, arguments);
  }
  if (PolarLineChart2) PolarAreaChart2.__proto__ = PolarLineChart2;
  PolarAreaChart2.prototype = Object.create(PolarLineChart2 && PolarLineChart2.prototype);
  PolarAreaChart2.prototype.constructor = PolarAreaChart2;
  PolarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segment;
    if (style === SMOOTH) {
      segment = new spline_polar_area_segment_default(linePoints, currentSeries, seriesIx);
    } else {
      segment = new polar_area_segment_default(linePoints, currentSeries, seriesIx);
    }
    return segment;
  };
  PolarAreaChart2.prototype.createMissingValue = function createMissingValue(value2, missingValues) {
    var missingValue;
    if (hasValue(value2.x) && missingValues !== INTERPOLATE) {
      missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (missingValues === ZERO) {
        missingValue.y = 0;
      }
    }
    return missingValue;
  };
  PolarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  PolarAreaChart2.prototype._hasMissingValuesGap = function _hasMissingValuesGap() {
    var this$1 = this;
    var series = this.options.series;
    for (var idx = 0; idx < series.length; idx++) {
      if (this$1.seriesMissingValues(series[idx]) === GAP) {
        return true;
      }
    }
  };
  PolarAreaChart2.prototype.sortPoints = function sortPoints(points) {
    var this$1 = this;
    points.sort(xComparer);
    if (this._hasMissingValuesGap()) {
      for (var idx = 0; idx < points.length; idx++) {
        var point = points[idx];
        if (point) {
          var value2 = point.value;
          if (!hasValue(value2.y) && this$1.seriesMissingValues(point.series) === GAP) {
            delete points[idx];
          }
        }
      }
    }
    return points;
  };
  return PolarAreaChart2;
}(polar_line_chart_default);
function xComparer(a38, b2) {
  return a38.value.x - b2.value.x;
}
var polar_area_chart_default = PolarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea.js
var PolarPlotArea = function(PolarPlotAreaBase2) {
  function PolarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2) PolarPlotArea2.__proto__ = PolarPlotAreaBase2;
  PolarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  PolarPlotArea2.prototype.constructor = PolarPlotArea2;
  PolarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var polarAxis = new polar_axis_default(this.options.xAxis, this.chartService);
    this.polarAxis = polarAxis;
    this.axisX = polarAxis;
    this.appendAxis(polarAxis);
  };
  PolarPlotArea2.prototype.render = function render() {
    this.series = [].concat(this.originalSeries);
    this.createTrendlineSeries();
    PolarPlotAreaBase2.prototype.render.call(this);
  };
  PolarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    return deepExtend(defaults, {
      majorGridLines: { type: ARC },
      minorGridLines: { type: ARC }
    }, this.options.yAxis);
  };
  PolarPlotArea2.prototype.createValueAxis = function createValueAxis() {
    PolarPlotAreaBase2.prototype.createValueAxis.call(this);
    this.axisY = this.valueAxis;
  };
  PolarPlotArea2.prototype.trendlineFactory = function trendlineFactory2(options, series) {
    var trendline = xy_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = POLAR_LINE;
    }
    return trendline;
  };
  PolarPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.valueAxisRangeTracker.update(chart.yAxisRanges);
    plotarea_base_default.prototype.appendChart.call(this, chart, pane);
  };
  PolarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createLineChart(
      filterSeriesByType(series, [POLAR_LINE]),
      pane
    );
    this.createScatterChart(
      filterSeriesByType(series, [POLAR_SCATTER]),
      pane
    );
    this.createAreaChart(
      filterSeriesByType(series, [POLAR_AREA]),
      pane
    );
  };
  PolarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new polar_line_chart_default(this, { series });
    this.appendChart(lineChart, pane);
  };
  PolarPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var scatterChart = new polar_scatter_chart_default(this, { series });
    this.appendChart(scatterChart, pane);
  };
  PolarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new polar_area_chart_default(this, { series });
    this.appendChart(areaChart, pane);
  };
  PolarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e39, eventType) {
    var coords = chart._eventCoordinates(e39);
    var point = new point_default(coords.x, coords.y);
    var xValue = this.axisX.getValue(point);
    var yValue = this.axisY.getValue(point);
    if (xValue !== null && yValue !== null) {
      chart.trigger(eventType, {
        element: eventElement(e39),
        x: xValue,
        y: yValue
      });
    }
  };
  PolarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  return PolarPlotArea2;
}(polar_plotarea_base_default);
setDefaultOptions(PolarPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(PolarPlotArea.prototype, plotarea_events_mixin_default, {
  seriesValues: xy_plotarea_default.prototype.seriesValues
});
var polar_plotarea_default = PolarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-line-chart/radar-line-chart.js
function groupBySeriesIx(segments) {
  var seriesSegments = [];
  for (var idx = 0; idx < segments.length; idx++) {
    var segment = segments[idx];
    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];
    seriesSegments[segment.seriesIx].push(segment);
  }
  return seriesSegments;
}
var RadarLineChart = function(LineChart2) {
  function RadarLineChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2) RadarLineChart2.__proto__ = LineChart2;
  RadarLineChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  RadarLineChart2.prototype.constructor = RadarLineChart2;
  RadarLineChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var valueRadius = categorySlot.center.y - valueSlot.y1;
    var slot = point_default.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  RadarLineChart2.prototype.renderSegments = function renderSegments() {
    LineChart2.prototype.renderSegments.call(this);
    if (this._segments && this._segments.length > 1) {
      var seriesSegments = groupBySeriesIx(this._segments);
      for (var idx = 0; idx < seriesSegments.length; idx++) {
        var segments = seriesSegments[idx];
        if (segments && segments.length > 1) {
          var firstPoint = segments[0].linePoints[0];
          var lastSegment = last(segments);
          var lastPoint = last(lastSegment.linePoints);
          var isFirstDataPoint = firstPoint.categoryIx === 0;
          var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;
          if (isFirstDataPoint && isLastDataPoint) {
            last(segments).linePoints.push(firstPoint);
          }
        }
      }
    }
  };
  RadarLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    var segment = new pointType(linePoints, currentSeries, seriesIx);
    var missingValues = this.seriesMissingValues(currentSeries);
    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {
      segment.options.closed = true;
    }
    return segment;
  };
  return RadarLineChart2;
}(line_chart_default);
setDefaultOptions(RadarLineChart, {
  clip: false,
  limitPoints: false
});
var radar_line_chart_default = RadarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/spline-radar-area-segment.js
var SplineRadarAreaSegment = function(SplineAreaSegment2) {
  function SplineRadarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2) SplineRadarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplineRadarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplineRadarAreaSegment2.prototype.constructor = SplineRadarAreaSegment2;
  SplineRadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return SplineRadarAreaSegment2;
}(spline_area_segment_default);
var spline_radar_area_segment_default = SplineRadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-segment.js
var RadarAreaSegment = function(AreaSegment2) {
  function RadarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) RadarAreaSegment2.__proto__ = AreaSegment2;
  RadarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RadarAreaSegment2.prototype.constructor = RadarAreaSegment2;
  RadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return RadarAreaSegment2;
}(area_segment_default);
var radar_area_segment_default = RadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-chart.js
var RadarAreaChart = function(RadarLineChart2) {
  function RadarAreaChart2() {
    RadarLineChart2.apply(this, arguments);
  }
  if (RadarLineChart2) RadarAreaChart2.__proto__ = RadarLineChart2;
  RadarAreaChart2.prototype = Object.create(RadarLineChart2 && RadarLineChart2.prototype);
  RadarAreaChart2.prototype.constructor = RadarAreaChart2;
  RadarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    var segment;
    if (isStacked && seriesIx > 0 && prevSegment) {
      stackPoints = prevSegment.linePoints.slice(0);
      previousSegment = prevSegment;
    }
    if (style === SMOOTH) {
      segment = new spline_radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
      segment.options.closed = true;
    } else {
      linePoints.push(linePoints[0]);
      segment = new radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
    }
    return segment;
  };
  RadarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  return RadarAreaChart2;
}(radar_line_chart_default);
var radar_area_chart_default = RadarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-segment.js
var RadarSegment = function(DonutSegment2) {
  function RadarSegment2(value2, options) {
    DonutSegment2.call(this, value2, null, options);
  }
  if (DonutSegment2) RadarSegment2.__proto__ = DonutSegment2;
  RadarSegment2.prototype = Object.create(DonutSegment2 && DonutSegment2.prototype);
  RadarSegment2.prototype.constructor = RadarSegment2;
  RadarSegment2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return RadarSegment2;
}(donut_segment_default);
setDefaultOptions(RadarSegment, {
  overlay: {
    gradient: "none"
  },
  labels: {
    distance: 10
  }
});
var radar_segment_default = RadarSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-cluster-layout.js
var RadarClusterLayout = function(ChartElement2) {
  function RadarClusterLayout2(options) {
    ChartElement2.call(this, options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  if (ChartElement2) RadarClusterLayout2.__proto__ = ChartElement2;
  RadarClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarClusterLayout2.prototype.constructor = RadarClusterLayout2;
  RadarClusterLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var gap = options.gap;
    var spacing = options.spacing;
    var count = children.length;
    var slots = count + gap + spacing * (count - 1);
    var slotAngle = sector.angle / slots;
    var angle = sector.startAngle + slotAngle * (gap / 2);
    this.forEach(children, function(child) {
      var slotSector = sector.clone();
      slotSector.startAngle = angle;
      slotSector.angle = slotAngle;
      if (child.sector) {
        slotSector.radius = child.sector.radius;
      }
      child.reflow(slotSector);
      child.sector = slotSector;
      angle += slotAngle + slotAngle * spacing;
    });
  };
  return RadarClusterLayout2;
}(chart_element_default);
setDefaultOptions(RadarClusterLayout, {
  gap: 1,
  spacing: 0
});
var radar_cluster_layout_default = RadarClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-stack-layout.js
var RadarStackLayout = function(ChartElement2) {
  function RadarStackLayout2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2) RadarStackLayout2.__proto__ = ChartElement2;
  RadarStackLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarStackLayout2.prototype.constructor = RadarStackLayout2;
  RadarStackLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var reverse = ref2.options.reverse;
    var children = ref2.children;
    var childrenCount = children.length;
    var first = reverse ? childrenCount - 1 : 0;
    var step = reverse ? -1 : 1;
    this.box = new box_default();
    for (var i36 = first; i36 >= 0 && i36 < childrenCount; i36 += step) {
      var childSector = children[i36].sector;
      childSector.startAngle = sector.startAngle;
      childSector.angle = sector.angle;
    }
  };
  return RadarStackLayout2;
}(chart_element_default);
var radar_stack_layout_default = RadarStackLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-bar-chart.js
var RadarBarChart = function(BarChart2) {
  function RadarBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2) RadarBarChart2.__proto__ = BarChart2;
  RadarBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RadarBarChart2.prototype.constructor = RadarBarChart2;
  RadarBarChart2.prototype.pointType = function pointType() {
    return radar_segment_default;
  };
  RadarBarChart2.prototype.clusterType = function clusterType() {
    return radar_cluster_layout_default;
  };
  RadarBarChart2.prototype.stackType = function stackType() {
    return radar_stack_layout_default;
  };
  RadarBarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  RadarBarChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var slot = categorySlot.clone();
    var y = categorySlot.center.y;
    slot.radius = y - valueSlot.y1;
    slot.innerRadius = y - valueSlot.y2;
    return slot;
  };
  RadarBarChart2.prototype.reflowPoint = function reflowPoint(point, pointSlot) {
    point.sector = pointSlot;
    point.reflow();
  };
  RadarBarChart2.prototype.createAnimation = function createAnimation() {
    this.options.animation.center = this.box.toRect().center();
    BarChart2.prototype.createAnimation.call(this);
  };
  return RadarBarChart2;
}(bar_chart_default);
RadarBarChart.prototype.reflow = categorical_chart_default.prototype.reflow;
setDefaultOptions(RadarBarChart, {
  clip: false,
  limitPoints: false,
  animation: {
    type: "pie"
  }
});
var radar_bar_chart_default = RadarBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/radar-plotarea.js
var RadarPlotArea = function(PolarPlotAreaBase2) {
  function RadarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2) RadarPlotArea2.__proto__ = PolarPlotAreaBase2;
  RadarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  RadarPlotArea2.prototype.constructor = RadarPlotArea2;
  RadarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var categoryAxis = new radar_category_axis_default(this.options.categoryAxis, this.chartService);
    this.polarAxis = categoryAxis;
    this.categoryAxis = categoryAxis;
    this.appendAxis(categoryAxis);
    this.aggregateCategories();
    this.createTrendlineSeries();
    this.createCategoryAxesLabels();
  };
  RadarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    if (this._hasBarCharts) {
      deepExtend(defaults, {
        majorGridLines: { type: ARC },
        minorGridLines: { type: ARC }
      });
    }
    if (this._isStacked100) {
      deepExtend(defaults, {
        roundToMajorUnit: false,
        labels: { format: "P0" }
      });
    }
    return deepExtend(defaults, this.options.valueAxis);
  };
  RadarPlotArea2.prototype.aggregateCategories = function aggregateCategories() {
    categorical_plotarea_default.prototype.aggregateCategories.call(this, this.panes);
  };
  RadarPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    categorical_plotarea_default.prototype.createCategoryAxesLabels.call(this, this.panes);
  };
  RadarPlotArea2.prototype.filterSeries = function filterSeries(currentSeries) {
    return currentSeries;
  };
  RadarPlotArea2.prototype.trendlineFactory = function trendlineFactory2(options, series) {
    var trendline = categorical_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = RADAR_LINE;
    }
    return trendline;
  };
  RadarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createAreaChart(
      filterSeriesByType(series, [RADAR_AREA]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [RADAR_LINE]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [RADAR_COLUMN]),
      pane
    );
  };
  RadarPlotArea2.prototype.chartOptions = function chartOptions(series) {
    var options = { series };
    var firstSeries = series[0];
    if (firstSeries) {
      var filteredSeries = this.filterVisibleSeries(series);
      var stack = firstSeries.stack;
      options.isStacked = stack && filteredSeries.length > 1;
      options.isStacked100 = stack && stack.type === "100%" && filteredSeries.length > 1;
      if (options.isStacked100) {
        this._isStacked100 = true;
      }
    }
    return options;
  };
  RadarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new radar_area_chart_default(this, this.chartOptions(series));
    this.appendChart(areaChart, pane);
  };
  RadarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new radar_line_chart_default(this, this.chartOptions(series));
    this.appendChart(lineChart, pane);
  };
  RadarPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var options = this.chartOptions(series);
    var filteredSeries = this.filterVisibleSeries(series);
    var anyStackedSeries = filteredSeries.some(function(s10) {
      return s10.stack;
    });
    var isStacked100 = filteredSeries.some(function(s10) {
      return s10.stack && s10.stack.type === "100%";
    });
    options.gap = firstSeries.gap;
    options.spacing = firstSeries.spacing;
    options.defaultStack = firstSeries.stack && filteredSeries.length > 1;
    options.isStacked = anyStackedSeries && filteredSeries.length > 1;
    options.isStacked100 = isStacked100 && filteredSeries.length > 1;
    var barChart = new radar_bar_chart_default(this, options);
    this.appendChart(barChart, pane);
    this._hasBarCharts = true;
  };
  RadarPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis() {
    return this.categoryAxis;
  };
  RadarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e39, eventType) {
    var coords = chart._eventCoordinates(e39);
    var point = new point_default(coords.x, coords.y);
    var category = this.categoryAxis.getCategory(point);
    var value2 = this.valueAxis.getValue(point);
    if (category !== null && value2 !== null) {
      chart.trigger(eventType, {
        element: eventElement(e39),
        category,
        value: value2
      });
    }
  };
  RadarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  RadarPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return PolarPlotAreaBase2.prototype._pointsByVertical.call(this, basePoint).sort(this._getSeriesCompareFn());
  };
  RadarPlotArea2.prototype._getSeriesCompareFn = function _getSeriesCompareFn() {
    return function(a38, b2) {
      return b2.value - a38.value;
    };
  };
  return RadarPlotArea2;
}(polar_plotarea_base_default);
deepExtend(RadarPlotArea.prototype, plotarea_events_mixin_default, {
  appendChart: categorical_plotarea_default.prototype.appendChart,
  aggregateSeries: categorical_plotarea_default.prototype.aggregateSeries,
  seriesSourcePoints: categorical_plotarea_default.prototype.seriesSourcePoints,
  seriesValues: categorical_plotarea_default.prototype.seriesValues
});
setDefaultOptions(RadarPlotArea, {
  categoryAxis: {
    categories: []
  },
  valueAxis: {}
});
var radar_plotarea_default = RadarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-segment.js
var FunnelSegment = function(ChartElement2) {
  function FunnelSegment2(value2, options, segmentOptions) {
    ChartElement2.call(this, options);
    this.value = value2;
    this.options.index = segmentOptions.index;
  }
  if (ChartElement2) FunnelSegment2.__proto__ = ChartElement2;
  FunnelSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelSegment2.prototype.constructor = FunnelSegment2;
  FunnelSegment2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  };
  FunnelSegment2.prototype.reflow = function reflow(chartBox) {
    var points = this.points;
    var label = this.children[0];
    var x1 = Math.min(points[0].x, points[3].x);
    var x22 = Math.max(points[1].x, points[2].x);
    this.box = new box_default(x1, points[0].y, x22, points[2].y);
    if (label) {
      label.reflow(new box_default(chartBox.x1, points[0].y, chartBox.x2, points[2].y));
    }
  };
  FunnelSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options = this.options;
    var visual;
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    if (options.visual) {
      visual = options.visual({
        category: this.category,
        dataItem: this.dataItem,
        value: this.value,
        series: this.series,
        percentage: this.percentage,
        points: this.points,
        options,
        sender: this.getSender(),
        createVisual: function() {
          return this$1.createPath();
        }
      });
    } else {
      visual = this.createPath();
    }
    if (visual) {
      this.visual.append(visual);
    }
  };
  FunnelSegment2.prototype.createPath = function createPath() {
    var options = this.options;
    var border = options.border;
    var path = drawing_exports.Path.fromPoints(this.points, {
      fill: createPatternFill(options.pattern, {
        color: options.color,
        opacity: options.opacity
      }),
      stroke: {
        color: border.color,
        opacity: border.opacity,
        width: border.width
      }
    }).close();
    return path;
  };
  FunnelSegment2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromPoints(this.points, style);
  };
  FunnelSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  FunnelSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var path = drawing_exports.Path.fromPoints(this.points).close();
    return {
      options: this.options,
      path
    };
  };
  FunnelSegment2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = this.options.focusHighlight.border.width;
    var result = drawing_exports.Path.fromPoints(this.points, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    })).close();
    var clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(this.box.clone().pad(borderWidth).toRect()));
    clipPath.paths.push(drawing_exports.Path.fromPoints(this.points));
    result.clip(clipPath);
    return result;
  };
  FunnelSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    return {
      point: new point_default(box.center().x, box.y1),
      align: {
        horizontal: "center",
        vertical: "top"
      }
    };
  };
  FunnelSegment2.prototype.formatValue = function formatValue(format) {
    var point = this;
    return point.owner.formatPointValue(point, format);
  };
  FunnelSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  FunnelSegment2.prototype.getIndex = function getIndex() {
    return this.index;
  };
  return FunnelSegment2;
}(chart_element_default);
setDefaultOptions(FunnelSegment, {
  color: WHITE,
  border: {
    width: 1
  },
  labels: {
    format: ""
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(FunnelSegment.prototype, point_events_mixin_default);
deepExtend(FunnelSegment.prototype, accessibility_attributes_mixin_default);
var funnel_segment_default = FunnelSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-chart.js
var FunnelChart = function(ChartElement2) {
  function FunnelChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.labels = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2) FunnelChart2.__proto__ = ChartElement2;
  FunnelChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelChart2.prototype.constructor = FunnelChart2;
  FunnelChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    return this.plotArea.chartService.format.auto(format, point.value);
  };
  FunnelChart2.prototype.render = function render() {
    var this$1 = this;
    var seriesIx = 0;
    var ref2 = this;
    var options = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0) seriesColors = [];
    var series = options.series[seriesIx];
    var data = series.data;
    if (!data) {
      return;
    }
    var ref$1 = bindSegments(series);
    var total3 = ref$1.total;
    var points = ref$1.points;
    for (var i36 = 0; i36 < points.length; i36++) {
      var pointData = points[i36];
      if (!pointData) {
        continue;
      }
      var fields = pointData.fields;
      if (!isFunction(series.color)) {
        series.color = fields.color || seriesColors[i36 % seriesColors.length];
      }
      fields = deepExtend({
        index: i36,
        owner: this$1,
        series,
        seriesIx,
        dataItem: data[i36],
        percentage: pointData.value / total3
      }, fields, { visible: pointData.visible });
      var value2 = pointData.valueFields.value;
      var segment = this$1.createSegment(value2, fields);
      var label = this$1.createLabel(value2, fields);
      if (segment && label) {
        segment.append(label);
      }
    }
  };
  FunnelChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options, value2, fields) {
    var series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      index: fields.index
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "toggle",
      "visual",
      "ariaTemplate",
      "ariaContent"
    ] });
  };
  FunnelChart2.prototype.createSegment = function createSegment(value2, fields) {
    var seriesOptions = deepExtend({}, fields.series);
    seriesOptions.pattern = fields.pattern || seriesOptions.pattern;
    this.evalSegmentOptions(seriesOptions, value2, fields);
    this.createLegendItem(value2, seriesOptions, fields);
    if (fields.visible !== false) {
      var segment = new funnel_segment_default(value2, seriesOptions, fields);
      Object.assign(segment, fields);
      this.append(segment);
      this.points.push(segment);
      return segment;
    }
  };
  FunnelChart2.prototype.createLabel = function createLabel(value2, fields) {
    var series = fields.series;
    var dataItem = fields.dataItem;
    var labels = deepExtend({}, this.options.labels, series.labels);
    var text = value2;
    if (labels.visible) {
      var labelTemplate = getTemplate(labels);
      var data = {
        dataItem,
        value: value2,
        percentage: fields.percentage,
        category: fields.category,
        series
      };
      if (labelTemplate) {
        text = labelTemplate(data);
      } else if (labels.format) {
        text = this.chartService.format.auto(labels.format, text);
      }
      if (!labels.color) {
        labels.color = auto_text_color_default(series.color);
        if (!labels.background) {
          labels.background = series.color;
        }
      }
      this.evalSegmentOptions(labels, value2, fields);
      var textBox = new text_box_default(text, deepExtend({
        vAlign: labels.position
      }, labels), data);
      this.labels.push(textBox);
      return textBox;
    }
  };
  FunnelChart2.prototype.labelPadding = function labelPadding() {
    var labels = this.labels;
    var padding = { left: 0, right: 0 };
    for (var i36 = 0; i36 < labels.length; i36++) {
      var label = labels[i36];
      var align = label.options.align;
      if (align !== CENTER) {
        var width = labels[i36].box.width();
        if (align === LEFT) {
          padding.left = Math.max(padding.left, width);
        } else {
          padding.right = Math.max(padding.right, width);
        }
      }
    }
    return padding;
  };
  FunnelChart2.prototype.dynamicSlopeReflow = function dynamicSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var firstSegment = segments[0];
    var maxSegment = firstSegment;
    for (var idx = 0; idx < segments.length; idx++) {
      if (segments[idx].percentage > maxSegment.percentage) {
        maxSegment = segments[idx];
      }
    }
    var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
    var previousOffset = (width - lastUpperSide) / 2;
    var previousHeight = 0;
    for (var idx$1 = 0; idx$1 < count; idx$1++) {
      var percentage = segments[idx$1].percentage;
      var nextSegment = segments[idx$1 + 1];
      var nextPercentage = nextSegment ? nextSegment.percentage : percentage;
      var points = segments[idx$1].points = [];
      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      var offset = void 0;
      if (!percentage) {
        offset = nextPercentage ? 0 : width / 2;
      } else {
        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
      }
      offset = limitValue(offset, 0, width);
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + offset, box.y1 + height + previousHeight));
      previousOffset = offset;
      previousHeight += height + options.segmentSpacing;
      lastUpperSide = limitValue(width - 2 * offset, 0, width);
    }
  };
  FunnelChart2.prototype.constantSlopeReflow = function constantSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var decreasingWidth = options.neckRatio <= 1;
    var neckRatio = decreasingWidth ? options.neckRatio * width : width;
    var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;
    var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
    var finalNarrow = (topMostWidth - neckRatio) / 2;
    var previousHeight = 0;
    for (var idx = 0; idx < count; idx++) {
      var points = segments[idx].points = [];
      var percentage = segments[idx].percentage;
      var offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));
      previousOffset += offset;
      previousHeight += height + options.segmentSpacing;
    }
  };
  FunnelChart2.prototype.reflow = function reflow(chartBox) {
    var points = this.points;
    var count = points.length;
    if (!count) {
      return;
    }
    var options = this.options;
    var box = chartBox.clone().unpad(this.labelPadding());
    var totalHeight = box.height() - options.segmentSpacing * (count - 1);
    var width = box.width();
    if (options.dynamicSlope) {
      this.dynamicSlopeReflow(box, width, totalHeight);
    } else {
      this.constantSlopeReflow(box, width, totalHeight);
    }
    for (var idx = 0; idx < count; idx++) {
      points[idx].reflow(chartBox);
    }
  };
  return FunnelChart2;
}(chart_element_default);
setDefaultOptions(FunnelChart, {
  neckRatio: 0.3,
  width: 300,
  dynamicSlope: false,
  dynamicHeight: true,
  segmentSpacing: 0,
  labels: {
    visible: false,
    align: CENTER,
    position: CENTER,
    zIndex: 1
  }
});
deepExtend(FunnelChart.prototype, pie_chart_mixin_default);
var funnel_chart_default = FunnelChart;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/pyramid-chart.js
var MAX_NECK_RATIO = 1e6;
var PyramidChart = function(FunnelChart2) {
  function PyramidChart2(plotArea, options) {
    options.dynamicSlope = false;
    options.neckRatio = MAX_NECK_RATIO;
    FunnelChart2.call(this, plotArea, options);
  }
  if (FunnelChart2) PyramidChart2.__proto__ = FunnelChart2;
  PyramidChart2.prototype = Object.create(FunnelChart2 && FunnelChart2.prototype);
  PyramidChart2.prototype.constructor = PyramidChart2;
  return PyramidChart2;
}(funnel_chart_default);
var pyramid_chart_default = PyramidChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/funnel-plotarea.js
var FunnelPlotArea = function(PlotAreaBase2) {
  function FunnelPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) FunnelPlotArea2.__proto__ = PlotAreaBase2;
  FunnelPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  FunnelPlotArea2.prototype.constructor = FunnelPlotArea2;
  FunnelPlotArea2.prototype.render = function render() {
    this.createChart(funnel_chart_default, filterSeriesByType(this.series, [FUNNEL]));
    this.createChart(pyramid_chart_default, filterSeriesByType(this.series, [PYRAMID]));
  };
  FunnelPlotArea2.prototype.createChart = function createChart(chartType, series) {
    var firstSeries = series[0];
    if (!firstSeries) {
      return;
    }
    var chart = new chartType(this, {
      series,
      legend: this.options.legend,
      neckRatio: firstSeries.neckRatio,
      dynamicHeight: firstSeries.dynamicHeight,
      dynamicSlope: firstSeries.dynamicSlope,
      segmentSpacing: firstSeries.segmentSpacing,
      highlight: firstSeries.highlight
    });
    this.appendChart(chart);
  };
  FunnelPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append(this.options.legend.data, chart.legendItems);
  };
  FunnelPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return this.pointsBySeriesIndex(basePoint.series.index);
  };
  FunnelPlotArea2.prototype.getPointToTheRight = function getPointToTheRight(point) {
    return this.getPointBelow(point);
  };
  FunnelPlotArea2.prototype.getPointToTheLeft = function getPointToTheLeft(point) {
    return this.getPointAbove(point);
  };
  return FunnelPlotArea2;
}(plotarea_base_default);
var funnel_plotarea_default = FunnelPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/color-scale.js
var colorScale = function(color, minLightnessOffset) {
  if (minLightnessOffset === void 0) minLightnessOffset = 0.05;
  var baseColor = parseColor(color);
  var offset = 1 - minLightnessOffset;
  return function(value2) {
    var hsl = baseColor.toHSL();
    var range = 100 - hsl.l;
    var point = offset - value2;
    hsl.l += Math.min(point * range, range);
    return hsl.toCss();
  };
};
var color_scale_default = colorScale;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-point.js
var HeatmapPoint = function(ChartElement2) {
  function HeatmapPoint2(value2, options) {
    ChartElement2.call(this);
    this.options = options;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  if (ChartElement2) HeatmapPoint2.__proto__ = ChartElement2;
  HeatmapPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapPoint2.prototype.constructor = HeatmapPoint2;
  HeatmapPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createMarker();
    this.createLabel();
    this.createNote();
  };
  HeatmapPoint2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  HeatmapPoint2.prototype.createLabelElement = function createLabelElement(options) {
    var labelColor = options.color;
    if (!labelColor) {
      labelColor = auto_text_color_default(this.color);
    }
    return new text_box_default(
      this.getLabelText(options),
      deepExtend(
        {
          align: CENTER,
          vAlign: CENTER,
          margin: {
            left: 5,
            right: 5
          },
          zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
        },
        options,
        {
          color: labelColor
        }
      ),
      this.pointData()
    );
  };
  HeatmapPoint2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  };
  HeatmapPoint2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  HeatmapPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.reflow(this.markerBox());
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    this.marker.reflow(this.markerBox());
  };
  HeatmapPoint2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
  };
  HeatmapPoint2.prototype.markerBox = function markerBox() {
    var options = this.options;
    var markers = options.markers;
    var border = markers.border;
    var rect = this.box.toRect();
    var type = valueOrDefault(markers.type, "rect");
    var isRoundRect = type === ROUNDED_RECT;
    var borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);
    var halfBorderWidth = Math.round(borderWidth / 2);
    if (markers.size) {
      var center = rect.center();
      rect.size.width = rect.size.height = markers.size;
      rect.origin.x = Math.round(center.x - rect.size.width / 2);
      rect.origin.y = Math.round(center.y - rect.size.height / 2);
    }
    rect.size.width -= borderWidth;
    rect.size.height -= borderWidth;
    rect.origin.y += halfBorderWidth + 0.5;
    rect.origin.x += halfBorderWidth + 0.5;
    return rectToBox(rect);
  };
  HeatmapPoint2.prototype.markerBorder = function markerBorder() {
    var options = this.options;
    var markers = options.markers;
    var border = markers.border;
    var opacity = valueOrDefault(border.opacity, options.opacity);
    return {
      color: border.color || this.color,
      width: border.width,
      opacity,
      dashType: border.dashType
    };
  };
  HeatmapPoint2.prototype.createMarker = function createMarker() {
    var options = this.options;
    var markerOptions = options.markers;
    var marker = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: this.color,
      border: this.markerBorder(),
      pattern: options.pattern,
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    this.marker = marker;
    this.append(marker);
  };
  HeatmapPoint2.prototype.createHighlight = function createHighlight(style) {
    var options = this.options;
    var markerOptions = this.options.highlight.markers || this.options.markers;
    var highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: markerOptions.color || this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
    });
    highlight.reflow(this.markerBox());
    var visual = highlight.getElement();
    visual.options.fill = style.fill;
    visual.options.stroke = style.stroke;
    return visual;
  };
  HeatmapPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  HeatmapPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  HeatmapPoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var markerOptions = this.options.markers;
    var highlightOptions2 = this.options.focusHighlight;
    var highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      borderRadius: markerOptions.borderRadius,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this.markerBox());
    return highlight.getElement();
  };
  HeatmapPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var left = this.box.center().x;
    var top = this.box.y1 - TOOLTIP_OFFSET;
    return {
      point: new point_default(left, top),
      align: {
        horizontal: CENTER,
        vertical: BOTTOM
      }
    };
  };
  HeatmapPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  HeatmapPoint2.prototype.unclipElements = function unclipElements() {
  };
  HeatmapPoint2.prototype.pointData = function pointData() {
    return {
      x: this.value.x,
      y: this.value.y,
      value: this.value.value,
      dataItem: this.dataItem,
      series: this.series
    };
  };
  return HeatmapPoint2;
}(chart_element_default);
deepExtend(HeatmapPoint.prototype, point_events_mixin_default);
deepExtend(HeatmapPoint.prototype, note_mixin_default);
deepExtend(HeatmapPoint.prototype, accessibility_attributes_mixin_default);
HeatmapPoint.prototype.defaults = {
  markers: {
    type: "rect",
    borderRadius: 4,
    border: {
      color: "transparent"
    }
  },
  padding: { top: 1 },
  labels: {
    visible: false,
    padding: 3
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var heatmap_point_default = HeatmapPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-chart.js
var HeatmapChart = function(ChartElement2) {
  function HeatmapChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2) HeatmapChart2.__proto__ = ChartElement2;
  HeatmapChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapChart2.prototype.constructor = HeatmapChart2;
  HeatmapChart2.prototype._initFields = function _initFields() {
    this.points = [];
    this.seriesOptions = [];
    this.valueRange = { min: MAX_VALUE, max: MIN_VALUE };
    this._evalSeries = [];
  };
  HeatmapChart2.prototype.render = function render() {
    this.setRange();
    this.traverseDataPoints(this.addValue.bind(this));
  };
  HeatmapChart2.prototype.setRange = function setRange() {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1.plotArea.bindPoint(currentSeries, pointIx);
        var valueFields = ref$1.valueFields;
        if (defined(valueFields.value) && valueFields.value !== null) {
          this$1.valueRange.min = Math.min(this$1.valueRange.min, valueFields.value);
          this$1.valueRange.max = Math.max(this$1.valueRange.max, valueFields.value);
        }
      }
    }
  };
  HeatmapChart2.prototype.addValue = function addValue(value2, fields) {
    var point;
    if (value2 && defined(value2.value) && value2.value !== null) {
      point = this.createPoint(value2, fields);
      if (point) {
        Object.assign(point, fields);
      }
    }
    this.points.push(point);
  };
  HeatmapChart2.prototype.evalPointOptions = function evalPointOptions(options, value2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    var pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem,
        min: this.valueRange.min,
        max: this.valueRange.max
      }, state);
    }
    return pointOptions;
  };
  HeatmapChart2.prototype.pointType = function pointType() {
    return heatmap_point_default;
  };
  HeatmapChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options = this.seriesOptions[seriesIx];
    if (!options) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return Object.assign({}, options);
  };
  HeatmapChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions.pattern = fields.pattern || pointOptions.pattern;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    } else if (this.valueRange.max !== 0) {
      var scale = color_scale_default(color);
      color = scale(value2.value / this.valueRange.max);
    }
    var point = new heatmap_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  HeatmapChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value2, fields) {
      var point = chartPoints[pointIx++];
      var ref2 = this$1.seriesAxes(fields.series);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var indexX = xAxis.categoryIndex(value2.x);
      var indexY = yAxis.categoryIndex(value2.y);
      var slotX = xAxis.getSlot(indexX, indexX, limit);
      var slotY = yAxis.getSlot(indexY, indexY, limit);
      if (point) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  HeatmapChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  HeatmapChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var ref$1 = this$1.seriesAxes(currentSeries);
      var xAxis = ref$1.xAxis;
      var yAxis = ref$1.yAxis;
      var xRange = xAxis.currentRangeIndices();
      var yRange = yAxis.currentRangeIndices();
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$2 = this$1.plotArea.bindPoint(currentSeries, pointIx);
        var value2 = ref$2.valueFields;
        var fields = ref$2.fields;
        var xIndex = xAxis.totalIndex(value2.x);
        var yIndex = yAxis.totalIndex(value2.y);
        var xIn = xRange.min <= xIndex && xIndex <= xRange.max;
        var yIn = yRange.min <= yIndex && yIndex <= yRange.max;
        if (xIn && yIn) {
          callback(value2, deepExtend({
            pointIx,
            series: currentSeries,
            seriesIx,
            dataItem: currentSeries.data[pointIx],
            owner: this$1
          }, fields));
        }
      }
    }
  };
  HeatmapChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.value);
  };
  HeatmapChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  };
  return HeatmapChart2;
}(chart_element_default);
setDefaultOptions(HeatmapChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}: {2}"
  },
  labels: {
    format: "{2}"
  },
  clip: true
});
var heatmap_chart_default = HeatmapChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/heatmap-plotarea.js
var HeatmapPlotArea = function(PlotAreaBase2) {
  function HeatmapPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) HeatmapPlotArea2.__proto__ = PlotAreaBase2;
  HeatmapPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  HeatmapPlotArea2.prototype.constructor = HeatmapPlotArea2;
  HeatmapPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
  };
  HeatmapPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0) panes = this.panes;
    this.bindCategories();
    this.createAxes(panes);
    this.createCharts(panes);
    this.createAxisLabels();
  };
  HeatmapPlotArea2.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var series = this.srcSeries || this.series;
    for (var i36 = 0; i36 < series.length; i36++) {
      var currentSeries = series[i36];
      var data = currentSeries.data || [];
      var ref2 = this$1.seriesAxes(currentSeries);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var xCategories = createHashSet(xAxis.categories || []);
      var yCategories = createHashSet(yAxis.categories || []);
      for (var pointIndex = 0; pointIndex < data.length; pointIndex++) {
        var ref$1 = series_binder_default.current.bindPoint(currentSeries, pointIndex).valueFields;
        var x5 = ref$1.x;
        var y = ref$1.y;
        if (!xCategories.has(x5)) {
          xCategories.add(x5);
        }
        if (!yCategories.has(y)) {
          yCategories.add(y);
        }
      }
      xAxis.categories = xCategories.values();
      yAxis.categories = yCategories.values();
    }
  };
  HeatmapPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i36 = 0; i36 < panes.length; i36++) {
      var pane = panes[i36];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createHeatmapChart(
        filterSeriesByType(filteredSeries, [HEATMAP]),
        pane
      );
    }
  };
  HeatmapPlotArea2.prototype.createHeatmapChart = function createHeatmapChart(series, pane) {
    var chart = new heatmap_chart_default(this, {
      series
    });
    this.appendChart(chart, pane);
  };
  HeatmapPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options.xAxis);
    var xAxis = grep(xAxisOptions, function(a38) {
      return a38.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options.yAxis);
    var yAxis = grep(yAxisOptions, function(a38) {
      return a38.name === yAxisName;
    })[0];
    var panes = options.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  HeatmapPlotArea2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxis;
    var yAxis;
    var options = this.options;
    var xAxisOptions = [].concat(options.xAxis);
    var xAxisName = series.xAxis;
    if (xAxisName) {
      xAxis = xAxisOptions.find(function(axis) {
        return axis.name === xAxisName;
      });
    } else {
      xAxis = xAxisOptions[0];
    }
    var yAxisOptions = [].concat(options.yAxis);
    var yAxisName = series.yAxis;
    if (yAxisName) {
      yAxis = yAxisOptions.find(function(axis) {
        return axis.name === yAxisName;
      });
    } else {
      yAxis = yAxisOptions[0];
    }
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapPlotArea2.prototype.createAxisLabels = function createAxisLabels() {
    var axes = this.axes;
    for (var i36 = 0; i36 < axes.length; i36++) {
      axes[i36].createLabels();
    }
  };
  HeatmapPlotArea2.prototype.createXYAxis = function createXYAxis(options, vertical, axisIndex) {
    var axisName = options.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var axisOptions2 = Object.assign({
      axisCrossingValue: 0
    }, options, {
      vertical,
      reverse: vertical || this.chartService.rtl ? !options.reverse : options.reverse,
      justified: false
    });
    var firstCategory = axisOptions2.categories ? axisOptions2.categories[0] : null;
    var typeSamples = [axisOptions2.min, axisOptions2.max, firstCategory];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    var inferredDate;
    for (var i36 = 0; i36 < typeSamples.length; i36++) {
      if (typeSamples[i36] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_category_axis_default;
    } else {
      axisType = category_axis_default;
    }
    var axis = new axisType(axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    axis.indexCategories();
    return axis;
  };
  HeatmapPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options = this.options;
    var xAxesOptions = [].concat(options.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  HeatmapPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      delete this.namedYAxes[axisName];
    } else {
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  HeatmapPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e39, eventType) {
    var coords = chart._eventCoordinates(e39);
    var point = new point_default(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i36 = 0; i36 < length; i36++) {
      var axis = allAxes[i36];
      var values5 = axis.options.vertical ? yValues : xValues;
      appendIfNotNull(values5, axis.getCategory(point));
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e39),
        originalEvent: e39,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  HeatmapPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions3(this.options, index, vertical, options);
    updateAxisOptions3(this.originalOptions, index, vertical, options);
  };
  HeatmapPlotArea2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return Object.assign({}, axis.options.crosshair, { zIndex: 0 });
  };
  HeatmapPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint, offset) {
    var this$1 = this;
    if (offset === void 0) offset = 0;
    var normalizedOffset = this.axisX.options.reverse ? offset * -1 : offset;
    var axisXItems = this.axisX.children;
    var xIndex = this._getPointAxisXIndex(basePoint) + normalizedOffset;
    xIndex = cycleIndex(xIndex, axisXItems.length);
    var targetXValue = axisXItems[xIndex].value;
    var points = this.filterPoints(function(point) {
      return compareValues(point.pointData().x, targetXValue);
    }).sort(function(a38, b2) {
      return this$1._getPointAxisYIndex(a38) - this$1._getPointAxisYIndex(b2);
    });
    if (this.axisY.options.reverse) {
      return points.reverse();
    }
    return points;
  };
  HeatmapPlotArea2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset) {
    var this$1 = this;
    if (offset === void 0) offset = 0;
    var normalizedOffset = this.axisY.options.reverse ? offset * -1 : offset;
    var axisYItems = this.axisY.children;
    var yIndex = this._getPointAxisYIndex(basePoint) + normalizedOffset;
    yIndex = cycleIndex(yIndex, axisYItems.length);
    var targetYValue = axisYItems[yIndex].value;
    var points = this.filterPoints(function(point) {
      return compareValues(point.pointData().y, targetYValue);
    }).sort(function(a38, b2) {
      return this$1._getPointAxisXIndex(a38) - this$1._getPointAxisXIndex(b2);
    });
    if (this.axisX.options.reverse) {
      return points.reverse();
    }
    return points;
  };
  HeatmapPlotArea2.prototype._getPointAxisXIndex = function _getPointAxisXIndex(point) {
    return this._getPointAxisIndex(this.axisX, point.pointData().x);
  };
  HeatmapPlotArea2.prototype._getPointAxisYIndex = function _getPointAxisYIndex(point) {
    return this._getPointAxisIndex(this.axisY, point.pointData().y);
  };
  HeatmapPlotArea2.prototype._getPointAxisIndex = function _getPointAxisIndex(axis, pointValue) {
    return axis.children.findIndex(function(axisItem) {
      return compareValues(pointValue, axisItem.value);
    });
  };
  return HeatmapPlotArea2;
}(plotarea_base_default);
function compareValues(a38, b2) {
  if (a38 instanceof Date && b2 instanceof Date) {
    return dateEquals(a38, b2);
  }
  return a38 === b2;
}
function updateAxisOptions3(targetOptions, axisIndex, vertical, options) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(HeatmapPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(HeatmapPlotArea.prototype, plotarea_events_mixin_default);
var heatmap_plotarea_default = HeatmapPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/register-charts.js
var COLOR = "color";
var FIRST = "first";
var FROM = "from";
var MAX = "max";
var MIN = "min";
var NOTE_TEXT = "noteText";
var SUMMARY_FIELD = "summary";
var TO = "to";
plotarea_factory_default.current.register(categorical_plotarea_default, [
  BAR,
  COLUMN,
  LINE,
  VERTICAL_LINE,
  AREA,
  VERTICAL_AREA,
  CANDLESTICK,
  OHLC,
  BULLET,
  VERTICAL_BULLET,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL,
  RANGE_AREA,
  VERTICAL_RANGE_AREA
].concat(
  TRENDLINE_SERIES
));
plotarea_factory_default.current.register(xy_plotarea_default, [
  SCATTER,
  SCATTER_LINE,
  BUBBLE
].concat(
  TRENDLINE_SERIES
));
plotarea_factory_default.current.register(pie_plotarea_default, [PIE]);
plotarea_factory_default.current.register(donut_plotarea_default, [DONUT]);
plotarea_factory_default.current.register(funnel_plotarea_default, [FUNNEL, PYRAMID]);
plotarea_factory_default.current.register(polar_plotarea_default, [
  POLAR_AREA,
  POLAR_LINE,
  POLAR_SCATTER
].concat(
  TRENDLINE_SERIES
));
plotarea_factory_default.current.register(radar_plotarea_default, [
  RADAR_AREA,
  RADAR_COLUMN,
  RADAR_LINE
].concat(
  TRENDLINE_SERIES
));
plotarea_factory_default.current.register(heatmap_plotarea_default, [HEATMAP]);
series_binder_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  [FROM, TO],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register(
  [WATERFALL, HORIZONTAL_WATERFALL],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X, Y], [COLOR, DRILLDOWN_FIELD, PATTERN_FIELD]);
series_binder_default.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [CATEGORY, COLOR, DRILLDOWN_FIELD, PATTERN_FIELD]);
series_binder_default.current.register(
  [FUNNEL, PYRAMID],
  [VALUE],
  [CATEGORY, COLOR, "visibleInLegend", "visible", DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL],
  { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }
);
default_aggregates_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  { from: MIN, to: MAX, color: FIRST, noteText: FIRST }
);
default_aggregates_default.current.register(
  [RADAR_AREA, RADAR_COLUMN, RADAR_LINE],
  { value: MAX, color: FIRST }
);
series_binder_default.current.register(
  [SCATTER, SCATTER_LINE, BUBBLE],
  [X, Y],
  [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]
);
series_binder_default.current.register(
  [BUBBLE],
  [X, Y, "size"],
  [COLOR, CATEGORY, NOTE_TEXT, PATTERN_FIELD]
);
series_binder_default.current.register(
  [HEATMAP],
  [X, Y, VALUE],
  [COLOR, NOTE_TEXT, PATTERN_FIELD]
);
series_binder_default.current.register(
  [CANDLESTICK, OHLC],
  ["open", "high", "low", "close"],
  [CATEGORY, COLOR, "downColor", NOTE_TEXT, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [CANDLESTICK, OHLC],
  {
    open: MAX,
    high: MAX,
    low: MIN,
    close: MAX,
    color: FIRST,
    downColor: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  ["lower", "q1", "median", "q3", "upper", "mean", "outliers"],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  {
    lower: MAX,
    q1: MAX,
    median: MAX,
    q3: MAX,
    upper: MAX,
    mean: MAX,
    outliers: FIRST,
    color: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BULLET, VERTICAL_BULLET],
  ["current", "target"],
  [CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BULLET, VERTICAL_BULLET],
  { current: MAX, target: MAX, color: FIRST, noteText: FIRST }
);
series_binder_default.current.register(
  [PIE, DONUT],
  [VALUE],
  [CATEGORY, COLOR, "explode", "visibleInLegend", "visible", DRILLDOWN_FIELD, PATTERN_FIELD]
);

// node_modules/@progress/kendo-charts/dist/es/chart/chart.js
var AXIS_NAMES = [CATEGORY, VALUE, X, Y];
var MOUSEDOWN = "mousedown";
var MOUSEMOVE = "mousemove";
var CONTEXTMENU = "contextmenu";
var MOUSELEAVE = "mouseleave";
var KEYDOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var MOUSEMOVE_DELAY = 20;
var NO_DATA_OVERLAY_TOP_CLASS = "k-chart-overlay-top";
var Chart = function(Class) {
  function Chart2(element, userOptions, themeOptions, context) {
    var this$1 = this;
    if (context === void 0) context = {};
    Class.call(this);
    this.observers = [];
    this.addObserver(context.observer);
    this.chartService = new chart_service_default(this, context);
    this.chartService.theme = themeOptions;
    this._initElement(element);
    var options = deepExtend({}, this.options, userOptions);
    this._originalOptions = deepExtend({}, options);
    this._theme = themeOptions;
    this._initTheme(options, themeOptions);
    this._focusState = {};
    this._initHandlers();
    this._initSurface();
    this.bindCategories();
    font_loader_default.preloadFonts(userOptions, function() {
      this$1.fontLoaded = true;
      if (!this$1._destroyed) {
        this$1.trigger("init");
        this$1._redraw();
        this$1._attachEvents();
        this$1._restoreOverlayElement();
      }
    });
  }
  if (Class) Chart2.__proto__ = Class;
  Chart2.prototype = Object.create(Class && Class.prototype);
  Chart2.prototype.constructor = Chart2;
  Chart2.prototype._initElement = function _initElement(element) {
    var this$1 = this;
    this._setElementClass(element);
    element.style.position = "relative";
    element.tabIndex = element.getAttribute("tabindex") ? element.getAttribute("tabindex") : 0;
    element.setAttribute("role", "graphics-document document");
    for (var i36 = element.childNodes.length - 1; i36 >= 0; i36--) {
      var child = element.childNodes[i36];
      if (!hasClasses(child, "k-chart-overlay")) {
        element.removeChild(child);
      } else {
        this$1.overlayElement = child;
      }
    }
    this.element = element;
  };
  Chart2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-chart");
  };
  Chart2.prototype._restoreOverlayElement = function _restoreOverlayElement() {
    if (!this.overlayElement) {
      return;
    }
    if (this._hasSeriesData()) {
      this.overlayElement.style.display = "none";
    } else {
      if (!this.options.title || this.options.title && this.options.title.position !== BOTTOM) {
        addClass(this.overlayElement, NO_DATA_OVERLAY_TOP_CLASS);
      } else {
        removeClass(this.overlayElement, NO_DATA_OVERLAY_TOP_CLASS);
      }
      this.overlayElement.style.display = "";
    }
    if (this.overlayElement.parentElement !== this.element) {
      this.element.appendChild(this.overlayElement);
    }
  };
  Chart2.prototype._hasSeriesData = function _hasSeriesData() {
    var series = this.options.series || [];
    var hasData = series.length > 0 && series.some(function(x5) {
      return x5.data && x5.data.length > 0;
    });
    return hasData;
  };
  Chart2.prototype._initTheme = function _initTheme(options, themeOptions) {
    var seriesCopies = [];
    var series = options.series || [];
    for (var i36 = 0; i36 < series.length; i36++) {
      seriesCopies.push(Object.assign({}, series[i36]));
    }
    options.series = seriesCopies;
    resolveAxisAliases(options);
    this.applyDefaults(options, themeOptions);
    if (options.seriesColors === null) {
      delete options.seriesColors;
    }
    if (isString(options.title)) {
      options.title = { text: options.title };
    }
    this.options = deepExtend({}, themeOptions, options);
    this.applySeriesColors();
  };
  Chart2.prototype.getSize = function getSize() {
    var chartArea = this.options.chartArea || {};
    var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);
    var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);
    return {
      width,
      height
    };
  };
  Chart2.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this._size;
    var hasSize = size.width > 0 || size.height > 0;
    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this._size = size;
      this._resize(size, force);
      this.trigger("resize", size);
    } else if (hasSize && this._selections && find(this._selections, function(s10) {
      return !s10.visible;
    })) {
      this._destroySelections();
      this._setupSelection();
    }
  };
  Chart2.prototype._resize = function _resize() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.redraw = function redraw(paneName) {
    this.applyDefaults(this.options);
    this.applySeriesColors();
    if (paneName) {
      var plotArea = this._model._plotArea;
      var pane = plotArea.findPane(paneName);
      plotArea.redraw(pane);
    } else {
      this._redraw();
    }
  };
  Chart2.prototype.getAxis = function getAxis(name2) {
    return findAxisByName(name2, this._plotArea.axes);
  };
  Chart2.prototype.findAxisByName = function findAxisByName2(name2) {
    return this.getAxis(name2);
  };
  Chart2.prototype.findPaneByName = function findPaneByName(name2) {
    var panes = this._plotArea.panes;
    for (var idx = 0; idx < panes.length; idx++) {
      if (panes[idx].options.name === name2) {
        return new chart_pane_default(panes[idx]);
      }
    }
  };
  Chart2.prototype.findPaneByIndex = function findPaneByIndex(idx) {
    var panes = this._plotArea.panes;
    if (panes[idx]) {
      return new chart_pane_default(panes[idx]);
    }
  };
  Chart2.prototype.plotArea = function plotArea() {
    return new chart_plotarea_default(this._plotArea);
  };
  Chart2.prototype.toggleHighlight = function toggleHighlight(show2, filter) {
    var plotArea = this._plotArea;
    var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
    var points;
    if (isFunction(filter)) {
      points = plotArea.filterPoints(filter);
    } else {
      var seriesName, categoryName;
      if (isObject(filter)) {
        seriesName = filter.series;
        categoryName = filter.category;
      } else {
        seriesName = categoryName = filter;
      }
      if (firstSeries.type === DONUT) {
        points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
      } else if (inArray(firstSeries.type, [PIE, FUNNEL, PYRAMID])) {
        points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
      } else {
        points = plotArea.pointsBySeriesName(seriesName);
      }
    }
    if (points) {
      this.togglePointsHighlight(show2, points);
    }
  };
  Chart2.prototype.togglePointsHighlight = function togglePointsHighlight(show2, points) {
    var highlight = this._highlight;
    for (var idx = 0; idx < points.length; idx++) {
      highlight.togglePointHighlight(points[idx], show2);
    }
  };
  Chart2.prototype.showTooltip = function showTooltip(filter) {
    var shared = this._sharedTooltip();
    var ref2 = this;
    var tooltip = ref2._tooltip;
    var plotArea = ref2._plotArea;
    var point, categoryIndex;
    if (isFunction(filter)) {
      point = plotArea.findPoint(filter);
      if (point && shared) {
        categoryIndex = point.categoryIx;
      }
    } else if (shared && defined(filter)) {
      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
    }
    if (shared) {
      if (categoryIndex >= 0) {
        var points = this._plotArea.pointsByCategoryIndex(categoryIndex);
        tooltip.showAt(points);
      }
    } else if (point) {
      tooltip.show(point);
    }
  };
  Chart2.prototype.hideTooltip = function hideTooltip() {
    this._tooltip.hide();
  };
  Chart2.prototype._initSurface = function _initSurface() {
    var surface = this.surface;
    var wrap = this._surfaceWrap();
    var chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      elementSize(wrap, { width: chartArea.width });
    }
    if (chartArea.height) {
      elementSize(wrap, { height: chartArea.height });
    }
    if (!surface || surface.options.type !== this.options.renderAs) {
      this._destroySurface();
      this.surface = drawing_exports.Surface.create(wrap, {
        type: this.options.renderAs
      });
      this.surface.bind("mouseenter", this._surfaceMouseenterHandler);
      this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);
    } else {
      this.surface.clear();
      this.surface.resize();
    }
    this.element._kendoExportVisual = this._kendoExportVisual.bind(this);
  };
  Chart2.prototype._surfaceWrap = function _surfaceWrap() {
    return this.element;
  };
  Chart2.prototype._redraw = function _redraw() {
    var model = this._getModel();
    this._size = {
      width: model.options.width,
      height: model.options.height
    };
    this._destroyView();
    this._setElementAccessibilityAttributes();
    this._model = model;
    this._plotArea = model._plotArea;
    this._legend = model._legend;
    model.renderVisual();
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.setup();
        }
      });
    }
    this._initSurface();
    this.surface.draw(model.visual);
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.play();
        }
      });
    }
    this._tooltip = this._createTooltip();
    this._highlight = new highlight_default();
    this._setupSelection();
    this._createPannable();
    this._createZoomSelection();
    this._createMousewheelZoom();
    this._setComputedStyles();
    this.trigger(RENDER);
    triggerPaneRender(this._plotArea.panes);
    if (!this._navState) {
      this._cancelDomEvents();
    }
    this._redrawFocusHighlight();
  };
  Chart2.prototype._setComputedStyles = function _setComputedStyles() {
    var titleHeight = this.titleHeight();
    this.element.style.setProperty("--kendo-chart-computed-title-height", titleHeight + "px");
  };
  Chart2.prototype._redrawFocusHighlight = function _redrawFocusHighlight() {
    if (this._destroyed) {
      return;
    }
    var ref2 = this;
    var ref_focusState = ref2._focusState;
    var legendInFocus = ref_focusState.legendInFocus;
    var preserveHighlight = ref_focusState.preserveHighlight;
    if (legendInFocus && preserveHighlight) {
      this._focusElement(this._getFocusedLegendItem(), false);
      this._focusState.preserveHighlight = false;
    }
  };
  Chart2.prototype._setElementAccessibilityAttributes = function _setElementAccessibilityAttributes() {
    var titleOptions = this.options.title;
    var title3 = isString(titleOptions) ? titleOptions : titleOptions.description || titleOptions.text;
    if (title3) {
      this.element.setAttribute("aria-roledescription", title3);
    }
  };
  Chart2.prototype._kendoExportVisual = function _kendoExportVisual(size) {
    if (size && size.width && size.height) {
      var chartArea = this._originalOptions.chartArea || {};
      var exportOptions = {
        width: chartArea.width || size.width,
        height: chartArea.height || size.height
      };
      return this.exportVisual(exportOptions);
    }
    return this.exportVisual();
  };
  Chart2.prototype.exportVisual = function exportVisual(exportOptions) {
    var visual;
    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {
      var currentOptions = this.options;
      var options = deepExtend({}, exportOptions.options, {
        chartArea: {
          width: exportOptions.width,
          height: exportOptions.height
        }
      });
      clearMissingValues(this._originalOptions, options);
      this.options = deepExtend({}, this._originalOptions, options);
      this._initTheme(this.options, this._theme);
      this.bindCategories();
      var model = this._getModel();
      model.renderVisual();
      triggerPaneRender(model._plotArea.panes);
      visual = model.visual;
      this.options = currentOptions;
    } else {
      visual = this.surface.exportVisual();
    }
    return visual;
  };
  Chart2.prototype._sharedTooltip = function _sharedTooltip() {
    return this._plotArea instanceof categorical_plotarea_default && this.options.tooltip && this.options.tooltip.shared;
  };
  Chart2.prototype._createPannable = function _createPannable() {
    var options = this.options;
    if (options.pannable !== false) {
      this._pannable = new pannable_default(this._plotArea, options.pannable);
    }
  };
  Chart2.prototype._createZoomSelection = function _createZoomSelection() {
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    if (zoomable !== false && selection !== false) {
      this._zoomSelection = new zoom_selection_default(this, selection);
    }
  };
  Chart2.prototype._createMousewheelZoom = function _createMousewheelZoom() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel;
    if (zoomable !== false && mousewheel !== false) {
      this._mousewheelZoom = new mousewheel_zoom_default(this, mousewheel);
    }
  };
  Chart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    var pannable = this.options.pannable;
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    var mousewheel = (zoomable || {}).mousewheel;
    var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);
    var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);
    var element = this.element;
    if (this._dragZoomEnabled && allowDrag && allowZoom) {
      element.style.touchAction = this._touchAction || "";
      this._dragZoomEnabled = false;
    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {
      element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
    this._toggleDomEvents(!allowDrag, !allowZoom);
  };
  Chart2.prototype._toggleDomEvents = function _toggleDomEvents(drag, zoom) {
    var domEvents = this.domEvents;
    if (!domEvents) {
      return;
    }
    if (domEvents.toggleDrag) {
      domEvents.toggleDrag(drag);
    }
    if (domEvents.toggleZoom) {
      domEvents.toggleZoom(zoom);
    }
  };
  Chart2.prototype._createTooltip = function _createTooltip() {
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var tooltip;
    if (this._sharedTooltip()) {
      tooltip = this._createSharedTooltip(tooltipOptions);
    } else {
      tooltip = new tooltip_default(this.chartService, tooltipOptions);
    }
    return tooltip;
  };
  Chart2.prototype._createSharedTooltip = function _createSharedTooltip(options) {
    return new shared_tooltip_default(this._plotArea, options);
  };
  Chart2.prototype.applyDefaults = function applyDefaults2(options, themeOptions) {
    applyAxisDefaults(options, themeOptions);
    applySeriesDefaults(options, themeOptions);
  };
  Chart2.prototype.applySeriesColors = function applySeriesColors() {
    var options = this.options;
    var series = options.series;
    var colors = options.seriesColors || [];
    for (var i36 = 0; i36 < series.length; i36++) {
      var currentSeries = series[i36];
      var seriesColor = colors[i36 % colors.length];
      var defaults = currentSeries._defaults;
      currentSeries.color = currentSeries.color || seriesColor;
      if (defaults) {
        defaults.color = defaults.color || seriesColor;
      }
    }
  };
  Chart2.prototype._getModel = function _getModel() {
    var options = this.options;
    var plotArea = this._createPlotArea();
    var model = new root_element_default(this._modelOptions());
    model.chart = this;
    model._plotArea = plotArea;
    var title3 = title_default.buildTitle(options.title);
    var subtitle2 = title_default.buildTitle(options.subtitle, {
      align: options.title.align,
      position: options.title.position
    });
    model.append.apply(model, title_default.orderTitles([title3, subtitle2]));
    if (options.legend && options.legend.visible) {
      var legend2 = new legend_default(plotArea.options.legend, this.chartService);
      model.append(legend2);
      model._legend = legend2;
    }
    model.append(plotArea);
    model.reflow();
    this._setTitleBox(title3, subtitle2);
    return model;
  };
  Chart2.prototype._setTitleBox = function _setTitleBox(title3, subtitle2) {
    if (!title3 && !subtitle2) {
      return;
    }
    this._titleBox = (title3 || subtitle2).box.clone();
    var titlePosition = title3 ? title3.options.position : "";
    var subtitlePosition = subtitle2 ? subtitle2.options.position : "";
    var samePosition = titlePosition === subtitlePosition;
    var subtitleAtTop = subtitlePosition !== BOTTOM;
    if (samePosition && subtitle2) {
      this._titleBox.wrap(subtitle2.box);
    } else if (title3 && subtitle2 && subtitleAtTop) {
      this._titleBox = subtitle2.box.clone();
    }
  };
  Chart2.prototype._modelOptions = function _modelOptions() {
    var options = this.options;
    var size = this.getSize();
    return deepExtend({
      transitions: options.transitions,
      width: size.width || DEFAULT_WIDTH,
      height: size.height || DEFAULT_HEIGHT
    }, options.chartArea);
  };
  Chart2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var options = this.options;
    var plotArea = plotarea_factory_default.current.create(skipSeries ? [] : options.series, options, this.chartService);
    return plotArea;
  };
  Chart2.prototype._setupSelection = function _setupSelection() {
    var this$1 = this;
    var ref2 = this;
    var axes = ref2._plotArea.axes;
    var selections = this._selections = [];
    for (var i36 = 0; i36 < axes.length; i36++) {
      var axis = axes[i36];
      var options = axis.options;
      if (axis instanceof category_axis_default && options.select && !options.vertical) {
        var range = axis.range();
        var selection = new selection_default(
          this$1,
          axis,
          deepExtend({ min: range.min, max: range.max }, options.select)
        );
        selections.push(selection);
      }
    }
  };
  Chart2.prototype._selectStart = function _selectStart(e39) {
    return this.trigger(SELECT_START, e39);
  };
  Chart2.prototype._select = function _select(e39) {
    return this.trigger(SELECT2, e39);
  };
  Chart2.prototype._selectEnd = function _selectEnd(e39) {
    return this.trigger(SELECT_END, e39);
  };
  Chart2.prototype._initHandlers = function _initHandlers() {
    this._clickHandler = this._click.bind(this);
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._mousedownHandler = this._mousedown.bind(this);
    this._mousewheelHandler = this._mousewheel.bind(this);
    this._mouseleaveHandler = this._mouseleave.bind(this);
    this._surfaceMouseenterHandler = this._mouseover.bind(this);
    this._surfaceMouseleaveHandler = this._mouseout.bind(this);
    this._mousemove = throttle(
      this._mousemove.bind(this),
      MOUSEMOVE_DELAY
    );
  };
  Chart2.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Chart2.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Chart2.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Chart2.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0) args = {};
    args.sender = this;
    if (name2 === SHOW_TOOLTIP) {
      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);
    } else if (name2 === SERIES_OVER) {
      this._updateDrilldownPoint(args.point);
    } else if (name2 === SERIES_LEAVE) {
      this._resetDrilldownPoint();
    } else if (name2 === SERIES_CLICK) {
      this._focusPoint(args.point);
      this._startDrilldown(args.point);
    } else if (name2 === LEGEND_ITEM_CLICK) {
      this._focusLegendItem(args);
    }
    var observers = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  };
  Chart2.prototype.titleHeight = function titleHeight() {
    if (!this._titleBox) {
      return 0;
    }
    return this._titleBox.height();
  };
  Chart2.prototype._attachEvents = function _attachEvents() {
    var obj, obj$1;
    var element = this.element;
    this._touchAction = element.style.touchAction;
    bindEvents(element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSELEAVE] = this._mouseleaveHandler, obj[KEYDOWN] = this._keydownHandler, obj[MOUSEDOWN] = this._mousedownHandler, obj[FOCUS] = this._focusHandler, obj[BLUR] = this._blurHandler, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents(element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
    this.domEvents = dom_events_builder_default.create(this.element, {
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
    this._toggleDragZoomEvents();
  };
  Chart2.prototype._mouseleave = function _mouseleave(e39) {
    if (this._hoveredPoint) {
      this._hoveredPoint.out(this, e39);
      this._hoveredPoint = null;
    }
    if (this._plotAreaHovered) {
      this._plotAreaHovered = false;
      this.trigger(PLOT_AREA_LEAVE);
    }
    if (this._hasInactiveOpacity() && this._activeChartInstance) {
      this._applySeriesOpacity(this._activeChartInstance.children, null, true);
      this._updateSeriesOpacity(null, true);
    }
  };
  Chart2.prototype._cancelDomEvents = function _cancelDomEvents() {
    if (this.domEvents && this.domEvents.cancel) {
      this.domEvents.cancel();
    }
  };
  Chart2.prototype._gesturestart = function _gesturestart(e39) {
    if (this._mousewheelZoom && !this._stopChartHandlers(e39)) {
      this._gestureDistance = e39.distance;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this.surface.suspendTracking();
    }
  };
  Chart2.prototype._gestureend = function _gestureend(e39) {
    if (this._zooming && !this._stopChartHandlers(e39)) {
      if (this.surface) {
        this.surface.resumeTracking();
      }
      this._zooming = false;
      this.trigger(ZOOM_END, {});
    }
  };
  Chart2.prototype._gesturechange = function _gesturechange(e39) {
    var mousewheelZoom = this._mousewheelZoom;
    if (mousewheelZoom && !this._stopChartHandlers(e39)) {
      e39.preventDefault();
      var previousGestureDistance = this._gestureDistance;
      var scaleDelta = -e39.distance / previousGestureDistance + 1;
      if (Math.abs(scaleDelta) >= 0.1) {
        scaleDelta = Math.round(scaleDelta * 10);
        this._gestureDistance = e39.distance;
        var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e39 };
        if (this._zooming || !this.trigger(ZOOM_START, args)) {
          var coords = this._eventCoordinates(e39);
          if (!this._zooming) {
            this._zooming = true;
          }
          var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);
          if (ranges && !this.trigger(ZOOM, args)) {
            mousewheelZoom.zoom();
          }
        }
      }
    }
  };
  Chart2.prototype._mouseout = function _mouseout(e39) {
    if (e39.element) {
      var element = this._drawingChartElement(e39.element, e39);
      if (element && element.leave) {
        element.leave(this, e39.originalEvent);
      }
    }
  };
  Chart2.prototype._start = function _start(e39) {
    var coords = this._eventCoordinates(e39);
    if (this._stopChartHandlers(e39) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {
      this._startNavigation(e39, coords, DRAG_START);
    }
    if (this._pannable && this._pannable.start(e39)) {
      this.surface.suspendTracking();
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._suppressHover = true;
      this.chartService.panning = true;
    }
    if (this._zoomSelection) {
      if (this._zoomSelection.start(e39)) {
        this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e39 });
      }
    }
  };
  Chart2.prototype._move = function _move(e39) {
    var ref2 = this;
    var state = ref2._navState;
    var pannable = ref2._pannable;
    if (this._stopChartHandlers(e39)) {
      return;
    }
    if (pannable) {
      var ranges = pannable.move(e39);
      if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e39 })) {
        pannable.pan();
      }
    } else if (state) {
      var ranges$1 = {};
      var axes = state.axes;
      for (var i36 = 0; i36 < axes.length; i36++) {
        var currentAxis = axes[i36];
        var axisName = currentAxis.options.name;
        if (axisName) {
          var axis = currentAxis.options.vertical ? e39.y : e39.x;
          var delta = axis.startLocation - axis.location;
          if (delta !== 0) {
            ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);
          }
        }
      }
      state.axisRanges = ranges$1;
      this.trigger(DRAG, {
        axisRanges: ranges$1,
        originalEvent: e39
      });
    }
    if (this._zoomSelection) {
      this._zoomSelection.move(e39);
    }
  };
  Chart2.prototype._end = function _end(e39) {
    if (this._stopChartHandlers(e39)) {
      return;
    }
    var pannable = this._pannable;
    if (pannable && pannable.end(e39)) {
      this.surface.resumeTracking();
      this.trigger(DRAG_END, {
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e39
      });
      this._suppressHover = false;
      this.chartService.panning = false;
    } else {
      this._endNavigation(e39, DRAG_END);
    }
    if (this._zoomSelection) {
      var ranges = this._zoomSelection.end(e39);
      if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e39 })) {
        this._zoomSelection.zoom();
        this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e39 });
      }
    }
  };
  Chart2.prototype._stopChartHandlers = function _stopChartHandlers(e39) {
    var selections = this._selections || [];
    if (!selections.length) {
      return false;
    }
    var coords = this._eventCoordinates(e39);
    var pane = this._plotArea.paneByPoint(coords);
    if (pane) {
      for (var idx = 0; idx < selections.length; idx++) {
        if (selections[idx].onPane(pane)) {
          return true;
        }
      }
    }
  };
  Chart2.prototype._mousewheelZoomRate = function _mousewheelZoomRate() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel || {};
    return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);
  };
  Chart2.prototype._mousewheel = function _mousewheel(e39) {
    var this$1 = this;
    var delta = mousewheelDelta(e39);
    var mousewheelZoom = this._mousewheelZoom;
    var coords = this._eventCoordinates(e39);
    if (this._stopChartHandlers(e39) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (mousewheelZoom) {
      var args = { delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e39 };
      if (this._zooming || !this.trigger(ZOOM_START, args)) {
        e39.preventDefault();
        if (!this._zooming) {
          this._unsetActivePoint();
          this._clearFocusedElement();
          this.surface.suspendTracking();
          this._zooming = true;
        }
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);
        if (args.axisRanges && !this.trigger(ZOOM, args)) {
          mousewheelZoom.zoom();
        }
        this._mwTimeout = setTimeout(function() {
          this$1.trigger(ZOOM_END, args);
          this$1._zooming = false;
          if (this$1.surface) {
            this$1.surface.resumeTracking();
          }
        }, MOUSEWHEEL_DELAY);
      }
    } else {
      var state = this._navState;
      if (!state) {
        var prevented = this._startNavigation(e39, coords, ZOOM_START);
        if (!prevented) {
          state = this._navState;
        }
      }
      if (state) {
        var totalDelta = state.totalDelta || delta;
        state.totalDelta = totalDelta + delta;
        var axes = this._navState.axes;
        var ranges = {};
        for (var i36 = 0; i36 < axes.length; i36++) {
          var currentAxis = axes[i36];
          var axisName = currentAxis.options.name;
          if (axisName) {
            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1._mousewheelZoomRate(), coords);
          }
        }
        this.trigger(ZOOM, {
          delta,
          axisRanges: ranges,
          originalEvent: e39
        });
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        this._mwTimeout = setTimeout(function() {
          this$1._endNavigation(e39, ZOOM_END);
        }, MOUSEWHEEL_DELAY);
      }
    }
  };
  Chart2.prototype._startNavigation = function _startNavigation(e39, coords, chartEvent) {
    var plotArea = this._model._plotArea;
    var pane = plotArea.findPointPane(coords);
    var axes = plotArea.axes.slice(0);
    if (!pane) {
      return;
    }
    var ranges = axisRanges(axes);
    var prevented = this.trigger(chartEvent, {
      axisRanges: ranges,
      originalEvent: e39
    });
    if (prevented) {
      this._cancelDomEvents();
    } else {
      this._suppressHover = true;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._navState = {
        axisRanges: ranges,
        pane,
        axes
      };
    }
  };
  Chart2.prototype._endNavigation = function _endNavigation(e39, chartEvent) {
    if (this._navState) {
      this.trigger(chartEvent, {
        axisRanges: this._navState.axisRanges,
        originalEvent: e39
      });
      this._suppressHover = false;
      this._navState = null;
    }
  };
  Chart2.prototype._getChartElement = function _getChartElement(e39, match) {
    var element = this.surface.eventTarget(e39);
    if (element) {
      return this._drawingChartElement(element, e39, match);
    }
  };
  Chart2.prototype._drawingChartElement = function _drawingChartElement(element, e39, match) {
    var current4 = element;
    var chartElement;
    while (current4 && !chartElement) {
      chartElement = current4.chartElement;
      current4 = current4.parent;
    }
    if (chartElement) {
      if (chartElement.aliasFor) {
        chartElement = chartElement.aliasFor(e39, this._eventCoordinates(e39));
      }
      if (match) {
        chartElement = chartElement.closest(match);
        if (chartElement && chartElement.aliasFor) {
          chartElement = chartElement.aliasFor();
        }
      }
      return chartElement;
    }
  };
  Chart2.prototype._eventCoordinates = function _eventCoordinates(e39) {
    var coordinates = eventCoordinates(e39);
    return this._toModelCoordinates(coordinates.x, coordinates.y);
  };
  Chart2.prototype._elementPadding = function _elementPadding() {
    if (!this._padding) {
      var ref2 = elementStyles(this.element, ["paddingLeft", "paddingTop"]);
      var paddingLeft = ref2.paddingLeft;
      var paddingTop = ref2.paddingTop;
      this._padding = {
        top: paddingTop,
        left: paddingLeft
      };
    }
    return this._padding;
  };
  Chart2.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point) {
    var padding = this._elementPadding();
    var offset = elementOffset(this.element);
    return {
      left: round(point.x + padding.left + offset.left),
      top: round(point.y + padding.top + offset.top)
    };
  };
  Chart2.prototype._toModelCoordinates = function _toModelCoordinates(clientX, clientY) {
    var element = this.element;
    var offset = elementOffset(element);
    var padding = this._elementPadding();
    var inverseTransform = elementScale(element).invert();
    var point = new geometry_exports.Point(
      clientX - offset.left - padding.left,
      clientY - offset.top - padding.top
    ).transform(inverseTransform);
    return new point_default(point.x, point.y);
  };
  Chart2.prototype._tap = function _tap(e39) {
    var this$1 = this;
    var drawingElement = this.surface.eventTarget(e39);
    var element = this._drawingChartElement(drawingElement, e39);
    var sharedTooltip = this._sharedTooltip();
    if (!this._startHover(drawingElement, e39) && !sharedTooltip) {
      this._unsetActivePoint();
    }
    if (sharedTooltip) {
      this._trackSharedTooltip(this._eventCoordinates(e39), e39, true);
    }
    this._propagateClick(element, e39);
    this.handlingTap = true;
    setTimeout(function() {
      this$1.handlingTap = false;
    }, 0);
  };
  Chart2.prototype._click = function _click(e39) {
    var element = this._getChartElement(e39);
    this._propagateClick(element, e39);
  };
  Chart2.prototype._propagateClick = function _propagateClick(element, e39) {
    var this$1 = this;
    var current4 = element;
    while (current4) {
      if (current4.click) {
        current4.click(this$1, e39);
      }
      current4 = current4.parent;
    }
  };
  Chart2.prototype._isLegendBeforeChart = function _isLegendBeforeChart() {
    var ref2 = this;
    var legendPosition = ref2.options.legend.position;
    var legend2 = ref2._legend;
    return legend2 && legend2.hasItems() && (legendPosition === TOP || legendPosition === LEFT);
  };
  Chart2.prototype._focus = function _focus() {
    if (!this._preventInitialPointFocus) {
      if (this._isLegendBeforeChart()) {
        this._focusFirstLegendItem();
      } else {
        this._focusFirstPoint();
      }
    }
    this._preventInitialPointFocus = false;
  };
  Chart2.prototype._keydown = function _keydown(e39) {
    var ref2 = this;
    var ref_focusState = ref2._focusState;
    var legendInFocus = ref_focusState.legendInFocus;
    var focusedElement = ref_focusState.focusedElement;
    var legend2 = ref2._legend;
    if (e39.key === TAB) {
      this._clearFocusedElement();
      var isLegendBeforeChart = this._isLegendBeforeChart();
      if (legendInFocus && isLegendBeforeChart !== e39.shiftKey) {
        this._navigatePoints(e39);
      } else if (!legendInFocus && isLegendBeforeChart === e39.shiftKey && legend2.hasItems()) {
        this._navigateLegend(e39);
      }
    } else if (e39.key === ESCAPE) {
      if (focusedElement) {
        e39.stopPropagation();
      }
      if (this._tooltip && this._tooltip.visible) {
        this._hideTooltip();
      } else {
        this._blur();
      }
    } else if (e39.key === ENTER) {
      if (focusedElement) {
        this._focusState.preserveHighlight = true;
        this._propagateClick(focusedElement, e39);
        this._focusElement(focusedElement);
      }
    } else if (!legendInFocus) {
      this._navigatePoints(e39);
    } else {
      this._navigateLegend(e39);
    }
  };
  Chart2.prototype._navigatePoints = function _navigatePoints(e39) {
    var this$1 = this;
    var ref2 = this;
    var focusState = ref2._focusState;
    var plotArea = ref2._plotArea;
    focusState.legendInFocus = false;
    if (!focusState.focusedElement) {
      this._focusFirstPoint();
      e39.preventDefault();
      return;
    }
    var moveFocus = function(point) {
      focusState.focusedPoint = point;
      this$1._focusElement(focusState.focusedPoint);
      this$1._displayTooltip(point);
      e39.preventDefault();
    };
    switch (e39.key) {
      case ARROW_RIGHT:
        moveFocus(plotArea.getPointToTheRight(focusState.focusedPoint));
        break;
      case ARROW_LEFT:
        moveFocus(plotArea.getPointToTheLeft(focusState.focusedPoint));
        break;
      case ARROW_DOWN:
        moveFocus(plotArea.getPointBelow(focusState.focusedPoint));
        break;
      case ARROW_UP:
        moveFocus(plotArea.getPointAbove(focusState.focusedPoint));
        break;
      default:
        break;
    }
  };
  Chart2.prototype._navigateLegend = function _navigateLegend(e39) {
    var this$1 = this;
    var ref2 = this;
    var focusState = ref2._focusState;
    var legend2 = ref2._legend;
    var rtl = ref2.chartService.rtl;
    focusState.legendInFocus = true;
    if (!focusState.focusedElement) {
      this._focusFirstLegendItem();
      e39.preventDefault();
      return;
    }
    var itemsLength = legend2.getItems().length;
    var moveFocus = function(cycleFunc) {
      focusState.focusedLegendItemIndex = cycleFunc(
        focusState.focusedLegendItemIndex,
        itemsLength
      );
      this$1._focusElement(this$1._getFocusedLegendItem());
      e39.preventDefault();
    };
    switch (e39.key) {
      case ARROW_UP:
      case ARROW_LEFT:
        moveFocus(rtl ? cycleUp : cycleDown);
        break;
      case ARROW_DOWN:
      case ARROW_RIGHT:
        moveFocus(rtl ? cycleDown : cycleUp);
        break;
      default:
        break;
    }
  };
  Chart2.prototype._focusFirstPoint = function _focusFirstPoint() {
    var point = this._focusState.focusedPoint = this._plotArea.getFirstPoint();
    if (point) {
      this._focusElement(point);
      this._displayTooltip(point);
    }
  };
  Chart2.prototype._hasFocus = function _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  };
  Chart2.prototype._mousedown = function _mousedown() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
    }
  };
  Chart2.prototype._focusChart = function _focusChart() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
      this.element.focus();
    }
  };
  Chart2.prototype._focusPoint = function _focusPoint(point) {
    this._focusState.focusedPoint = point;
    this._focusChart();
    this._focusElement(point, true);
  };
  Chart2.prototype._focusFirstLegendItem = function _focusFirstLegendItem() {
    var ref2 = this;
    var focusState = ref2._focusState;
    focusState.focusedLegendItemIndex = 0;
    this._focusElement(this._getFocusedLegendItem());
    focusState.legendInFocus = true;
    this._hideTooltip();
  };
  Chart2.prototype._focusLegendItem = function _focusLegendItem(args) {
    var ref2 = this;
    var focusState = ref2._focusState;
    focusState.focusedLegendItemIndex = this._legend.getItems().findIndex(function(x5) {
      return x5.options.series.index === args.seriesIndex && x5.options.pointIndex === args.pointIndex;
    });
    focusState.legendInFocus = true;
    this._focusChart();
    this._focusElement(this._getFocusedLegendItem(), true);
  };
  Chart2.prototype._getFocusedLegendItem = function _getFocusedLegendItem() {
    var ref2 = this;
    var focusState = ref2._focusState;
    var legend2 = ref2._legend;
    return legend2.getItems()[focusState.focusedLegendItemIndex];
  };
  Chart2.prototype._focusElement = function _focusElement(element, omitHighlight) {
    var ref2 = this;
    var focusState = ref2._focusState;
    this._clearFocusedElement();
    if (!element) {
      return;
    }
    focusState.focusedElement = element;
    this._setElementActiveDescendant(element);
    if (!omitHighlight) {
      element.focusVisual();
      if (focusState.legendInFocus) {
        var options = element.options;
        this._showSeriesInactiveOpacity(options.series.index, options.pointIndex);
      } else {
        this._showInactiveOpacity(element);
      }
    }
  };
  Chart2.prototype._clearFocusedElement = function _clearFocusedElement() {
    var ref2 = this;
    var focusState = ref2._focusState;
    if (!focusState) {
      return;
    }
    if (focusState.focusedElement && focusState.focusedElement.clearFocusFromVisual) {
      focusState.focusedElement.clearFocusFromVisual();
      this._clearElementActiveDescendant();
    }
    focusState.focusedElement = null;
  };
  Chart2.prototype._setElementActiveDescendant = function _setElementActiveDescendant(element) {
    if (this.options.renderAs === "canvas") {
      this._pseudoFocusedElement = this._createPseudoFocusedElement(element);
      this.element.append(this._pseudoFocusedElement);
    }
    this.element.setAttribute(ARIA_ACTIVE_DESCENDANT, element._id);
  };
  Chart2.prototype._clearElementActiveDescendant = function _clearElementActiveDescendant() {
    if (this._pseudoFocusedElement) {
      this._pseudoFocusedElement.remove();
      this._pseudoFocusedElement = null;
    }
    this.element.removeAttribute(ARIA_ACTIVE_DESCENDANT);
  };
  Chart2.prototype._createPseudoFocusedElement = function _createPseudoFocusedElement(element) {
    var pseudoElement = document.createElement("div");
    var accessibilityOptions = element.options.accessibility;
    pseudoElement.id = element._id;
    pseudoElement.setAttribute("aria-label", element.getAriaLabelText());
    pseudoElement.setAttribute("role", accessibilityOptions.role);
    pseudoElement.setAttribute("aria-roledescription", accessibilityOptions.ariaRoleDescription);
    var checked = accessibilityOptions.ariaChecked;
    if (defined(checked)) {
      pseudoElement.setAttribute("aria-checked", checked);
    }
    return pseudoElement;
  };
  Chart2.prototype._blur = function _blur() {
    this._focusState.legendInFocus = false;
    this._clearFocusedElement();
    this._hideInactiveOpacity();
  };
  Chart2.prototype._startHover = function _startHover(element, e39) {
    if (this._suppressHover) {
      return false;
    }
    var point = this._drawingChartElement(element, e39, function(element2) {
      return (element2.hover || element2.over) && !(element2 instanceof plotarea_base_default);
    });
    var activePoint = this._activePoint;
    this._updateHoveredPoint(point, e39);
    if (point && activePoint !== point && point.hover) {
      this._activePoint = point;
      if (!this._sharedTooltip() && !point.hover(this, e39)) {
        this._displayTooltip(point);
        this._showInactiveOpacity(point);
      }
    }
    return point;
  };
  Chart2.prototype._displayTooltip = function _displayTooltip(point) {
    var tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);
    if (tooltipOptions.visible) {
      if (this._sharedTooltip() && point.box) {
        this._trackSharedTooltip(point.box.center(), {});
      } else {
        this._tooltip.show(point);
      }
    }
  };
  Chart2.prototype._hideTooltip = function _hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Chart2.prototype._displayInactiveOpacity = function _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {
    var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);
    if (!chartInstance) {
      return;
    }
    if (multipleSeries) {
      this._updateSeriesOpacity(activePoint);
      this._applySeriesOpacity(chartInstance.children, null, true);
      this._applySeriesOpacity(chartInstance.children, activePoint.series);
      this._highlight.show(highlightPoints || activePoint);
    } else {
      var inactivePoints;
      if (!chartInstance.supportsPointInactiveOpacity()) {
        this._highlight.show(activePoint);
        return;
      }
      inactivePoints = this._getInactivePoints(activePoint, chartInstance);
      if (inactivePoints && inactivePoints.length) {
        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));
      }
    }
  };
  Chart2.prototype._getInactivePoints = function _getInactivePoints(activePoint, chartInstance) {
    var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);
    return allPoints.filter(function(point) {
      return point !== activePoint;
    });
  };
  Chart2.prototype._getAllPointsOfType = function _getAllPointsOfType(container, type) {
    var this$1 = this;
    var points = [];
    for (var i36 = 0; i36 < container.children.length; i36++) {
      var element = container.children[i36];
      if (element.constructor === type) {
        points.push(element);
      } else if (element.children && element.children.length) {
        points = points.concat(this$1._getAllPointsOfType(element, type));
      }
    }
    return points;
  };
  Chart2.prototype._updateHoveredPoint = function _updateHoveredPoint(point, e39) {
    var hoveredPoint = this._hoveredPoint;
    if (hoveredPoint && hoveredPoint !== point) {
      hoveredPoint.out(this, e39);
      this._hoveredPoint = null;
    }
    if (point && hoveredPoint !== point && point.over) {
      this._hoveredPoint = point;
      point.over(this, e39);
    }
  };
  Chart2.prototype._updateDrilldownPoint = function _updateDrilldownPoint(point) {
    if (!point || !point.series) {
      return;
    }
    var ref2 = series_binder_default.current.bindPoint(point.series, null, point.dataItem);
    var fields = ref2.fields;
    if (fields.drilldown) {
      this._drilldownState = { cursor: this.element.style.cursor };
      this.element.style.cursor = "pointer";
    }
  };
  Chart2.prototype._resetDrilldownPoint = function _resetDrilldownPoint() {
    if (this._drilldownState) {
      this.element.style.cursor = this._drilldownState.cursor;
      this._drilldownState = null;
    }
  };
  Chart2.prototype._startDrilldown = function _startDrilldown(point) {
    if (!point || !point.series) {
      return;
    }
    var series = point.series;
    var ref2 = series_binder_default.current.bindPoint(series, null, point.dataItem);
    var fields = ref2.fields;
    var value2 = fields.drilldown;
    if (value2) {
      var args = { series, point, value: value2, sender: this };
      this.trigger(DRILLDOWN, args);
    }
  };
  Chart2.prototype._updateSeriesOpacity = function _updateSeriesOpacity(point, resetOpacity) {
    var this$1 = this;
    var plotArea = this._plotArea;
    var length = plotArea.series.length;
    for (var i36 = 0; i36 < length; i36++) {
      var currSeries = plotArea.series[i36];
      var defaultOpacity = this$1._getDefaultOpacityForSeries(currSeries);
      var inactiveOpacity = this$1._getInactiveOpacityForSeries(currSeries);
      if (!resetOpacity && currSeries !== point.series) {
        currSeries.defaultOpacity = defaultOpacity;
        currSeries.opacity = inactiveOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = inactiveOpacity;
        }
      } else {
        currSeries.opacity = defaultOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = defaultOpacity;
        }
      }
    }
  };
  Chart2.prototype._applySeriesOpacity = function _applySeriesOpacity(elements, activeSeries, reset, series) {
    var this$1 = this;
    for (var i36 = 0; i36 < elements.length; i36++) {
      var element = elements[i36];
      var currSeries = element.series || series;
      var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;
      if (shouldHighlight && element.visual) {
        var opacity = series ? series.opacity : element.series.opacity;
        if (currSeries !== activeSeries || reset) {
          element.visual.opacity(reset ? 1 : opacity);
        }
      }
      if (element.children && element.children.length) {
        this$1._applySeriesOpacity(element.children, activeSeries, reset, element.series);
      }
    }
  };
  Chart2.prototype._chartInstanceFromPoint = function _chartInstanceFromPoint(point) {
    var chartInstance = point.parent;
    while (chartInstance && !chartInstance.plotArea) {
      chartInstance = chartInstance.parent;
    }
    return chartInstance;
  };
  Chart2.prototype._showInactiveOpacity = function _showInactiveOpacity(point) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      this._displayInactiveOpacity(point, multipleSeries);
    } else {
      this._highlight.show(point);
    }
  };
  Chart2.prototype._hideInactiveOpacity = function _hideInactiveOpacity(point) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      if (multipleSeries && this._activeChartInstance) {
        this._updateSeriesOpacity(point, true);
        this._applySeriesOpacity(this._activeChartInstance.children, null, true);
        this._activeChartInstance = null;
      }
      this._highlight && this._highlight.hide();
      this._activePoint = null;
    }
  };
  Chart2.prototype._hasInactiveOpacity = function _hasInactiveOpacity() {
    var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== void 0;
    var hasInactiveOpacity = this.options.series.filter(function(s10) {
      return s10.highlight.inactiveOpacity !== void 0;
    }).length > 0;
    return hasDefaultInactiveOpacity || hasInactiveOpacity;
  };
  Chart2.prototype._getInactiveOpacityForSeries = function _getInactiveOpacityForSeries(series) {
    var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;
    var seriesInactiveOpacity = series.highlight.inactiveOpacity;
    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._getDefaultOpacityForSeries = function _getDefaultOpacityForSeries(series) {
    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._mouseover = function _mouseover(e39) {
    var obj;
    var point = this._startHover(e39.element, e39.originalEvent);
    if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {
      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);
      bindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
    }
  };
  Chart2.prototype._mouseMoveTracking = function _mouseMoveTracking(e39) {
    var obj;
    var ref2 = this;
    var options = ref2.options;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    var point = ref2._activePoint;
    var coords = this._eventCoordinates(e39);
    if (this._plotArea.box.containsPoint(coords)) {
      if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {
        var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);
        if (seriesPoint && seriesPoint !== point) {
          this._activePoint = seriesPoint;
          if (!seriesPoint.hover(this, e39)) {
            var tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);
            if (tooltipOptions.visible) {
              tooltip.show(seriesPoint);
            }
            highlight.show(seriesPoint);
          }
        }
      }
    } else {
      unbindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._mouseMoveTrackHandler = null;
      this._hideInactiveOpacity(point);
    }
  };
  Chart2.prototype._mousemove = function _mousemove(e39) {
    var coords = this._eventCoordinates(e39);
    var plotArea = this._plotArea;
    this._trackCrosshairs(coords);
    if (plotArea.hover) {
      var overPlotArea = plotArea.backgroundContainsPoint(coords);
      if (overPlotArea) {
        this._plotAreaHovered = true;
        this._plotArea.hover(this, e39);
      } else if (this._plotAreaHovered && !overPlotArea) {
        this._plotAreaHovered = false;
        this.trigger(PLOT_AREA_LEAVE);
      }
    }
    if (this._sharedTooltip()) {
      this._trackSharedTooltip(coords, e39);
    }
  };
  Chart2.prototype._trackCrosshairs = function _trackCrosshairs(coords) {
    var crosshairs = this._plotArea.crosshairs;
    for (var i36 = 0; i36 < crosshairs.length; i36++) {
      var current4 = crosshairs[i36];
      if (current4.box.containsPoint(coords)) {
        current4.showAt(coords);
      } else {
        current4.hide();
      }
    }
  };
  Chart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords, e39, toggle) {
    if (this._suppressHover) {
      return;
    }
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var plotArea = ref2._plotArea;
    var categoryAxis = ref2._plotArea.categoryAxis;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    if (plotArea.backgroundContainsPoint(coords)) {
      var index = categoryAxis.pointCategoryIndex(coords);
      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {
        var points = plotArea.pointsByCategoryIndex(index);
        var pointArgs = points.map(function(point) {
          return point.eventArgs(e39);
        });
        var hoverArgs = pointArgs[0] || {};
        hoverArgs.categoryPoints = pointArgs;
        if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {
          if (tooltipOptions.visible) {
            tooltip.showAt(points, coords);
          }
          highlight.show(points);
          this._sharedHighlight = true;
        } else {
          tooltip.hide();
        }
        this._tooltipCategoryIx = index;
      } else if (toggle && this._sharedHighlight) {
        highlight.hide();
        tooltip.hide();
        this._sharedHighlight = false;
      }
    } else if (this._sharedHighlight) {
      highlight.hide();
      tooltip.hide();
      this._tooltipCategoryIx = null;
      this._sharedHighlight = false;
    }
  };
  Chart2.prototype.hideElements = function hideElements(options) {
    var plotArea = this._plotArea;
    this._mousemove.cancel();
    plotArea.hideCrosshairs();
    this._unsetActivePoint(options);
  };
  Chart2.prototype._unsetActivePoint = function _unsetActivePoint(options) {
    var ref2 = this;
    var highlight = ref2._highlight;
    this._activePoint = null;
    this._hoveredPoint = null;
    if (!options || !options.keepTooltipOpen) {
      this._hideTooltip();
    }
    this._tooltipCategoryIx = null;
    this._sharedHighlight = false;
    if (highlight) {
      highlight.hide();
    }
  };
  Chart2.prototype._deferRedraw = function _deferRedraw() {
    this._redraw();
  };
  Chart2.prototype._clearRedrawTimeout = function _clearRedrawTimeout() {
    if (this._redrawTimeout) {
      clearInterval(this._redrawTimeout);
      this._redrawTimeout = null;
    }
  };
  Chart2.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var options = this.options;
    var definitions = [].concat(options.categoryAxis);
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.autoBind !== false) {
        this$1.bindCategoryAxisFromSeries(axis, axisIx);
      }
    }
  };
  Chart2.prototype.bindCategoryAxisFromSeries = function bindCategoryAxisFromSeries(axis, axisIx) {
    var this$1 = this;
    var uniqueCategories = /* @__PURE__ */ new Set();
    var seriesOnAxis = this.options.series.filter(function(series) {
      return series.categoryAxis === axis.name || !series.categoryAxis && axisIx === 0;
    });
    var hasCategoryBinding = seriesOnAxis.some(function(series) {
      return Boolean(series.categoryField);
    });
    var seriesWithData = seriesOnAxis.filter(function(series) {
      return series.data && series.data.length > 0;
    });
    var categorySamples = seriesWithData.map(function(series) {
      return series_binder_default.current.bindPoint(series, 0).fields.category;
    });
    var dateAxis = categorySamples.reduce(function(result, firstCategory) {
      return result || isDateAxis(axis, firstCategory);
    }, false);
    var seriesWithBinding = seriesWithData.filter(function(series, seriesIx) {
      return series.categoryField || defined(categorySamples[seriesIx]);
    });
    seriesWithBinding.forEach(function(series) {
      return series.data.forEach(function(row, index) {
        var category = series_binder_default.current.bindPoint(series, index).fields.category;
        if (dateAxis) {
          var date = parseDateCategory(category, row, this$1.chartService.intl);
          category = date ? date.getTime() : void 0;
        }
        uniqueCategories.add(category);
      });
    });
    if (uniqueCategories.size > 0) {
      var categories = Array.from(uniqueCategories.values());
      if (dateAxis) {
        categories = categories.sort().map(function(time) {
          return time && new Date(time);
        });
      }
      axis.categories = categories;
    } else if (hasCategoryBinding) {
      axis.categories = [];
    }
  };
  Chart2.prototype._isBindable = function _isBindable(series) {
    var valueFields = series_binder_default.current.valueFields(series);
    var result = true;
    for (var i36 = 0; i36 < valueFields.length; i36++) {
      var field = valueFields[i36];
      if (field === VALUE) {
        field = "field";
      } else {
        field = field + "Field";
      }
      if (!defined(series[field])) {
        result = false;
        break;
      }
    }
    return result;
  };
  Chart2.prototype._noTransitionsRedraw = function _noTransitionsRedraw() {
    var options = this.options;
    var transitionsState;
    if (options.transitions !== false) {
      options.transitions = false;
      transitionsState = true;
    }
    this._redraw();
    if (transitionsState) {
      options.transitions = true;
    }
  };
  Chart2.prototype._legendItemHover = function _legendItemHover(seriesIndex, pointIndex) {
    this._showSeriesInactiveOpacity(seriesIndex, pointIndex);
  };
  Chart2.prototype._showSeriesInactiveOpacity = function _showSeriesInactiveOpacity(seriesIndex, pointIndex) {
    var ref2 = this;
    var plotArea = ref2._plotArea;
    var highlight = ref2._highlight;
    var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
    var items;
    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL, PYRAMID])) {
      items = plotArea.findPoint(function(point2) {
        return point2.series.index === seriesIndex && point2.index === pointIndex;
      });
    } else {
      items = plotArea.pointsBySeriesIndex(seriesIndex);
    }
    if (this._hasInactiveOpacity() && currentSeries.visible && items) {
      var multipleSeries = plotArea.series.length > 1;
      var point = items.length ? items[0] : items;
      this._displayInactiveOpacity(point, multipleSeries, items);
    } else {
      highlight.show(items);
    }
  };
  Chart2.prototype._shouldAttachMouseMove = function _shouldAttachMouseMove() {
    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);
  };
  Chart2.prototype.updateMouseMoveHandler = function updateMouseMoveHandler() {
    var obj, obj$1;
    unbindEvents(this.element, (obj = {}, obj[MOUSEMOVE] = this._mousemove, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents(this.element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
  };
  Chart2.prototype.applyOptions = function applyOptions(options, theme) {
    clearMissingValues(this._originalOptions, options);
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    if (theme) {
      this._theme = theme;
      this.chartService.theme = theme;
    }
    this._initTheme(this.options, this._theme);
    this._toggleDragZoomEvents();
  };
  Chart2.prototype.setOptions = function setOptions(options, theme) {
    this.applyOptions(options, theme);
    this.bindCategories();
    this.redraw();
    this.updateMouseMoveHandler();
    this._restoreOverlayElement();
  };
  Chart2.prototype.setDirection = function setDirection(rtl) {
    this.chartService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this._destroySurface();
    }
  };
  Chart2.prototype.setIntlService = function setIntlService(intl) {
    this.chartService.intl = intl;
  };
  Chart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.destroy = function destroy() {
    var obj, obj$1;
    this._destroyed = true;
    unbindEvents(this.element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSEMOVE] = this._mousemove, obj[MOUSELEAVE] = this._mouseleaveHandler, obj[KEYDOWN] = this._keydownHandler, obj[FOCUS] = this._focusHandler, obj[BLUR] = this._blurHandler, obj));
    if (this.domEvents) {
      this.domEvents.destroy();
      delete this.domEvents;
    }
    if (this._mouseMoveTrackHandler) {
      unbindEvents(document, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mouseMoveTrackHandler, obj$1));
    }
    this._focusState = null;
    this._destroyView();
    this._destroySurface();
    this._clearRedrawTimeout();
  };
  Chart2.prototype._destroySurface = function _destroySurface() {
    var surface = this.surface;
    if (surface) {
      surface.unbind("mouseenter", this._surfaceMouseenterHandler);
      surface.unbind("mouseleave", this._surfaceMouseleaveHandler);
      surface.destroy();
      this.surface = null;
    }
  };
  Chart2.prototype._destroySelections = function _destroySelections() {
    var selections = this._selections;
    if (selections) {
      while (selections.length > 0) {
        selections.shift().destroy();
      }
    }
  };
  Chart2.prototype._destroyView = function _destroyView() {
    var model = this._model;
    if (model) {
      model.destroy();
      this._model = null;
    }
    this._unsetActivePoint();
    this._clearFocusedElement();
    this._resetDrilldownPoint();
    this._destroySelections();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this._highlight) {
      this._highlight.destroy();
    }
    if (this._zoomSelection) {
      this._zoomSelection.destroy();
      delete this._zoomSelection;
    }
    if (this._pannable) {
      this._pannable.destroy();
      delete this._pannable;
    }
    if (this._mousewheelZoom) {
      this._mousewheelZoom.destroy();
      delete this._mousewheelZoom;
    }
  };
  return Chart2;
}(class_default);
function resolveAxisAliases(options) {
  var aliases = AXIS_NAMES;
  for (var idx = 0; idx < aliases.length; idx++) {
    var alias = aliases[idx] + "Axes";
    if (options[alias]) {
      options[aliases[idx] + "Axis"] = options[alias];
      delete options[alias];
    }
  }
}
function pointByCategoryName(points, name2) {
  if (points) {
    for (var idx = 0; idx < points.length; idx++) {
      if (points[idx].category === name2) {
        return [points[idx]];
      }
    }
  }
}
function applyAxisDefaults(options, themeOptions) {
  var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};
  var axisName, axisDefaults2, axes;
  function mapAxisOptions(axisOptions2) {
    var axisColor = (axisOptions2 || {}).color || axisDefaults2.color;
    var result = deepExtend(
      {},
      themeAxisDefaults,
      themeAxisDefaults[axisName],
      axisDefaults2,
      axisDefaults2[axisName],
      {
        line: { color: axisColor },
        labels: { color: axisColor },
        title: { color: axisColor }
      },
      axisOptions2
    );
    delete result[axisName];
    return result;
  }
  for (var idx = 0; idx < AXIS_NAMES.length; idx++) {
    axisName = AXIS_NAMES[idx] + "Axis";
    axisDefaults2 = options.axisDefaults || {};
    axes = [].concat(options[axisName]);
    axes = axes.map(mapAxisOptions);
    options[axisName] = axes.length > 1 ? axes : axes[0];
  }
}
function applySeriesDefaults(options, themeOptions) {
  var series = options.series;
  var seriesLength = series.length;
  var seriesDefaults2 = options.seriesDefaults;
  var commonDefaults = deepExtend({}, options.seriesDefaults);
  var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};
  var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);
  cleanupNestedSeriesDefaults(commonDefaults);
  cleanupNestedSeriesDefaults(commonThemeDefaults);
  for (var i36 = 0; i36 < seriesLength; i36++) {
    var seriesType = series[i36].type || options.seriesDefaults.type;
    var baseOptions = deepExtend(
      { data: [] },
      commonThemeDefaults,
      themeSeriesDefaults[seriesType],
      { tooltip: options.tooltip },
      commonDefaults,
      seriesDefaults2[seriesType]
    );
    series[i36]._defaults = baseOptions;
    series[i36] = deepExtend({}, baseOptions, series[i36]);
    series[i36].data = series[i36].data || [];
  }
}
function cleanupNestedSeriesDefaults(seriesDefaults2) {
  delete seriesDefaults2.bar;
  delete seriesDefaults2.column;
  delete seriesDefaults2.rangeColumn;
  delete seriesDefaults2.line;
  delete seriesDefaults2.verticalLine;
  delete seriesDefaults2.pie;
  delete seriesDefaults2.donut;
  delete seriesDefaults2.area;
  delete seriesDefaults2.verticalArea;
  delete seriesDefaults2.scatter;
  delete seriesDefaults2.scatterLine;
  delete seriesDefaults2.bubble;
  delete seriesDefaults2.candlestick;
  delete seriesDefaults2.ohlc;
  delete seriesDefaults2.boxPlot;
  delete seriesDefaults2.bullet;
  delete seriesDefaults2.verticalBullet;
  delete seriesDefaults2.polarArea;
  delete seriesDefaults2.polarLine;
  delete seriesDefaults2.radarArea;
  delete seriesDefaults2.radarLine;
  delete seriesDefaults2.waterfall;
}
function axisRanges(axes) {
  var ranges = {};
  for (var i36 = 0; i36 < axes.length; i36++) {
    var axis = axes[i36];
    var axisName = axis.options.name;
    if (axisName) {
      ranges[axisName] = axis.range();
    }
  }
  return ranges;
}
var DATA_FIELDS = ["data", "categories"];
function clearMissingValues(originalOptions, options) {
  for (var field in options) {
    if (!inArray(field, DATA_FIELDS) && hasOwnProperty(options, field)) {
      var fieldValue = options[field];
      var originalValue = originalOptions[field];
      if (defined(originalValue)) {
        var nullValue = fieldValue === null;
        if (nullValue || !defined(fieldValue)) {
          delete originalOptions[field];
          if (nullValue) {
            delete options[field];
          }
        } else if (originalValue && isObject(fieldValue)) {
          if (isObject(originalValue)) {
            clearMissingValues(originalValue, fieldValue);
          }
        }
      }
    }
  }
}
function triggerPaneRender(panes) {
  for (var idx = 0; idx < panes.length; idx++) {
    panes[idx].notifyRender();
  }
}
setDefaultOptions(Chart, {
  renderAs: "",
  chartArea: {},
  legend: {
    visible: true,
    labels: {},
    accessibility: {},
    focusHighlight: {
      border: {
        opacity: 1,
        color: BLACK,
        width: 2
      }
    }
  },
  categoryAxis: {},
  seriesDefaults: {
    type: COLUMN,
    data: [],
    highlight: {
      visible: true
    },
    labels: {},
    negativeValues: {
      visible: false
    },
    accessibility: {},
    focusHighlight: {
      border: {
        opacity: 1,
        width: 2
      },
      zIndex: 200
    }
  },
  series: [],
  seriesColors: null,
  tooltip: {
    visible: false
  },
  transitions: true,
  valueAxis: {},
  plotArea: {},
  title: {},
  xAxis: {},
  yAxis: {},
  panes: [{}],
  pannable: false,
  zoomable: false
});
var chart_default = Chart;

// node_modules/@progress/kendo-charts/dist/es/sparkline/shared-tooltip.js
var TOP_OFFSET = -2;
var SharedTooltip2 = function(ChartSharedTooltip) {
  function SharedTooltip3() {
    ChartSharedTooltip.apply(this, arguments);
  }
  if (ChartSharedTooltip) SharedTooltip3.__proto__ = ChartSharedTooltip;
  SharedTooltip3.prototype = Object.create(ChartSharedTooltip && ChartSharedTooltip.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(coords, slot) {
    var axis = this.plotArea.categoryAxis;
    var vertical = axis.options.vertical;
    var align = vertical ? {
      horizontal: "left",
      vertical: "center"
    } : {
      horizontal: "center",
      vertical: "bottom"
    };
    var point;
    if (vertical) {
      point = new point_default(this.plotArea.box.x2, slot.center().y);
    } else {
      point = new point_default(slot.center().x, TOP_OFFSET);
    }
    return {
      point,
      align
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point, slot) {
    return this._slotAnchor({}, slot);
  };
  return SharedTooltip3;
}(shared_tooltip_default);
var shared_tooltip_default2 = SharedTooltip2;

// node_modules/@progress/kendo-charts/dist/es/sparkline/sparkline.js
var DEAULT_BAR_WIDTH = 150;
var DEAULT_BULLET_WIDTH = 150;
var NO_CROSSHAIR = [BAR, BULLET];
function hide(children) {
  var state = [];
  for (var idx = 0; idx < children.length; idx++) {
    var child = children[idx];
    state[idx] = child.style.display;
    child.style.display = "none";
  }
  return state;
}
function show(children, state) {
  for (var idx = 0; idx < children.length; idx++) {
    children[idx].style.display = state[idx];
  }
}
function wrapNumber(value2) {
  return isNumber(value2) ? [value2] : value2;
}
var Sparkline = function(Chart2) {
  function Sparkline2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2) Sparkline2.__proto__ = Chart2;
  Sparkline2.prototype = Object.create(Chart2 && Chart2.prototype);
  Sparkline2.prototype.constructor = Sparkline2;
  Sparkline2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-sparkline");
  };
  Sparkline2.prototype._initElement = function _initElement(element) {
    Chart2.prototype._initElement.call(this, element);
    this._initialWidth = Math.floor(elementSize(element).width);
  };
  Sparkline2.prototype._resize = function _resize() {
    var element = this.element;
    var state = hide(element.childNodes);
    this._initialWidth = Math.floor(elementSize(element).width);
    show(element.childNodes, state);
    Chart2.prototype._resize.call(this);
  };
  Sparkline2.prototype._modelOptions = function _modelOptions() {
    var chartOptions = this.options;
    var stage = this._surfaceWrap();
    var displayState = hide(stage.childNodes);
    var space = document.createElement("span");
    space.innerHTML = "&nbsp;";
    stage.appendChild(space);
    var options = deepExtend({
      width: this._autoWidth,
      height: elementSize(stage).height,
      transitions: chartOptions.transitions
    }, chartOptions.chartArea, {
      inline: true,
      align: false
    });
    elementSize(stage, {
      width: options.width,
      height: options.height
    });
    stage.removeChild(space);
    show(stage.childNodes, displayState);
    if (this.surface) {
      this.surface.resize();
    }
    return options;
  };
  Sparkline2.prototype._surfaceWrap = function _surfaceWrap() {
    if (!this.stage) {
      var stage = this.stage = document.createElement("span");
      this.element.appendChild(stage);
    }
    return this.stage;
  };
  Sparkline2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var plotArea = Chart2.prototype._createPlotArea.call(this, skipSeries);
    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);
    return plotArea;
  };
  Sparkline2.prototype._calculateWidth = function _calculateWidth(plotArea) {
    var options = this.options;
    var margin = getSpacing(options.chartArea.margin);
    var charts = plotArea.charts;
    var stage = this._surfaceWrap();
    var total3 = 0;
    for (var i36 = 0; i36 < charts.length; i36++) {
      var currentChart = charts[i36];
      var firstSeries = (currentChart.options.series || [])[0];
      if (!firstSeries) {
        continue;
      }
      if (firstSeries.type === BAR) {
        return DEAULT_BAR_WIDTH;
      }
      if (firstSeries.type === BULLET) {
        return DEAULT_BULLET_WIDTH;
      }
      if (firstSeries.type === PIE) {
        return elementSize(stage).height;
      }
      var categoryAxis = currentChart.categoryAxis;
      if (categoryAxis) {
        var pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);
        total3 = Math.max(total3, pointsCount);
      }
    }
    var size = total3 * options.pointWidth;
    if (size > 0) {
      size += margin.left + margin.right;
    }
    return size;
  };
  Sparkline2.prototype._createSharedTooltip = function _createSharedTooltip(options) {
    return new shared_tooltip_default2(this._plotArea, options);
  };
  Sparkline2.normalizeOptions = function normalizeOptions(userOptions) {
    var options = wrapNumber(userOptions);
    if (isArray(options)) {
      options = { seriesDefaults: { data: options } };
    } else {
      options = deepExtend({}, options);
    }
    if (!options.series) {
      options.series = [{ data: wrapNumber(options.data) }];
    }
    deepExtend(options, {
      seriesDefaults: {
        type: options.type
      }
    });
    if (inArray(options.series[0].type, NO_CROSSHAIR) || inArray(options.seriesDefaults.type, NO_CROSSHAIR)) {
      options = deepExtend({}, {
        categoryAxis: {
          crosshair: {
            visible: false
          }
        }
      }, options);
    }
    return options;
  };
  return Sparkline2;
}(chart_default);
setDefaultOptions(Sparkline, {
  chartArea: {
    margin: 2
  },
  axisDefaults: {
    visible: false,
    majorGridLines: {
      visible: false
    },
    valueAxis: {
      narrowRange: true
    }
  },
  seriesDefaults: {
    type: "line",
    area: {
      line: {
        width: 0.5
      }
    },
    bar: {
      stack: true
    },
    padding: 2,
    width: 0.5,
    overlay: {
      gradient: null
    },
    highlight: {
      visible: false
    },
    border: {
      width: 0
    },
    markers: {
      size: 2,
      visible: false
    }
  },
  tooltip: {
    visible: true,
    shared: true
  },
  categoryAxis: {
    crosshair: {
      visible: true,
      tooltip: {
        visible: false
      }
    }
  },
  legend: {
    visible: false
  },
  transitions: false,
  pointWidth: 5,
  panes: [{ clip: false }]
});
var sparkline_default = Sparkline;

// node_modules/@progress/kendo-charts/dist/es/stock/fade-out-animation.js
var FadeOutAnimation = function(superclass) {
  function FadeOutAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) FadeOutAnimation2.__proto__ = superclass;
  FadeOutAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeOutAnimation2.prototype.constructor = FadeOutAnimation2;
  FadeOutAnimation2.prototype.setup = function setup() {
    this._initialOpacity = parseFloat(elementStyles(this.element, "opacity").opacity);
  };
  FadeOutAnimation2.prototype.step = function step(pos) {
    elementStyles(this.element, {
      opacity: String(interpolateValue(this._initialOpacity, 0, pos))
    });
  };
  FadeOutAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    elementStyles(this.element, {
      display: "none",
      opacity: String(this._initialOpacity)
    });
  };
  FadeOutAnimation2.prototype.cancel = function cancel() {
    superclass.prototype.abort.call(this);
    elementStyles(this.element, {
      opacity: String(this._initialOpacity)
    });
  };
  return FadeOutAnimation2;
}(drawing_exports.Animation);
var fade_out_animation_default = FadeOutAnimation;

// node_modules/@progress/kendo-charts/dist/es/stock/navigator-hint.js
function createDiv2(className, style) {
  var div = document.createElement("div");
  div.className = className;
  if (style) {
    div.style.cssText = style;
  }
  return div;
}
var NavigatorHint = function(Class) {
  function NavigatorHint2(container, chartService, options) {
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.container = container;
    this.chartService = chartService;
    var padding = elementStyles(container, ["paddingLeft", "paddingTop"]);
    this.chartPadding = {
      top: padding.paddingTop,
      left: padding.paddingLeft
    };
    this.createElements();
    container.appendChild(this.element);
  }
  if (Class) NavigatorHint2.__proto__ = Class;
  NavigatorHint2.prototype = Object.create(Class && Class.prototype);
  NavigatorHint2.prototype.constructor = NavigatorHint2;
  NavigatorHint2.prototype.createElements = function createElements() {
    var element = this.element = createDiv2("k-navigator-hint", "display: none; position: absolute; top: 1px; left: 1px;");
    var tooltip = this.tooltip = createDiv2("k-tooltip k-chart-tooltip");
    var scroll = this.scroll = createDiv2("k-scroll");
    tooltip.innerHTML = "&nbsp;";
    element.appendChild(tooltip);
    element.appendChild(scroll);
  };
  NavigatorHint2.prototype.show = function show2(from, to, bbox) {
    var ref2 = this;
    var element = ref2.element;
    var options = ref2.options;
    var scroll = ref2.scroll;
    var tooltip = ref2.tooltip;
    var middle = toDate(toTime(from) + toTime(to - from) / 2);
    var scrollWidth = bbox.width() * 0.4;
    var minPos = bbox.center().x - scrollWidth;
    var maxPos = bbox.center().x;
    var posRange = maxPos - minPos;
    var range = options.max - options.min;
    var scale = posRange / range;
    var offset = middle - options.min;
    var text = this.chartService.intl.format(options.format, from, to);
    var template = getTemplate(options);
    this.clearHideTimeout();
    if (!this._visible) {
      elementStyles(element, {
        visibility: "hidden",
        display: "block"
      });
      this._visible = true;
    }
    if (template) {
      text = template({
        from,
        to
      });
    }
    tooltip.innerHTML = text;
    elementStyles(tooltip, {
      left: bbox.center().x - tooltip.offsetWidth / 2,
      top: bbox.y1
    });
    var tooltipStyle = elementStyles(tooltip, ["marginTop", "borderTopWidth", "height"]);
    elementStyles(scroll, {
      width: scrollWidth,
      left: minPos + offset * scale,
      top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2
    });
    elementStyles(element, {
      visibility: "visible"
    });
  };
  NavigatorHint2.prototype.clearHideTimeout = function clearHideTimeout() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    if (this._hideAnimation) {
      this._hideAnimation.cancel();
    }
  };
  NavigatorHint2.prototype.hide = function hide2() {
    var this$1 = this;
    this.clearHideTimeout();
    this._hideTimeout = setTimeout(function() {
      this$1._visible = false;
      this$1._hideAnimation = new fade_out_animation_default(this$1.element);
      this$1._hideAnimation.setup();
      this$1._hideAnimation.play();
    }, this.options.hideDelay);
  };
  NavigatorHint2.prototype.destroy = function destroy() {
    this.clearHideTimeout();
    if (this.container) {
      this.container.removeChild(this.element);
    }
    delete this.container;
    delete this.chartService;
    delete this.element;
    delete this.tooltip;
    delete this.scroll;
  };
  return NavigatorHint2;
}(class_default);
setDefaultOptions(NavigatorHint, {
  format: "{0:d} - {1:d}",
  hideDelay: 500
});
var navigator_hint_default = NavigatorHint;

// node_modules/@progress/kendo-charts/dist/es/stock/constants.js
var NAVIGATOR_PANE = "_navigator";
var NAVIGATOR_AXIS = NAVIGATOR_PANE;
var DEFAULT_PANE = "_default";

// node_modules/@progress/kendo-charts/dist/es/stock/navigator.js
var ZOOM_ACCELERATION2 = 3;
var Navigator = function(Class) {
  function Navigator3(chart) {
    var obj;
    Class.call(this);
    this.chart = chart;
    var options = this.options = deepExtend({}, this.options, chart.options.navigator);
    var select = options.select;
    if (select) {
      select.from = this.parseDate(select.from);
      select.to = this.parseDate(select.to);
    }
    if (!defined(options.hint.visible)) {
      options.hint.visible = options.visible;
    }
    this.chartObserver = new instance_observer_default(this, (obj = {}, obj[DRAG] = "_drag", obj[DRAG_END] = "_dragEnd", obj[ZOOM] = "_zoom", obj[ZOOM_END] = "_zoomEnd", obj));
    chart.addObserver(this.chartObserver);
  }
  if (Class) Navigator3.__proto__ = Class;
  Navigator3.prototype = Object.create(Class && Class.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.parseDate = function parseDate$1(value2) {
    return parseDate(this.chart.chartService.intl, value2);
  };
  Navigator3.prototype.clean = function clean() {
    if (this.selection) {
      this.selection.destroy();
      this.selection = null;
    }
    if (this.hint) {
      this.hint.destroy();
      this.hint = null;
    }
  };
  Navigator3.prototype.destroy = function destroy() {
    if (this.chart) {
      this.chart.removeObserver(this.chartObserver);
      delete this.chart;
    }
    this.clean();
  };
  Navigator3.prototype.redraw = function redraw() {
    this._redrawSelf();
    this.initSelection();
  };
  Navigator3.prototype.initSelection = function initSelection() {
    var ref2 = this;
    var chart = ref2.chart;
    var options = ref2.options;
    var axis = this.mainAxis();
    var ref$1 = axis.roundedRange();
    var min4 = ref$1.min;
    var max3 = ref$1.max;
    var ref$2 = options.select;
    var from = ref$2.from;
    var to = ref$2.to;
    var mousewheel = ref$2.mousewheel;
    var axisClone = clone2(axis);
    if (axis.categoriesCount() === 0) {
      return;
    }
    this.clean();
    axisClone.box = axis.box;
    this.selection = new selection_default(chart, axisClone, {
      min: min4,
      max: max3,
      from: from || min4,
      to: to || max3,
      mousewheel: valueOrDefault(mousewheel, { zoom: "left" }),
      visible: options.visible
    }, new instance_observer_default(this, {
      selectStart: "_selectStart",
      select: "_select",
      selectEnd: "_selectEnd"
    }));
    if (options.hint.visible) {
      this.hint = new navigator_hint_default(chart.element, chart.chartService, {
        min: min4,
        max: max3,
        template: getTemplate(options.hint),
        format: options.hint.format
      });
    }
  };
  Navigator3.prototype.setRange = function setRange() {
    var plotArea = this.chart._createPlotArea(true);
    var axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    var ref2 = axis.roundedRange();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var select = this.options.select || {};
    var from = select.from || min4;
    if (from < min4) {
      from = min4;
    }
    var to = select.to || max3;
    if (to > max3) {
      to = max3;
    }
    this.options.select = deepExtend({}, select, {
      from,
      to
    });
    this.filterAxes();
  };
  Navigator3.prototype._redrawSelf = function _redrawSelf(silent) {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      plotArea.redraw(last(plotArea.panes), silent);
    }
  };
  Navigator3.prototype.redrawSlaves = function redrawSlaves() {
    var chart = this.chart;
    var plotArea = chart._plotArea;
    var slavePanes = plotArea.panes.filter(function(pane) {
      return pane.options.name !== NAVIGATOR_PANE;
    });
    plotArea.srcSeries = chart.options.series;
    plotArea.options.categoryAxis = chart.options.categoryAxis;
    plotArea.clearSeriesPointsCache();
    plotArea.redraw(slavePanes);
  };
  Navigator3.prototype._drag = function _drag(e39) {
    var ref2 = this;
    var chart = ref2.chart;
    var selection = ref2.selection;
    var coords = chart._eventCoordinates(e39.originalEvent);
    var navigatorAxis = this.mainAxis();
    var naviRange = navigatorAxis.roundedRange();
    var inNavigator = navigatorAxis.pane.box.containsPoint(coords);
    var axis = chart._plotArea.categoryAxis;
    var range = e39.axisRanges[axis.options.name];
    var select = this.options.select;
    var duration2;
    if (!range || inNavigator || !selection) {
      return;
    }
    if (select.from && select.to) {
      duration2 = toTime(select.to) - toTime(select.from);
    } else {
      duration2 = toTime(selection.options.to) - toTime(selection.options.from);
    }
    var from = toDate(limitValue(
      toTime(range.min),
      naviRange.min,
      toTime(naviRange.max) - duration2
    ));
    var to = toDate(limitValue(
      toTime(from) + duration2,
      toTime(naviRange.min) + duration2,
      naviRange.max
    ));
    this.options.select = { from, to };
    if (this.options.liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(from, to);
    this.showHint(from, to);
  };
  Navigator3.prototype._dragEnd = function _dragEnd() {
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    if (this.hint) {
      this.hint.hide();
    }
  };
  Navigator3.prototype.readSelection = function readSelection() {
    var ref2 = this;
    var ref_selection_options = ref2.selection.options;
    var from = ref_selection_options.from;
    var to = ref_selection_options.to;
    var select = ref2.options.select;
    select.from = from;
    select.to = to;
  };
  Navigator3.prototype.filterAxes = function filterAxes() {
    var ref2 = this;
    var select = ref2.options.select;
    if (select === void 0) select = {};
    var chart = ref2.chart;
    var allAxes = chart.options.categoryAxis;
    var from = select.from;
    var to = select.to;
    for (var idx = 0; idx < allAxes.length; idx++) {
      var axis = allAxes[idx];
      if (axis.pane !== NAVIGATOR_PANE) {
        axis.min = from;
        axis.max = to;
      }
    }
  };
  Navigator3.prototype.filter = function filter() {
    var ref2 = this;
    var chart = ref2.chart;
    var select = ref2.options.select;
    if (!chart.requiresHandlers(["navigatorFilter"])) {
      return;
    }
    var mainAxis = this.mainAxis();
    var args = {
      from: select.from,
      to: select.to
    };
    if (mainAxis.options.type !== "category") {
      var axisOptions2 = new date_category_axis_default(deepExtend({
        baseUnit: "fit"
      }, chart.options.categoryAxis[0], {
        categories: [select.from, select.to]
      }), chart.chartService).options;
      args.from = addDuration(axisOptions2.min, -axisOptions2.baseUnitStep, axisOptions2.baseUnit);
      args.to = addDuration(axisOptions2.max, axisOptions2.baseUnitStep, axisOptions2.baseUnit);
    }
    this.chart.trigger("navigatorFilter", args);
  };
  Navigator3.prototype._zoom = function _zoom(e39) {
    var ref2 = this;
    var axis = ref2.chart._plotArea.categoryAxis;
    var selection = ref2.selection;
    var ref_options = ref2.options;
    var select = ref_options.select;
    var liveDrag = ref_options.liveDrag;
    var mainAxis = this.mainAxis();
    var delta = e39.delta;
    if (!selection) {
      return;
    }
    var fromIx = mainAxis.categoryIndex(selection.options.from);
    var toIx = mainAxis.categoryIndex(selection.options.to);
    var coords = this.chart._eventCoordinates(e39.originalEvent);
    e39.originalEvent.preventDefault();
    if (Math.abs(delta) > 1) {
      delta *= ZOOM_ACCELERATION2;
    }
    if (toIx - fromIx > 1) {
      selection.zoom(delta, coords);
      this.readSelection();
    } else {
      axis.options.min = select.from;
      select.from = axis.scaleRange(-e39.delta * this.chart._mousewheelZoomRate(), coords).min;
    }
    if (liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(select.from, select.to);
    this.showHint(this.options.select.from, this.options.select.to);
  };
  Navigator3.prototype._zoomEnd = function _zoomEnd(e39) {
    this._dragEnd(e39);
  };
  Navigator3.prototype.showHint = function showHint(from, to) {
    var plotArea = this.chart._plotArea;
    if (this.hint) {
      this.hint.show(from, to, plotArea.backgroundBox());
    }
  };
  Navigator3.prototype._selectStart = function _selectStart(e39) {
    return this.chart._selectStart(e39);
  };
  Navigator3.prototype._select = function _select(e39) {
    this.showHint(e39.from, e39.to);
    return this.chart._select(e39);
  };
  Navigator3.prototype._selectEnd = function _selectEnd(e39) {
    if (this.hint) {
      this.hint.hide();
    }
    this.readSelection();
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    return this.chart._selectEnd(e39);
  };
  Navigator3.prototype.mainAxis = function mainAxis() {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    }
  };
  Navigator3.prototype.select = function select(from, to) {
    var select2 = this.options.select;
    if (from && to) {
      select2.from = this.parseDate(from);
      select2.to = this.parseDate(to);
      this.filterAxes();
      this.filter();
      this.redrawSlaves();
      this.selection.set(from, to);
    }
    return {
      from: select2.from,
      to: select2.to
    };
  };
  Navigator3.setup = function setup(options, themeOptions) {
    if (options === void 0) options = {};
    if (themeOptions === void 0) themeOptions = {};
    if (options.__navi) {
      return;
    }
    options.__navi = true;
    var naviOptions = deepExtend({}, themeOptions.navigator, options.navigator);
    var panes = options.panes = [].concat(options.panes);
    var paneOptions = deepExtend({}, naviOptions.pane, { name: NAVIGATOR_PANE });
    if (!naviOptions.visible) {
      paneOptions.visible = false;
      paneOptions.height = 0.1;
    }
    if (options.navigator.position !== "top") {
      panes.push(paneOptions);
    } else {
      panes.unshift(paneOptions);
    }
    panes.forEach(function(pane) {
      pane.name = pane.name || DEFAULT_PANE;
    });
    Navigator3.attachAxes(options, naviOptions);
    Navigator3.attachSeries(options, naviOptions, themeOptions);
  };
  Navigator3.attachAxes = function attachAxes(options, naviOptions) {
    var series = naviOptions.series || [];
    var categoryAxes = options.categoryAxis = [].concat(options.categoryAxis);
    var valueAxes = options.valueAxis = [].concat(options.valueAxis);
    var allAxes = categoryAxes.concat(valueAxes);
    allAxes.forEach(function(axis) {
      axis.pane = axis.pane || DEFAULT_PANE;
    });
    var equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);
    var justifyAxis = equallySpacedSeries.length === 0;
    var base = deepExtend({
      type: "date",
      pane: NAVIGATOR_PANE,
      roundToBaseUnit: !justifyAxis,
      justified: justifyAxis,
      _collapse: false,
      majorTicks: { visible: true },
      tooltip: { visible: false },
      labels: { step: 1 },
      autoBind: naviOptions.autoBindElements,
      autoBaseUnitSteps: {
        minutes: [1],
        hours: [1, 2],
        days: [1, 2],
        weeks: [],
        months: [1],
        years: [1]
      }
    });
    var user = naviOptions.categoryAxis;
    categoryAxes.push(
      deepExtend({}, base, {
        maxDateGroups: 200
      }, user, {
        name: NAVIGATOR_AXIS,
        title: null,
        baseUnit: "fit",
        baseUnitStep: "auto",
        labels: { visible: false },
        majorTicks: { visible: false }
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_labels",
        maxDateGroups: 20,
        baseUnitStep: "auto",
        labels: { position: "" },
        plotBands: [],
        autoBaseUnitSteps: {
          minutes: []
        },
        _overlap: true
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_ticks",
        maxDateGroups: 200,
        majorTicks: {
          width: 0.5
        },
        plotBands: [],
        title: null,
        labels: { visible: false, mirror: true },
        _overlap: true
      })
    );
    valueAxes.push(deepExtend({
      name: NAVIGATOR_AXIS,
      pane: NAVIGATOR_PANE,
      majorGridLines: {
        visible: false
      },
      visible: false
    }, naviOptions.valueAxis));
  };
  Navigator3.attachSeries = function attachSeries(options, naviOptions, themeOptions) {
    var series = options.series = options.series || [];
    var navigatorSeries = [].concat(naviOptions.series || []);
    var seriesColors = themeOptions.seriesColors;
    var defaults = naviOptions.seriesDefaults;
    for (var idx = 0; idx < navigatorSeries.length; idx++) {
      series.push(
        deepExtend({
          color: seriesColors[idx % seriesColors.length],
          categoryField: naviOptions.dateField,
          visibleInLegend: false,
          tooltip: {
            visible: false
          }
        }, defaults, navigatorSeries[idx], {
          axis: NAVIGATOR_AXIS,
          categoryAxis: NAVIGATOR_AXIS,
          autoBind: naviOptions.autoBindElements
        })
      );
    }
  };
  return Navigator3;
}(class_default);
function ClonedObject() {
}
function clone2(obj) {
  ClonedObject.prototype = obj;
  return new ClonedObject();
}
var navigator_default = Navigator;

// node_modules/@progress/kendo-charts/dist/es/stock/stock-chart.js
var AUTO_CATEGORY_WIDTH = 28;
var StockChart = function(Chart2) {
  function StockChart2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2) StockChart2.__proto__ = Chart2;
  StockChart2.prototype = Object.create(Chart2 && Chart2.prototype);
  StockChart2.prototype.constructor = StockChart2;
  StockChart2.prototype.applyDefaults = function applyDefaults2(options, themeOptions) {
    var width = elementSize(this.element).width || DEFAULT_WIDTH;
    var theme = themeOptions;
    var stockDefaults = {
      seriesDefaults: {
        categoryField: options.dateField
      },
      axisDefaults: {
        categoryAxis: {
          name: "default",
          majorGridLines: {
            visible: false
          },
          labels: {
            step: 2
          },
          majorTicks: {
            visible: false
          },
          maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)
        }
      }
    };
    if (theme) {
      theme = deepExtend({}, theme, stockDefaults);
    }
    navigator_default.setup(options, theme);
    Chart2.prototype.applyDefaults.call(this, options, theme);
  };
  StockChart2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-chart k-stockchart");
  };
  StockChart2.prototype.setOptions = function setOptions(options) {
    this.destroyNavigator();
    Chart2.prototype.setOptions.call(this, options);
  };
  StockChart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this.options.transitions = false;
    this._fullRedraw();
    this.options.transitions = transitions;
  };
  StockChart2.prototype._resize = function _resize() {
    this.noTransitionsRedraw();
  };
  StockChart2.prototype._redraw = function _redraw() {
    var navigator2 = this.navigator;
    if (!this._dirty() && navigator2 && navigator2.options.partialRedraw) {
      navigator2.redrawSlaves();
    } else {
      this._fullRedraw();
    }
  };
  StockChart2.prototype._dirty = function _dirty() {
    var options = this.options;
    var series = [].concat(options.series, options.navigator.series);
    var seriesCount = grep(series, function(s10) {
      return s10 && s10.visible;
    }).length;
    var dirty = this._seriesCount !== seriesCount;
    this._seriesCount = seriesCount;
    return dirty;
  };
  StockChart2.prototype._fullRedraw = function _fullRedraw() {
    var navigator2 = this.navigator;
    if (!navigator2) {
      navigator2 = this.navigator = new navigator_default(this);
      this.trigger("navigatorCreated", { navigator: navigator2 });
    }
    navigator2.clean();
    navigator2.setRange();
    Chart2.prototype._redraw.call(this);
    navigator2.initSelection();
  };
  StockChart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords) {
    var plotArea = this._plotArea;
    var pane = plotArea.paneByPoint(coords);
    if (pane && pane.options.name === NAVIGATOR_PANE) {
      this._unsetActivePoint();
    } else {
      Chart2.prototype._trackSharedTooltip.call(this, coords);
    }
  };
  StockChart2.prototype.bindCategories = function bindCategories() {
    Chart2.prototype.bindCategories.call(this);
    this.copyNavigatorCategories();
  };
  StockChart2.prototype.copyNavigatorCategories = function copyNavigatorCategories() {
    var definitions = [].concat(this.options.categoryAxis);
    var categories;
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.name === NAVIGATOR_AXIS) {
        categories = axis.categories;
      } else if (categories && axis.pane === NAVIGATOR_PANE) {
        axis.categories = categories;
      }
    }
  };
  StockChart2.prototype.destroyNavigator = function destroyNavigator() {
    if (this.navigator) {
      this.navigator.destroy();
      this.navigator = null;
    }
  };
  StockChart2.prototype.destroy = function destroy() {
    this.destroyNavigator();
    Chart2.prototype.destroy.call(this);
  };
  StockChart2.prototype._stopChartHandlers = function _stopChartHandlers(e39) {
    var coords = this._eventCoordinates(e39);
    var pane = this._plotArea.paneByPoint(coords);
    return Chart2.prototype._stopChartHandlers.call(this, e39) || pane && pane.options.name === NAVIGATOR_PANE;
  };
  StockChart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    if (!this._dragZoomEnabled) {
      this.element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
  };
  return StockChart2;
}(chart_default);
setDefaultOptions(StockChart, {
  dateField: "date",
  axisDefaults: {
    categoryAxis: {
      type: "date",
      baseUnit: "fit",
      justified: true
    },
    valueAxis: {
      narrowRange: true,
      labels: {
        format: "C"
      }
    }
  },
  navigator: {
    select: {},
    seriesDefaults: {
      markers: {
        visible: false
      },
      tooltip: {
        visible: false
      },
      highlight: {
        visible: false
      },
      line: {
        width: 2
      }
    },
    hint: {},
    visible: true
  },
  tooltip: {
    visible: true
  },
  legend: {
    visible: false
  }
});
var stock_chart_default = StockChart;

// node_modules/@progress/kendo-charts/dist/es/gauges/constants.js
var ANGULAR_SPEED = 150;
var LINEAR_SPEED = 250;
var ARROW = "arrow";
var ARROW_POINTER = "arrowPointer";
var BAR_POINTER = "barPointer";
var DEFAULT_HEIGHT2 = 200;
var DEFAULT_LINE_WIDTH = 0.5;
var DEFAULT_WIDTH2 = 200;
var DEGREE = Math.PI / 180;
var INSIDE2 = "inside";
var LINEAR2 = "linear";
var OUTSIDE2 = "outside";
var RADIAL_POINTER = "radialPointer";
var RADIAL_RANGE_POINTER = "radialRangePointer";

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/pad.js
function pad(bbox, value2) {
  var origin = bbox.getOrigin();
  var size = bbox.getSize();
  var spacing = getSpacing(value2);
  bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);
  bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);
  return bbox;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/build-label-element.js
var Group = drawing_exports.Group;
var Path = drawing_exports.Path;
var Text2 = drawing_exports.Text;
function buildLabelElement(label, options) {
  var labelBox = label.box;
  var textBox = label.children[0].box;
  var border = options.border || {};
  var background = options.background || "";
  var wrapper2 = Path.fromRect(new geometry_exports.Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {
    stroke: {}
  });
  var text = new Text2(label.text, new geometry_exports.Point(textBox.x1, textBox.y1), {
    font: options.font,
    fill: { color: options.color }
  });
  var styleGeometry = pad(text.bbox().clone(), options.padding);
  var styleBox = Path.fromRect(styleGeometry, {
    stroke: {
      color: border.width ? border.color : "",
      width: border.width,
      opacity: border.opacity,
      dashType: border.dashType,
      lineJoin: "round",
      lineCap: "round"
    },
    fill: {
      color: background
    }
  });
  var elements = new Group();
  elements.append(wrapper2);
  elements.append(styleBox);
  elements.append(text);
  return elements;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/get-range.js
function getRange(range, min4, max3) {
  var from = defined(range.from) ? range.from : MIN_VALUE;
  var to = defined(range.to) ? range.to : MAX_VALUE;
  range.from = Math.max(Math.min(to, from), min4);
  range.to = Math.min(Math.max(to, from), max3);
  return range;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/unpad.js
function unpad(bbox, value2) {
  var spacing = getSpacing(value2);
  spacing.left = -spacing.left;
  spacing.top = -spacing.top;
  spacing.right = -spacing.right;
  spacing.bottom = -spacing.bottom;
  return pad(bbox, spacing);
}

// node_modules/@progress/kendo-charts/dist/es/gauges/gauge.js
var DEFAULT_MARGIN = 5;
var Path2 = drawing_exports.Path;
var Surface = drawing_exports.Surface;
var Gauge = function(Class) {
  function Gauge2(element, userOptions, theme, context) {
    if (context === void 0) context = {};
    Class.call(this);
    this.element = element;
    this.theme = theme;
    this.contextService = new chart_service_default(this, context);
    this._originalOptions = deepExtend({}, this.options, userOptions);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  if (Class) Gauge2.__proto__ = Class;
  Gauge2.prototype = Object.create(Class && Class.prototype);
  Gauge2.prototype.constructor = Gauge2;
  Gauge2.prototype.destroy = function destroy() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
    }
    delete this.element;
    delete this.surfaceElement;
  };
  Gauge2.prototype.value = function value2(pointerValue) {
    var pointer = this.pointers[0];
    if (arguments.length === 0) {
      return pointer.value();
    }
    pointer.value(pointerValue);
    this._setValueOptions(pointerValue);
  };
  Gauge2.prototype._draw = function _draw() {
    var surface = this.surface;
    surface.clear();
    surface.draw(this._visuals);
  };
  Gauge2.prototype.exportVisual = function exportVisual() {
    return this._visuals;
  };
  Gauge2.prototype.allValues = function allValues(values5) {
    var pointers = this.pointers;
    var allValues2 = [];
    if (arguments.length === 0) {
      for (var i36 = 0; i36 < pointers.length; i36++) {
        allValues2.push(pointers[i36].value());
      }
      return allValues2;
    }
    if (isArray(values5)) {
      for (var i$1 = 0; i$1 < values5.length; i$1++) {
        if (isNumber(values5[i$1])) {
          pointers[i$1].value(values5[i$1]);
        }
      }
    }
    this._setValueOptions(values5);
  };
  Gauge2.prototype._setValueOptions = function _setValueOptions(values5) {
    var pointers = [].concat(this.options.pointer);
    var arrayValues = [].concat(values5);
    for (var i36 = 0; i36 < arrayValues.length; i36++) {
      pointers[i36].value = arrayValues[i36];
    }
  };
  Gauge2.prototype.resize = function resize() {
    this.noTransitionsRedraw();
  };
  Gauge2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this._toggleTransitions(false);
    this.redraw();
    this._toggleTransitions(transitions);
  };
  Gauge2.prototype.redraw = function redraw() {
    var size = this._surfaceSize();
    var wrapper2 = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._initSurface();
    this.gaugeArea = this._createGaugeArea();
    this._createModel();
    var bbox = unpad(wrapper2.bbox(), this._gaugeAreaMargin);
    this.reflow(bbox);
  };
  Gauge2.prototype.setOptions = function setOptions(options, theme) {
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  };
  Gauge2.prototype.setDirection = function setDirection(rtl) {
    this.contextService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this.surface.destroy();
      this.surface = null;
    }
  };
  Gauge2.prototype.setIntlService = function setIntlService(intl) {
    this.contextService.intl = intl;
  };
  Gauge2.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
    var options = this.options;
    var pointer = options.pointer;
    if (isArray(pointer)) {
      var pointers = [];
      for (var i36 = 0; i36 < pointer.length; i36++) {
        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i36]));
      }
      options.pointer = pointers;
    }
  };
  Gauge2.prototype._createGaugeArea = function _createGaugeArea() {
    var options = this.options.gaugeArea;
    var size = this.surface.size();
    var border = options.border || {};
    var areaGeometry = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;
    if (border.width > 0) {
      areaGeometry = unpad(areaGeometry, border.width);
    }
    var gaugeArea = Path2.fromRect(areaGeometry, {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        opacity: border.opacity,
        dashType: border.dashType,
        lineJoin: "round",
        lineCap: "round"
      },
      fill: {
        color: options.background
      }
    });
    return gaugeArea;
  };
  Gauge2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options = ref2.options;
    var surface = ref2.surface;
    var element = this._surfaceElement();
    var size = this._surfaceSize();
    elementSize(element, size);
    if (!surface || surface.options.type !== options.renderAs) {
      if (surface) {
        surface.destroy();
      }
      this.surface = Surface.create(element, {
        type: options.renderAs
      });
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Gauge2.prototype._surfaceSize = function _surfaceSize() {
    var options = this.options;
    var size = this._getSize();
    if (options.gaugeArea) {
      deepExtend(size, options.gaugeArea);
    }
    return size;
  };
  Gauge2.prototype._surfaceElement = function _surfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
    return this.surfaceElement;
  };
  Gauge2.prototype.getSize = function getSize() {
    return this._getSize();
  };
  Gauge2.prototype._getSize = function _getSize() {
    var element = this.element;
    var defaultSize = this._defaultSize();
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (!width) {
      width = defaultSize.width;
    }
    if (!height) {
      height = defaultSize.height;
    }
    return { width, height };
  };
  Gauge2.prototype._defaultSize = function _defaultSize() {
    return {
      width: DEFAULT_WIDTH2,
      height: DEFAULT_HEIGHT2
    };
  };
  Gauge2.prototype._toggleTransitions = function _toggleTransitions(value2) {
    var this$1 = this;
    this.options.transitions = value2;
    for (var i36 = 0; i36 < this.pointers.length; i36++) {
      this$1.pointers[i36].options.animation.transitions = value2;
    }
  };
  return Gauge2;
}(class_default);
setDefaultOptions(Gauge, {
  plotArea: {},
  theme: "default",
  renderAs: "",
  pointer: {},
  scale: {},
  gaugeArea: {}
});
var gauge_default = Gauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-scale.js
var Path3 = drawing_exports.Path;
var Group2 = drawing_exports.Group;
var Point2 = geometry_exports.Point;
function renderAxisTick(tickRenderOptions, tickOptions) {
  var position = tickRenderOptions.position;
  var tickX = tickRenderOptions.tickX;
  var tickY = tickRenderOptions.tickY;
  var start, end;
  if (tickRenderOptions.vertical) {
    start = new Point2(tickX, position);
    end = new Point2(tickX + tickOptions.size, position);
  } else {
    start = new Point2(position, tickY);
    end = new Point2(position, tickY + tickOptions.size);
  }
  var tickPath = new Path3({
    stroke: {
      color: tickOptions.color,
      width: tickOptions.width
    }
  }).moveTo(start).lineTo(end);
  return tickPath;
}
function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {
  var count = tickPositions.length;
  if (tickOptions.visible) {
    var mirror = tickRenderOptions.mirror;
    var lineBox = tickRenderOptions.lineBox;
    for (var i36 = tickOptions.skip; i36 < count; i36 += tickOptions.step) {
      if (i36 % tickOptions.skipUnit === 0) {
        continue;
      }
      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickRenderOptions.position = tickPositions[i36];
      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));
    }
  }
}
var LinearScale = function(NumericAxis2) {
  function LinearScale2(options, service) {
    var scaleOptions = options || {};
    if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {
      scaleOptions = Object.assign({}, scaleOptions, {
        reverse: true
      });
    }
    NumericAxis2.call(this, 0, 1, scaleOptions, service);
    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;
  }
  if (NumericAxis2) LinearScale2.__proto__ = NumericAxis2;
  LinearScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  LinearScale2.prototype.constructor = LinearScale2;
  LinearScale2.prototype.initUserOptions = function initUserOptions(options) {
    var scaleOptions = deepExtend({}, this.options, options);
    scaleOptions = deepExtend({}, scaleOptions, { labels: { mirror: scaleOptions.mirror } });
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    return scaleOptions;
  };
  LinearScale2.prototype.initFields = function initFields() {
  };
  LinearScale2.prototype.render = function render() {
    var elements = this.elements = new Group2();
    var labels = this.renderLabels();
    var scaleLine = this.renderLine();
    var scaleTicks = this.renderTicks();
    var ranges = this.renderRanges();
    elements.append(scaleLine, labels, scaleTicks, ranges);
    return elements;
  };
  LinearScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var options = this.options;
    var min4 = options.min;
    var max3 = options.max;
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var ranges = options.ranges || [];
    var elements = new Group2();
    var count = ranges.length;
    var rangeSize = options.rangeSize || options.minorTicks.size / 2;
    for (var i36 = 0; i36 < count; i36++) {
      var range = getRange(ranges[i36], min4, max3);
      var slot = this$1.getSlot(range.from, range.to);
      var slotX = vertical ? this$1.lineBox() : slot;
      var slotY = vertical ? slot : this$1.lineBox();
      if (vertical) {
        slotX.x1 -= rangeSize * (mirror ? -1 : 1);
      } else {
        slotY.y2 += rangeSize * (mirror ? -1 : 1);
      }
      elements.append(Path3.fromRect(new geometry_exports.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {
        fill: { color: range.color, opacity: range.opacity },
        stroke: {}
      }));
    }
    return elements;
  };
  LinearScale2.prototype.renderLabels = function renderLabels() {
    var ref2 = this;
    var labels = ref2.labels;
    var options = ref2.options;
    var elements = new Group2();
    for (var i36 = 0; i36 < labels.length; i36++) {
      elements.append(buildLabelElement(labels[i36], options.labels));
    }
    return elements;
  };
  LinearScale2.prototype.renderLine = function renderLine() {
    var line = this.options.line;
    var lineBox = this.lineBox();
    var elements = new Group2();
    if (line.width > 0 && line.visible) {
      var linePath = new Path3({
        stroke: {
          color: line.color,
          dashType: line.dashType,
          width: line.width
        }
      });
      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      elements.append(linePath);
    }
    return elements;
  };
  LinearScale2.prototype.renderTicks = function renderTicks$1() {
    var ticks = new Group2();
    var options = this.options;
    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    var tickRenderOptions = {
      vertical: options.vertical,
      mirror: options.labels.mirror,
      lineBox: this.lineBox()
    };
    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);
    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {
      skipUnit: majorUnit / options.minorUnit
    }, options.minorTicks));
    return ticks;
  };
  return LinearScale2;
}(numeric_axis_default);
setDefaultOptions(LinearScale, {
  min: 0,
  max: 50,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  line: {
    width: DEFAULT_LINE_WIDTH
  },
  labels: {
    position: INSIDE2,
    padding: 2
  },
  mirror: false,
  _alignLines: false
});
var linear_scale_default = LinearScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/pointer.js
var Pointer = function(Class) {
  function Pointer2(scale, userOptions) {
    Class.call(this);
    var ref2 = scale.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var options = this.options = deepExtend({}, this.options, userOptions);
    options.fill = options.color;
    this.scale = scale;
    if (defined(options.value)) {
      options.value = limitValue(options.value, min4, max3);
    } else {
      options.value = min4;
    }
  }
  if (Class) Pointer2.__proto__ = Class;
  Pointer2.prototype = Object.create(Class && Class.prototype);
  Pointer2.prototype.constructor = Pointer2;
  Pointer2.prototype.value = function value2(newValue) {
    var options = this.options;
    var value3 = options.value;
    if (arguments.length === 0) {
      return value3;
    }
    var ref2 = this.scale.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    options._oldValue = defined(options._oldValue) ? options.value : min4;
    options.value = limitValue(newValue, min4, max3);
    if (this.elements) {
      this.repaint();
    }
  };
  return Pointer2;
}(class_default);
setDefaultOptions(Pointer, {
  color: BLACK
});
var pointer_default = Pointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-pointer.js
var LinearPointer = function(Pointer2) {
  function LinearPointer2(scale, options) {
    Pointer2.call(this, scale, options);
    this.options = deepExtend({
      track: {
        visible: defined(options.track)
      }
    }, this.options);
  }
  if (Pointer2) LinearPointer2.__proto__ = Pointer2;
  LinearPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  LinearPointer2.prototype.constructor = LinearPointer2;
  LinearPointer2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options = ref2.options;
    var scale = ref2.scale;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var scaleLine = scale.lineBox();
    var trackSize = options.track.size || options.size;
    var pointerHalfSize = options.size / 2;
    var margin = getSpacing(options.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    var pointerBox, pointerRangeBox, trackBox;
    space = mirror ? -space : space;
    if (vertical) {
      trackBox = new box_default(
        scaleLine.x1 + space,
        scaleLine.y1,
        scaleLine.x1 + space,
        scaleLine.y2
      );
      if (mirror) {
        trackBox.x1 -= trackSize;
      } else {
        trackBox.x2 += trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x2 + space,
          scaleLine.y1 - pointerHalfSize,
          scaleLine.x2 + space,
          scaleLine.y2 + pointerHalfSize
        );
        pointerBox = pointerRangeBox;
      }
    } else {
      trackBox = new box_default(
        scaleLine.x1,
        scaleLine.y1 - space,
        scaleLine.x2,
        scaleLine.y1 - space
      );
      if (mirror) {
        trackBox.y2 += trackSize;
      } else {
        trackBox.y1 -= trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x1 - pointerHalfSize,
          scaleLine.y1 - space,
          scaleLine.x2 + pointerHalfSize,
          scaleLine.y1 - space
        );
        pointerBox = pointerRangeBox;
      }
    }
    this.trackBox = trackBox;
    this.pointerRangeBox = pointerRangeBox;
    this.box = pointerBox || trackBox.clone().pad(options.border.width);
  };
  LinearPointer2.prototype.getElementOptions = function getElementOptions() {
    var options = this.options;
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: defined(options.border) ? {
        color: options.border.width ? options.border.color || options.color : "",
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: options.opacity
      } : null
    };
  };
  LinearPointer2.prototype._margin = function _margin() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var margin = getSpacing(options.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    return space;
  };
  return LinearPointer2;
}(pointer_default);
setDefaultOptions(LinearPointer, {
  shape: BAR_POINTER,
  track: {
    border: {
      width: 1
    }
  },
  color: BLACK,
  border: {
    width: 1
  },
  opacity: 1,
  margin: getSpacing(3),
  animation: {
    type: BAR_POINTER
  },
  visible: true
});
var linear_pointer_default = LinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer-animation.js
var ArrowLinearPointerAnimation = function(superclass) {
  function ArrowLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) ArrowLinearPointerAnimation2.__proto__ = superclass;
  ArrowLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ArrowLinearPointerAnimation2.prototype.constructor = ArrowLinearPointerAnimation2;
  ArrowLinearPointerAnimation2.prototype.setup = function setup() {
    var options = this.options;
    var margin = options.margin;
    var from = options.from;
    var to = options.to;
    var vertical = options.vertical;
    var axis = vertical ? "x1" : "y1";
    if (options.mirror === vertical) {
      from[axis] -= margin;
      to[axis] -= margin;
    } else {
      from[axis] += margin;
      to[axis] += margin;
    }
    var fromScale = this.fromScale = new geometry_exports.Point(from.x1, from.y1);
    var toScale = this.toScale = new geometry_exports.Point(to.x1, to.y1);
    if (options.duration !== 0) {
      options.duration = Math.max(fromScale.distanceTo(toScale) / options.duration * 1e3, 1);
    }
  };
  ArrowLinearPointerAnimation2.prototype.step = function step(pos) {
    var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);
    var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);
    this.element.transform(geometry_exports.transform().translate(translateX, translateY));
  };
  return ArrowLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ArrowLinearPointerAnimation, {
  easing: LINEAR2,
  duration: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);
var arrow_linear_pointer_animation_default = ArrowLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer.js
var Point3 = geometry_exports.Point;
var Path4 = drawing_exports.Path;
var ArrowLinearPointer = function(LinearPointer2) {
  function ArrowLinearPointer2(scale, options) {
    LinearPointer2.call(this, scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.6;
    }
  }
  if (LinearPointer2) ArrowLinearPointer2.__proto__ = LinearPointer2;
  ArrowLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  ArrowLinearPointer2.prototype.constructor = ArrowLinearPointer2;
  ArrowLinearPointer2.prototype.pointerShape = function pointerShape() {
    var ref2 = this;
    var scale = ref2.scale;
    var size = ref2.options.size;
    var halfSize = size / 2;
    var sign = scale.options.mirror ? -1 : 1;
    var shape;
    if (scale.options.vertical) {
      shape = [
        new Point3(0, 0 - halfSize),
        new Point3(0 - sign * size, 0),
        new Point3(0, 0 + halfSize)
      ];
    } else {
      shape = [
        new Point3(0 - halfSize, 0),
        new Point3(0, 0 + sign * size),
        new Point3(0 + halfSize, 0)
      ];
    }
    return shape;
  };
  ArrowLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var animation = new arrow_linear_pointer_animation_default(this.elements, deepExtend(options.animation, {
      vertical: scale.options.vertical,
      mirror: scale.options.mirror,
      margin: this._margin(options.margin),
      from: scale.getSlot(options._oldValue),
      to: scale.getSlot(options.value)
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  ArrowLinearPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var elementOptions = this.getElementOptions();
    var shape = this.pointerShape(options.value);
    options.animation.type = ARROW_POINTER;
    var elements = new Path4({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();
    var slot = scale.getSlot(options.value);
    elements.transform(geometry_exports.transform().translate(slot.x1, slot.y1));
    this.elements = elements;
    return elements;
  };
  return ArrowLinearPointer2;
}(linear_pointer_default);
var arrow_linear_pointer_default = ArrowLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer-animation.js
var BarLinearPointerAnimation = function(superclass) {
  function BarLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) BarLinearPointerAnimation2.__proto__ = superclass;
  BarLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarLinearPointerAnimation2.prototype.constructor = BarLinearPointerAnimation2;
  BarLinearPointerAnimation2.prototype.setup = function setup() {
    var options = this.options;
    var axis = this.axis = options.vertical ? Y : X;
    var to = this.to = options.newPoints[0][axis];
    var from = this.from = options.oldPoints[0][axis];
    if (options.duration !== 0) {
      options.duration = Math.max(Math.abs(to - from) / options.speed * 1e3, 1);
    }
    this._set(from);
  };
  BarLinearPointerAnimation2.prototype.step = function step(pos) {
    var value2 = interpolateValue(this.from, this.to, pos);
    this._set(value2);
  };
  BarLinearPointerAnimation2.prototype._set = function _set(value2) {
    var setter = "set" + this.axis.toUpperCase();
    var points = this.options.newPoints;
    points[0][setter](value2);
    points[1][setter](value2);
  };
  return BarLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarLinearPointerAnimation, {
  easing: LINEAR2,
  speed: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);
var bar_linear_pointer_animation_default = BarLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer.js
var Group3 = drawing_exports.Group;
var Path5 = drawing_exports.Path;
var BarLinearPointer = function(LinearPointer2) {
  function BarLinearPointer2(scale, options) {
    LinearPointer2.call(this, scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.3;
    }
  }
  if (LinearPointer2) BarLinearPointer2.__proto__ = LinearPointer2;
  BarLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  BarLinearPointer2.prototype.constructor = BarLinearPointer2;
  BarLinearPointer2.prototype.pointerShape = function pointerShape(value2) {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var dir = mirror === vertical ? -1 : 1;
    var size = options.size * dir;
    var minSlot = scale.getSlot(scale.options.min);
    var slot = scale.getSlot(value2);
    var axis = vertical ? Y : X;
    var sizeAxis = vertical ? X : Y;
    var margin = this._margin() * dir;
    var p1 = new geometry_exports.Point();
    p1[axis] = minSlot[axis + "1"];
    p1[sizeAxis] = minSlot[sizeAxis + "1"];
    var p22 = new geometry_exports.Point();
    p22[axis] = slot[axis + "1"];
    p22[sizeAxis] = slot[sizeAxis + "1"];
    if (vertical) {
      p1.translate(margin, 0);
      p22.translate(margin, 0);
    } else {
      p1.translate(0, margin);
      p22.translate(0, margin);
    }
    var p32 = p22.clone();
    var p42 = p1.clone();
    if (vertical) {
      p32.translate(size, 0);
      p42.translate(size, 0);
    } else {
      p32.translate(0, size);
      p42.translate(0, size);
    }
    return [p1, p22, p32, p42];
  };
  BarLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var shape = this.pointerShape(options.value);
    var pointerPath = this.pointerPath;
    var oldShape = this.pointerShape(options._oldValue);
    pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();
    var animation = new bar_linear_pointer_animation_default(pointerPath, deepExtend(options.animation, {
      reverse: scale.options.reverse,
      vertical: scale.options.vertical,
      oldPoints: [oldShape[1], oldShape[2]],
      newPoints: [shape[1], shape[2]]
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  BarLinearPointer2.prototype.render = function render() {
    var group = new Group3();
    var elementOptions = this.getElementOptions();
    if (this.options.track.visible) {
      group.append(this.renderTrack());
    }
    var pointer = this.pointerPath = new Path5({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    });
    group.append(pointer);
    this.elements = group;
    return group;
  };
  BarLinearPointer2.prototype.renderTrack = function renderTrack() {
    var trackOptions = this.options.track;
    var border = trackOptions.border || {};
    var trackBox = this.trackBox.clone().pad(border.width || 0);
    return new Path5.fromRect(trackBox.toRect(), {
      fill: {
        color: trackOptions.color,
        opacity: trackOptions.opacity
      },
      stroke: {
        color: border.width ? border.color || trackOptions.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
  };
  return BarLinearPointer2;
}(linear_pointer_default);
var bar_linear_pointer_default = BarLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-gauge.js
var DEFAULT_MIN_WIDTH = 60;
var DEFAULT_MIN_HEIGHT = 60;
var Group4 = drawing_exports.Group;
var LinearGauge = function(Gauge2) {
  function LinearGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2) LinearGauge2.__proto__ = Gauge2;
  LinearGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  LinearGauge2.prototype.constructor = LinearGauge2;
  LinearGauge2.prototype.reflow = function reflow(bbox) {
    var pointers = this.pointers;
    var bboxX = bbox.origin.x;
    var bboxY = bbox.origin.y;
    var box = new box_default(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());
    this.scale.reflow(box);
    this._shrinkScaleWidth(box);
    for (var i36 = 0; i36 < pointers.length; i36++) {
      pointers[i36].reflow();
    }
    this.bbox = this._getBox(box);
    this._alignElements();
    this._shrinkElements();
    this._buildVisual();
    this._draw();
  };
  LinearGauge2.prototype._buildVisual = function _buildVisual() {
    var visuals = new Group4();
    var scaleElements = this.scale.render();
    var pointers = this.pointers;
    visuals.append(this.gaugeArea);
    visuals.append(scaleElements);
    for (var i36 = 0; i36 < pointers.length; i36++) {
      var current4 = pointers[i36];
      visuals.append(current4.render());
      current4.value(current4.options.value);
    }
    this._visuals = visuals;
  };
  LinearGauge2.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options = this.options;
    var scale = this.scale = new linear_scale_default(options.scale, this.contextService);
    this.pointers = [];
    var pointers = options.pointer;
    pointers = isArray(pointers) ? pointers : [pointers];
    for (var i36 = 0; i36 < pointers.length; i36++) {
      var currentOptions = deepExtend({}, pointers[i36], {
        animation: {
          transitions: options.transitions
        }
      });
      var pointerType = currentOptions.shape === ARROW ? arrow_linear_pointer_default : bar_linear_pointer_default;
      this$1.pointers.push(new pointerType(scale, currentOptions));
    }
  };
  LinearGauge2.prototype._defaultSize = function _defaultSize() {
    var vertical = this.options.scale.vertical;
    return {
      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH2,
      height: vertical ? DEFAULT_HEIGHT2 : DEFAULT_MIN_HEIGHT
    };
  };
  LinearGauge2.prototype._getBox = function _getBox(box) {
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var boxCenter = box.center();
    var plotAreaBox = pointers[0].box.clone().wrap(scale.box);
    for (var i36 = 0; i36 < pointers.length; i36++) {
      plotAreaBox.wrap(pointers[i36].box.clone());
    }
    var size;
    if (scale.options.vertical) {
      size = plotAreaBox.width() / 2;
      plotAreaBox = new box_default(
        boxCenter.x - size,
        box.y1,
        boxCenter.x + size,
        box.y2
      );
    } else {
      size = plotAreaBox.height() / 2;
      plotAreaBox = new box_default(
        box.x1,
        boxCenter.y - size,
        box.x2,
        boxCenter.y + size
      );
    }
    return plotAreaBox;
  };
  LinearGauge2.prototype._alignElements = function _alignElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box;
    var box = pointers[0].box.clone().wrap(scale.box);
    var plotAreaBox = this.bbox;
    for (var i36 = 0; i36 < pointers.length; i36++) {
      box.wrap(pointers[i36].box.clone());
    }
    var diff;
    if (scale.options.vertical) {
      diff = plotAreaBox.center().x - box.center().x;
      scale.reflow(new box_default(
        scaleBox.x1 + diff,
        plotAreaBox.y1,
        scaleBox.x2 + diff,
        plotAreaBox.y2
      ));
    } else {
      diff = plotAreaBox.center().y - box.center().y;
      scale.reflow(new box_default(
        scaleBox.x1,
        scaleBox.y1 + diff,
        scaleBox.x2,
        scaleBox.y2 + diff
      ));
    }
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  LinearGauge2.prototype._shrinkScaleWidth = function _shrinkScaleWidth(bbox) {
    var ref2 = this;
    var scale = ref2.scale;
    if (!scale.options.vertical) {
      var overflow = scale.contentBox().width() - bbox.width();
      if (overflow > 0) {
        scale.box.shrink(overflow, 0);
        scale.box.alignTo(bbox, "center");
        scale.reflow(scale.box);
      }
    }
  };
  LinearGauge2.prototype._shrinkElements = function _shrinkElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box.clone();
    var pos = scale.options.vertical ? "y" : "x";
    var pointerBox = pointers[0].box;
    for (var i36 = 0; i36 < pointers.length; i36++) {
      pointerBox.wrap(pointers[i36].box.clone());
    }
    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);
    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);
    scale.reflow(scaleBox);
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  return LinearGauge2;
}(gauge_default);
setDefaultOptions(LinearGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  },
  scale: {
    vertical: true
  }
});

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-scale.js
var GEO_ARC_ADJUST_ANGLE = 180;
var Arc = drawing_exports.Arc;
var Path6 = drawing_exports.Path;
var Group5 = drawing_exports.Group;
function drawTicks(arc, tickAngles, unit2, tickOptions) {
  var ticks = new Group5();
  var center = arc.center;
  var radius = arc.getRadiusX();
  if (tickOptions.visible) {
    for (var i36 = 0; i36 < tickAngles.length; i36++) {
      var tickStart = arc.pointAt(tickAngles[i36]);
      var tickEnd = new geometry_exports.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i36], center);
      ticks.append(new Path6({
        stroke: {
          color: tickOptions.color,
          width: tickOptions.width
        }
      }).moveTo(tickStart).lineTo(tickEnd));
    }
  }
  return ticks;
}
function rangeSegment(from, to, color, opacity) {
  return { from, to, color, opacity };
}
var RadialScale = function(NumericAxis2) {
  function RadialScale2(options, service) {
    NumericAxis2.call(this, 0, 1, options, service);
  }
  if (NumericAxis2) RadialScale2.__proto__ = NumericAxis2;
  RadialScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadialScale2.prototype.constructor = RadialScale2;
  RadialScale2.prototype.initUserOptions = function initUserOptions(options) {
    var scaleOptions = deepExtend({}, this.options, options);
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;
    return scaleOptions;
  };
  RadialScale2.prototype.initFields = function initFields() {
  };
  RadialScale2.prototype.render = function render(center, radius) {
    var arc = this.renderArc(center, radius);
    this.bbox = arc.bbox();
    this.labelElements = this.renderLabels();
    this.ticks = this.renderTicks();
    this.ranges = this.renderRanges();
  };
  RadialScale2.prototype.reflow = function reflow(bbox) {
    var center = bbox.center();
    var radius = Math.min(bbox.height(), bbox.width()) / 2;
    if (defined(this.bbox)) {
      this.bbox = this.arc.bbox();
      this.radius(this.arc.getRadiusX());
      this.repositionRanges();
      this.renderLabels();
    } else {
      return this.render(center, radius);
    }
  };
  RadialScale2.prototype.slotAngle = function slotAngle(value2) {
    var ref2 = this.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var reverse = ref2.reverse;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var angle = endAngle - startAngle;
    var result;
    if (reverse) {
      result = endAngle - (value2 - min4) / (max3 - min4) * angle;
    } else {
      result = (value2 - min4) / (max3 - min4) * angle + startAngle;
    }
    return result + GEO_ARC_ADJUST_ANGLE;
  };
  RadialScale2.prototype.hasRanges = function hasRanges() {
    var ranges = this.options.ranges;
    return ranges && ranges.length;
  };
  RadialScale2.prototype.ticksSize = function ticksSize() {
    var ref2 = this.options;
    var majorTicks = ref2.majorTicks;
    var minorTicks = ref2.minorTicks;
    var size = 0;
    if (majorTicks.visible) {
      size = majorTicks.size;
    }
    if (minorTicks.visible) {
      size = Math.max(minorTicks.size, size);
    }
    return size;
  };
  RadialScale2.prototype.labelsCount = function labelsCount() {
    var count = NumericAxis2.prototype.labelsCount.call(this);
    var options = this.options;
    var angle = options.endAngle - options.startAngle;
    if (angle >= 360 && options.max % options.majorUnit === 0) {
      count -= 1;
    }
    return count;
  };
  RadialScale2.prototype.renderLabels = function renderLabels() {
    var this$1 = this;
    var options = this.options;
    var arc = this.arc.clone();
    var radius = arc.getRadiusX();
    var tickAngles = this.tickAngles(arc, options.majorUnit);
    var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;
    var labelsGroup = new Group5();
    var rangeDistance = radius * 0.05;
    if (defined(options.rangeDistance)) {
      rangeDistance = options.rangeDistance;
    } else {
      options.rangeDistance = rangeDistance;
    }
    var labelsOptions = options.labels;
    var isInside = labelsOptions.position === INSIDE2;
    var hasLabelElements = defined(this.labelElements);
    if (isInside) {
      radius -= this.ticksSize();
      if (this.hasRanges() && !hasLabelElements) {
        radius -= rangeSize + rangeDistance;
      }
      arc.setRadiusX(radius).setRadiusY(radius);
    }
    var labels = this.labels;
    var count = labels.length;
    var padding = getSpacing(labelsOptions.padding);
    var paddingWidth = (padding.left + padding.right) / 2;
    var paddingHeight = (padding.top + padding.bottom) / 2;
    for (var i36 = 0; i36 < count; i36++) {
      var label = labels[i36];
      var halfWidth = label.box.width() / 2;
      var halfHeight = label.box.height() / 2;
      var angle = tickAngles[i36];
      var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;
      var lp = arc.pointAt(angle);
      var cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);
      var cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);
      label.reflow(new box_default(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));
      var labelPos = new geometry_exports.Point(label.box.x1, label.box.y1);
      var labelElement = void 0;
      if (!hasLabelElements) {
        labelElement = buildLabelElement(label, options.labels);
        labelsGroup.append(labelElement);
      } else {
        labelElement = this$1.labelElements.children[i36];
        var prevLabelPos = labelElement.bbox().origin;
        var labelTransform = labelElement.transform() || geometry_exports.transform();
        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);
        labelElement.transform(labelTransform);
      }
      this$1.bbox = geometry_exports.Rect.union(this$1.bbox, labelElement.bbox());
    }
    return labelsGroup;
  };
  RadialScale2.prototype.repositionRanges = function repositionRanges() {
    var ranges = this.ranges.children;
    if (ranges.length > 0) {
      var ref2 = this.options;
      var rangeDistance = ref2.rangeDistance;
      var rangeSize = ref2.rangeSize;
      var rangeRadius = this.getRangeRadius();
      if (this.options.labels.position === INSIDE2) {
        rangeRadius += rangeSize + rangeDistance;
      }
      var newRadius = rangeRadius + rangeSize / 2;
      for (var i36 = 0; i36 < ranges.length; i36++) {
        ranges[i36]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, this.ranges.bbox());
    }
  };
  RadialScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var segments = this.rangeSegments();
    var segmentsCount = segments.length;
    var result = new Group5();
    if (segmentsCount) {
      var ref2 = this.options;
      var rangeSize = ref2.rangeSize;
      var reverse = ref2.reverse;
      var rangeDistance = ref2.rangeDistance;
      var rangeRadius = this.getRangeRadius();
      this.radius(this.radius() - rangeSize - rangeDistance);
      for (var i36 = 0; i36 < segmentsCount; i36++) {
        var segment = segments[i36];
        var from = this$1.slotAngle(segment[reverse ? "to" : "from"]);
        var to = this$1.slotAngle(segment[!reverse ? "to" : "from"]);
        if (to - from !== 0) {
          result.append(this$1.createRange(from, to, rangeRadius, segment));
        }
      }
    }
    return result;
  };
  RadialScale2.prototype.createRange = function createRange(startAngle, endAngle, rangeRadius, options) {
    var rangeSize = this.options.rangeSize;
    var rangeGeom = new geometry_exports.Arc(this.arc.center, {
      radiusX: rangeRadius + rangeSize / 2,
      radiusY: rangeRadius + rangeSize / 2,
      startAngle,
      endAngle
    });
    return new Arc(rangeGeom, {
      stroke: {
        width: rangeSize,
        color: options.color,
        opacity: options.opacity,
        lineCap: options.lineCap
      }
    });
  };
  RadialScale2.prototype.rangeSegments = function rangeSegments() {
    var options = this.options;
    var ranges = options.ranges || [];
    var count = ranges.length;
    var segments = [];
    if (count) {
      var min4 = options.min;
      var max3 = options.max;
      var defaultColor = options.rangePlaceholderColor;
      segments.push(rangeSegment(min4, max3, defaultColor));
      for (var i36 = 0; i36 < count; i36++) {
        var range = getRange(ranges[i36], min4, max3);
        var segmentsCount = segments.length;
        for (var j2 = 0; j2 < segmentsCount; j2++) {
          var segment = segments[j2];
          if (segment.from <= range.from && range.from <= segment.to) {
            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));
            if (segment.from <= range.to && range.to <= segment.to) {
              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));
            }
            segment.to = range.from;
            break;
          }
        }
      }
    }
    return segments;
  };
  RadialScale2.prototype.getRangeRadius = function getRangeRadius() {
    var ref2 = this;
    var arc = ref2.arc;
    var options = ref2.options;
    var rangeSize = options.rangeSize;
    var rangeDistance = options.rangeDistance;
    var majorTickSize = options.majorTicks.size;
    var radius;
    if (options.labels.position === OUTSIDE2) {
      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;
    } else {
      radius = arc.getRadiusX() - rangeSize;
    }
    return radius;
  };
  RadialScale2.prototype.renderArc = function renderArc(center, radius) {
    var options = this.options;
    var arc = this.arc = new geometry_exports.Arc(center, {
      radiusX: radius,
      radiusY: radius,
      startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,
      endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE
    });
    return arc;
  };
  RadialScale2.prototype.renderTicks = function renderTicks2() {
    var ref2 = this;
    var arc = ref2.arc;
    var options = ref2.options;
    var tickArc = arc.clone();
    this.majorTickAngles = this.tickAngles(arc, options.majorUnit);
    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);
    var allTicks = new Group5();
    allTicks.append(this.majorTicks);
    var majorTickSize = options.majorTicks.size;
    var minorTickSize = options.minorTicks.size;
    this._tickDifference = majorTickSize - minorTickSize;
    if (options.labels.position === OUTSIDE2) {
      var radius = tickArc.getRadiusX();
      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);
    }
    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));
    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);
    allTicks.append(this.minorTicks);
    return allTicks;
  };
  RadialScale2.prototype.normalizeTickAngles = function normalizeTickAngles(angles) {
    var options = this.options;
    var skip = options.majorUnit / options.minorUnit;
    for (var i36 = angles.length - 1; i36 >= 0; i36--) {
      if (i36 % skip === 0) {
        angles.splice(i36, 1);
      }
    }
    return angles;
  };
  RadialScale2.prototype.tickAngles = function tickAngles(ring, stepValue) {
    var options = this.options;
    var reverse = options.reverse;
    var range = options.max - options.min;
    var angle = ring.endAngle - ring.startAngle;
    var tickCount = range / stepValue;
    var pos = ring.startAngle;
    var step = angle / tickCount;
    if (reverse) {
      pos += angle;
      step = -step;
    }
    if (angle >= 360 && options.max % stepValue === 0) {
      tickCount -= 1;
    }
    var positions = [];
    for (var i36 = 0; i36 < tickCount; i36++) {
      positions.push(round(pos, COORD_PRECISION));
      pos += step;
    }
    if (round(pos) <= ring.endAngle) {
      positions.push(pos);
    }
    return positions;
  };
  RadialScale2.prototype.radius = function radius(value2) {
    if (value2) {
      this.arc.setRadiusX(value2).setRadiusY(value2);
      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);
      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);
    } else {
      return this.arc.getRadiusX();
    }
  };
  RadialScale2.prototype.repositionTicks = function repositionTicks(ticks, tickAngles, minor) {
    var diff = minor ? this._tickDifference || 0 : 0;
    var tickArc = this.arc;
    var radius = tickArc.getRadiusX();
    if (minor && this.options.labels.position === OUTSIDE2 && diff !== 0) {
      tickArc = this.arc.clone();
      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);
    }
    for (var i36 = 0; i36 < ticks.length; i36++) {
      var newPoint = tickArc.pointAt(tickAngles[i36]);
      var segments = ticks[i36].segments;
      var xDiff = newPoint.x - segments[0].anchor().x;
      var yDiff = newPoint.y - segments[0].anchor().y;
      ticks[i36].transform(new geometry_exports.transform().translate(xDiff, yDiff));
    }
  };
  return RadialScale2;
}(numeric_axis_default);
setDefaultOptions(RadialScale, {
  min: 0,
  max: 100,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  startAngle: -30,
  endAngle: 210,
  labels: {
    position: INSIDE2,
    padding: 2
  }
});
var radial_scale_default = RadialScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer-animation.js
var RadialPointerAnimation = function(superclass) {
  function RadialPointerAnimation2(element, options) {
    superclass.call(this, element, options);
    var animationOptions = this.options;
    animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3, 1);
  }
  if (superclass) RadialPointerAnimation2.__proto__ = superclass;
  RadialPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RadialPointerAnimation2.prototype.constructor = RadialPointerAnimation2;
  RadialPointerAnimation2.prototype.step = function step(pos) {
    var options = this.options;
    var angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.transform(geometry_exports.transform().rotate(angle, options.center));
  };
  return RadialPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RadialPointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);
var radial_pointer_animation_default = RadialPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer.js
var CAP_SIZE = 0.05;
var Circle = drawing_exports.Circle;
var Group6 = drawing_exports.Group;
var Path7 = drawing_exports.Path;
var RadialPointer = function(Pointer2) {
  function RadialPointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2) RadialPointer2.__proto__ = Pointer2;
  RadialPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RadialPointer2.prototype.constructor = RadialPointer2;
  RadialPointer2.prototype.setAngle = function setAngle(angle) {
    this.elements.transform(geometry_exports.transform().rotate(angle, this.center));
  };
  RadialPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var oldAngle = scale.slotAngle(options._oldValue);
    var newAngle = scale.slotAngle(options.value);
    if (options.animation.transitions === false) {
      this.setAngle(newAngle);
    } else {
      new radial_pointer_animation_default(this.elements, deepExtend(options.animation, {
        oldAngle,
        newAngle
      })).play();
    }
  };
  RadialPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var elements = new Group6();
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    elements.append(this._renderNeedle(), this._renderCap());
    this.elements = elements;
    this.setAngle(DEGREE);
    return elements;
  };
  RadialPointer2.prototype.reflow = function reflow(arc) {
    var center = this.center = arc.center;
    var length = limitValue(this.options.length || 1, 0.1, 1.5);
    var radius = this.radius = arc.getRadiusX() * length;
    var capSize = this.capSize = Math.round(radius * this.options.cap.size);
    this.bbox = geometry_exports.Rect.fromPoints(
      new geometry_exports.Point(center.x - capSize, center.y - capSize),
      new geometry_exports.Point(center.x + capSize, center.y + capSize)
    );
  };
  RadialPointer2.prototype._renderNeedle = function _renderNeedle() {
    var minorTickSize = this.scale.options.minorTicks.size;
    var center = this.center;
    var needleColor = this.options.color;
    var needlePath = new Path7({
      fill: { color: needleColor },
      stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }
    });
    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();
    return needlePath;
  };
  RadialPointer2.prototype._renderCap = function _renderCap() {
    var options = this.options;
    var capColor = options.cap.color || options.color;
    var circle = new geometry_exports.Circle(this.center, this.capSize);
    var cap = new Circle(circle, {
      fill: { color: capColor },
      stroke: { color: capColor }
    });
    return cap;
  };
  return RadialPointer2;
}(pointer_default);
setDefaultOptions(RadialPointer, {
  cap: {
    size: CAP_SIZE
  },
  arrow: {
    width: 16,
    height: 14
  },
  animation: {
    type: RADIAL_POINTER,
    duration: ANGULAR_SPEED
  }
});
var radial_pointer_default = RadialPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-gauge.js
var Group7 = drawing_exports.Group;
var RadialGauge = function(Gauge2) {
  function RadialGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2) RadialGauge2.__proto__ = Gauge2;
  RadialGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  RadialGauge2.prototype.constructor = RadialGauge2;
  RadialGauge2.prototype.reflow = function reflow(bbox) {
    var this$1 = this;
    var pointers = this.pointers;
    this.scale.reflow(bbox);
    this._initialPlotArea = this.scale.bbox;
    for (var i36 = 0; i36 < pointers.length; i36++) {
      pointers[i36].reflow(this$1.scale.arc);
      this$1._initialPlotArea = geometry_exports.Rect.union(this$1._initialPlotArea, pointers[i36].bbox);
    }
    this.fitScale(bbox);
    this.alignScale(bbox);
    this._buildVisual(this.gaugeArea, pointers, this.scale);
    this._draw();
  };
  RadialGauge2.prototype._buildVisual = function _buildVisual(gaugeArea, pointers, scale) {
    var visuals = this._visuals = new Group7();
    visuals.append(gaugeArea);
    visuals.append(scale.ticks);
    visuals.append(scale.ranges);
    this._buildPointers(pointers);
    visuals.append(scale.labelElements);
  };
  RadialGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    var this$1 = this;
    for (var i36 = 0; i36 < pointers.length; i36++) {
      var current4 = pointers[i36];
      current4.render();
      this$1._visuals.append(current4.elements);
      current4.value(current4.options.value);
    }
  };
  RadialGauge2.prototype.fitScale = function fitScale(bbox) {
    var this$1 = this;
    var arc = this.scale.arc;
    var plotAreaBox = this._initialPlotArea;
    var step = Math.abs(this.getDiff(plotAreaBox, bbox));
    var min4 = round(step, COORD_PRECISION);
    var max3 = round(-step, COORD_PRECISION);
    var minDiff, midDiff, maxDiff, mid, oldDiff;
    var staleFlag = 0;
    var i36 = 0;
    while (i36++ < 100) {
      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;
      if (staleFlag > 5) {
        break;
      }
      if (min4 !== mid) {
        minDiff = this$1.getPlotBox(min4, bbox, arc);
        if (0 <= minDiff && minDiff <= 2) {
          break;
        }
      }
      if (max3 !== mid) {
        maxDiff = this$1.getPlotBox(max3, bbox, arc);
        if (0 <= maxDiff && maxDiff <= 2) {
          break;
        }
      }
      if (minDiff > 0 && maxDiff > 0) {
        mid = min4 * 2;
      } else if (minDiff < 0 && maxDiff < 0) {
        mid = max3 * 2;
      } else {
        mid = round((min4 + max3) / 2 || 1, COORD_PRECISION);
      }
      midDiff = this$1.getPlotBox(mid, bbox, arc);
      if (0 <= midDiff && midDiff <= 2) {
        break;
      }
      oldDiff = maxDiff;
      if (midDiff > 0) {
        max3 = mid;
        maxDiff = midDiff;
      } else {
        min4 = mid;
        minDiff = midDiff;
      }
    }
  };
  RadialGauge2.prototype.getPlotBox = function getPlotBox(step, bbox, arc) {
    var this$1 = this;
    var scale = this.scale;
    var pointers = this.pointers;
    var radius = arc.getRadiusX();
    var scaleArc = arc.clone();
    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);
    scale.arc = scaleArc;
    scale.reflow(bbox);
    this.plotBbox = scale.bbox;
    for (var i36 = 0; i36 < pointers.length; i36++) {
      pointers[i36].reflow(scaleArc);
      this$1.plotBbox = geometry_exports.Rect.union(this$1.plotBbox, pointers[i36].bbox);
    }
    return this.getDiff(this.plotBbox, bbox);
  };
  RadialGauge2.prototype.getDiff = function getDiff(plotBox, box) {
    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());
  };
  RadialGauge2.prototype.alignScale = function alignScale(bbox) {
    var this$1 = this;
    var plotBoxCenter = this.plotBbox.center();
    var boxCenter = bbox.center();
    var paddingX = plotBoxCenter.x - boxCenter.x;
    var paddingY = plotBoxCenter.y - boxCenter.y;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    scale.arc.center.x -= paddingX;
    scale.arc.center.y -= paddingY;
    scale.reflow(bbox);
    for (var i36 = 0; i36 < pointers.length; i36++) {
      pointers[i36].reflow(scale.arc);
      this$1.plotBbox = geometry_exports.Rect.union(scale.bbox, pointers[i36].bbox);
    }
  };
  RadialGauge2.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options = this.options;
    var pointers = options.pointer;
    var scale = this.scale = new radial_scale_default(options.scale, this.contextService);
    this.pointers = [];
    var pointersArr = isArray(pointers) ? pointers : [pointers];
    for (var i36 = 0; i36 < pointersArr.length; i36++) {
      var current4 = new radial_pointer_default(scale, deepExtend({}, pointersArr[i36], {
        animation: {
          transitions: options.transitions
        }
      }));
      this$1.pointers.push(current4);
    }
  };
  return RadialGauge2;
}(gauge_default);
setDefaultOptions(RadialGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  }
});
var radial_gauge_default = RadialGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-scale.js
var ArcScale = function(RadialScale2) {
  function ArcScale2() {
    RadialScale2.apply(this, arguments);
  }
  if (RadialScale2) ArcScale2.__proto__ = RadialScale2;
  ArcScale2.prototype = Object.create(RadialScale2 && RadialScale2.prototype);
  ArcScale2.prototype.constructor = ArcScale2;
  ArcScale2.prototype.rangeSegments = function rangeSegments() {
    var ref2 = this.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var rangePlaceholderColor = ref2.rangePlaceholderColor;
    var rangeLineCap = ref2.rangeLineCap;
    return [{ from: min4, to: max3, color: rangePlaceholderColor, lineCap: rangeLineCap }];
  };
  ArcScale2.prototype.hasRanges = function hasRanges() {
    return true;
  };
  ArcScale2.prototype.placeholderRangeAngle = function placeholderRangeAngle(angle) {
    var geometry = this.ranges.children[0].geometry();
    if (this.options.reverse) {
      geometry.setEndAngle(angle);
    } else {
      geometry.setStartAngle(angle);
    }
  };
  ArcScale2.prototype.addRange = function addRange(from, to, options) {
    var reverse = this.options.reverse;
    var startAngle = this.slotAngle(reverse ? to : from);
    var endAngle = this.slotAngle(reverse ? from : to);
    var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);
    this.ranges.append(range);
    return range;
  };
  return ArcScale2;
}(radial_scale_default);
setDefaultOptions(ArcScale, {
  min: 0,
  max: 100,
  majorTicks: {
    visible: false
  },
  minorTicks: {
    visible: false
  },
  labels: {
    visible: false
  },
  startAngle: 0,
  endAngle: 180,
  rangeLineCap: "round"
});
var arc_scale_default = ArcScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer-animation.js
var MAX_DURATION = 800;
var RangePointerAnimation = function(superclass) {
  function RangePointerAnimation2(element, options) {
    superclass.call(this, element, options);
    var animationOptions = this.options;
    var duration2 = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3;
    animationOptions.duration = limitValue(duration2, ANGULAR_SPEED, MAX_DURATION);
    var startColor = element.elements.options.get("stroke.color");
    var color = element.currentColor();
    if (startColor !== color) {
      this.startColor = new color_default(startColor);
      this.color = new color_default(color);
    }
  }
  if (superclass) RangePointerAnimation2.__proto__ = superclass;
  RangePointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RangePointerAnimation2.prototype.constructor = RangePointerAnimation2;
  RangePointerAnimation2.prototype.step = function step(pos) {
    var ref2 = this;
    var options = ref2.options;
    var startColor = ref2.startColor;
    var color = ref2.color;
    var angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.angle(angle);
    if (color) {
      var r27 = round(interpolateValue(startColor.r, color.r, pos));
      var g2 = round(interpolateValue(startColor.g, color.g, pos));
      var b2 = round(interpolateValue(startColor.b, color.b, pos));
      this.element.stroke(new color_default(r27, g2, b2).toHex());
    }
  };
  return RangePointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RangePointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);
var range_pointer_animation_default = RangePointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer.js
var RangePointer = function(Pointer2) {
  function RangePointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2) RangePointer2.__proto__ = Pointer2;
  RangePointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RangePointer2.prototype.constructor = RangePointer2;
  RangePointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var oldAngle = scale.slotAngle(options._oldValue);
    var newAngle = scale.slotAngle(options.value);
    if (this.animation) {
      this.animation.abort();
    }
    if (options.animation.transitions === false) {
      this.angle(newAngle);
      this.stroke(this.currentColor());
    } else {
      this.animation = new range_pointer_animation_default(this, deepExtend(options.animation, {
        oldAngle,
        newAngle
      }));
      this.animation.play();
    }
  };
  RangePointer2.prototype.angle = function angle(value2) {
    var geometry = this.elements.geometry();
    if (this.scale.options.reverse) {
      geometry.setStartAngle(value2);
    } else {
      geometry.setEndAngle(value2);
    }
    this.scale.placeholderRangeAngle(value2);
  };
  RangePointer2.prototype.stroke = function stroke(value2) {
    this.elements.stroke(value2);
  };
  RangePointer2.prototype.render = function render() {
    if (this.elements) {
      return;
    }
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    this.elements = scale.addRange(scale.options.min, this.options.value, {
      color: this.currentColor(),
      opacity: options.opacity,
      lineCap: scale.options.rangeLineCap
    });
  };
  RangePointer2.prototype.currentColor = function currentColor() {
    var ref2 = this.scale.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var ref$1 = this.options;
    var colors = ref$1.colors;
    var color = ref$1.color;
    var value2 = ref$1.value;
    var currentValue = isNumber(value2) ? value2 : min4;
    if (colors) {
      for (var idx = 0; idx < colors.length; idx++) {
        var ref$2 = colors[idx];
        var rangeColor = ref$2.color;
        var from = ref$2.from;
        if (from === void 0) from = min4;
        var to = ref$2.to;
        if (to === void 0) to = max3;
        if (from <= currentValue && currentValue <= to) {
          return rangeColor;
        }
      }
    }
    return color;
  };
  RangePointer2.prototype.reflow = function reflow() {
    this.render();
    this.bbox = this.elements.bbox();
  };
  return RangePointer2;
}(pointer_default);
setDefaultOptions(RangePointer, {
  animation: {
    type: RADIAL_RANGE_POINTER,
    duration: ANGULAR_SPEED
  }
});
var range_pointer_default = RangePointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-gauge.js
var ArcGauge = function(RadialGauge2) {
  function ArcGauge2() {
    RadialGauge2.apply(this, arguments);
  }
  if (RadialGauge2) ArcGauge2.__proto__ = RadialGauge2;
  ArcGauge2.prototype = Object.create(RadialGauge2 && RadialGauge2.prototype);
  ArcGauge2.prototype.constructor = ArcGauge2;
  ArcGauge2.prototype._initTheme = function _initTheme(theme) {
    RadialGauge2.prototype._initTheme.call(this, theme);
    this.options.color = this.options.color || (this.theme.pointer || {}).color;
  };
  ArcGauge2.prototype._createModel = function _createModel() {
    var options = this.options;
    var scale = this.scale = new arc_scale_default(options.scale, this.contextService);
    var pointer = new range_pointer_default(scale, deepExtend({}, {
      colors: options.colors,
      color: options.color,
      value: options.value,
      opacity: options.opacity,
      animation: {
        transitions: options.transitions
      }
    }));
    this.pointers = [pointer];
  };
  ArcGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    for (var i36 = 0; i36 < pointers.length; i36++) {
      var current4 = pointers[i36];
      current4.render();
      current4.value(current4.options.value);
    }
  };
  ArcGauge2.prototype._setValueOptions = function _setValueOptions(value2) {
    this.options.value = value2;
  };
  ArcGauge2.prototype.currentColor = function currentColor() {
    var pointer = this.pointers[0];
    if (pointer) {
      return pointer.currentColor();
    }
  };
  ArcGauge2.prototype.centerLabelPosition = function centerLabelPosition(width, height) {
    var size = this.getSize();
    var center = this.scale.arc.center;
    var left = center.x - width / 2;
    var top = center.y - height / 2;
    if (width < size.width) {
      var right = left + width;
      left = Math.max(left, 0);
      if (right > size.width) {
        left -= right - size.width;
      }
    }
    if (height < size.height) {
      var bbox = this.scale.bbox;
      var yLimit = bbox.bottomRight().y;
      var bottom = top + height;
      top = Math.max(top, bbox.origin.y);
      if (bottom > yLimit) {
        top -= bottom - yLimit;
      }
    }
    return {
      left,
      top
    };
  };
  return ArcGauge2;
}(radial_gauge_default);
var arc_gauge_default = ArcGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/circular/circular-gauge.js
var defaultStartAngle = 90;
var CircularGauge = function(ArcGauge2) {
  function CircularGauge2() {
    ArcGauge2.apply(this, arguments);
  }
  if (ArcGauge2) CircularGauge2.__proto__ = ArcGauge2;
  CircularGauge2.prototype = Object.create(ArcGauge2 && ArcGauge2.prototype);
  CircularGauge2.prototype.constructor = CircularGauge2;
  CircularGauge2.prototype._createModel = function _createModel() {
    var scaleOptions = this.options.scale;
    if (typeof scaleOptions.startAngle !== "number") {
      scaleOptions.startAngle = defaultStartAngle;
    }
    scaleOptions.endAngle = scaleOptions.startAngle + 360;
    ArcGauge2.prototype._createModel.call(this);
  };
  return CircularGauge2;
}(arc_gauge_default);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/encoding.js
var DEFAULT_QUIET_ZONE_LENGTH = 10;
var Encoding = function(Class) {
  function Encoding2(options) {
    Class.call(this);
    this.setOptions(options);
    this.initProperties();
  }
  if (Class) Encoding2.__proto__ = Class;
  Encoding2.prototype = Object.create(Class && Class.prototype);
  Encoding2.prototype.constructor = Encoding2;
  Encoding2.prototype.initProperties = function initProperties() {
  };
  Encoding2.prototype.setOptions = function setOptions(options) {
    this.options = Object.assign({}, this.options, options);
    this.quietZoneLength = this.options.addQuietZone ? 2 * this.options.quietZoneLength : 0;
  };
  Encoding2.prototype.encode = function encode(value2, width, height) {
    var convertedValue = defined(value2) ? String(value2) : value2;
    this.initValue(convertedValue, width, height);
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    this.addData();
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    return {
      baseUnit: this.baseUnit,
      pattern: this.pattern
    };
  };
  Encoding2.prototype.initValue = function initValue() {
  };
  Encoding2.prototype.addQuietZone = function addQuietZone() {
    this.pattern.push(this.options.quietZoneLength || DEFAULT_QUIET_ZONE_LENGTH);
  };
  Encoding2.prototype.addData = function addData() {
  };
  Encoding2.prototype.invalidCharacterError = function invalidCharacterError(character) {
    throw new Error('Character "' + character + '" is not valid for symbology ' + this.name + ".");
  };
  return Encoding2;
}(class_default);
setDefaultOptions(Encoding, {
  quietZoneLength: DEFAULT_QUIET_ZONE_LENGTH,
  addQuietZone: true,
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code11.js
var extend2 = Object.assign;
var Code11 = function(Encoding2) {
  function Code112() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Code112.__proto__ = Encoding2;
  Code112.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code112.prototype.constructor = Code112;
  Code112.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend2(this, {
      name: "Code 11",
      characterMap: ["111121", "211121", "121121", "221111", "112121", "212111", "122111", "111221", "211211", "211111", "112111"],
      cCheckSumTotal: 10,
      kCheckSumTotal: 9,
      kCheckSumMinLength: 10,
      checkSumMod: 11,
      DASH_VALUE: 10,
      DASH: "-",
      START: "112211",
      STOP: "11221"
    });
  };
  Code112.prototype.initValue = function initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.totalUnits = 0;
  };
  Code112.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i36 = 0; i36 < value2.length; i36++) {
      this$1.addCharacter(value2.charAt(i36));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  Code112.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code112.prototype.addCheckSum = function addCheckSum() {
    var value2 = this.value;
    var length = value2.length;
    var cValue = this.getWeightedSum(value2, length, this.cCheckSumTotal) % this.checkSumMod;
    this.checksum = String(cValue);
    this.addPattern(this.characterMap[cValue]);
    length++;
    if (length >= this.kCheckSumMinLength) {
      var kValue = (cValue + this.getWeightedSum(value2, length, this.kCheckSumTotal)) % this.checkSumMod;
      this.checksum += kValue;
      this.addPattern(this.characterMap[kValue]);
    }
  };
  Code112.prototype.getWeightedSum = function getWeightedSum(value2, length, total3) {
    var this$1 = this;
    var weightedSum = 0;
    for (var i36 = 0; i36 < value2.length; i36++) {
      weightedSum += this$1.weightedValue(this$1.getValue(value2.charAt(i36)), length, i36, total3);
    }
    return weightedSum;
  };
  Code112.prototype.weightedValue = function weightedValue(value2, length, index, total3) {
    var weight = (length - index) % total3 || total3;
    return weight * value2;
  };
  Code112.prototype.getValue = function getValue(character) {
    if (!isNaN(character)) {
      return parseInt(character, 10);
    } else if (character !== this.DASH) {
      this.invalidCharacterError(character);
    }
    return this.DASH_VALUE;
  };
  Code112.prototype.addCharacter = function addCharacter2(character) {
    var value2 = this.getValue(character);
    var pattern = this.characterMap[value2];
    this.addPattern(pattern);
  };
  Code112.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value2;
    for (var i36 = 0; i36 < pattern.length; i36++) {
      value2 = parseInt(pattern.charAt(i36), 10);
      this$1.pattern.push(value2);
      this$1.totalUnits += value2;
    }
  };
  return Code112;
}(Encoding);
setDefaultOptions(Code11, {
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39.js
var extend3 = Object.assign;
var Code39Base = function(Encoding2) {
  function Code39Base2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Code39Base2.__proto__ = Encoding2;
  Code39Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code39Base2.prototype.constructor = Code39Base2;
  Code39Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend3(this, {
      minBaseUnitLength: 0.7
    });
  };
  Code39Base2.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addStart();
    for (var idx = 0; idx < value2.length; idx++) {
      this$1.addCharacter(value2.charAt(idx));
    }
    if (this.options.addCheckSum) {
      this.pushCheckSum();
    }
    this.addStop();
    this.prepareValues();
  };
  Code39Base2.prototype.addCharacter = function addCharacter2(character) {
    var characterData = this.characterMap[character];
    if (!characterData) {
      this.invalidCharacterError(character);
    }
    this.addBase(characterData);
  };
  Code39Base2.prototype.addBase = function addBase() {
  };
  return Code39Base2;
}(Encoding);
var Code39 = function(Code39Base2) {
  function Code392() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2) Code392.__proto__ = Code39Base2;
  Code392.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code392.prototype.constructor = Code392;
  Code392.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend3(this, {
      name: "Code 39",
      checkSumMod: 43,
      minRatio: 2.5,
      maxRatio: 3,
      gapWidth: 1,
      splitCharacter: "|",
      patternMappings: {
        "b": "1|",
        "w": "1|",
        "B": "ratio|",
        "W": "ratio|"
      },
      characterMap: {
        "0": { "pattern": "bwbWBwBwb", "value": 0 },
        "1": { "pattern": "BwbWbwbwB", "value": 1 },
        "2": { "pattern": "bwBWbwbwB", "value": 2 },
        "3": { "pattern": "BwBWbwbwb", "value": 3 },
        "4": { "pattern": "bwbWBwbwB", "value": 4 },
        "5": { "pattern": "BwbWBwbwb", "value": 5 },
        "6": { "pattern": "bwBWBwbwb", "value": 6 },
        "7": { "pattern": "bwbWbwBwB", "value": 7 },
        "8": { "pattern": "BwbWbwBwb", "value": 8 },
        "9": { "pattern": "bwBWbwBwb", "value": 9 },
        "A": { "pattern": "BwbwbWbwB", "value": 10 },
        "B": { "pattern": "bwBwbWbwB", "value": 11 },
        "C": { "pattern": "BwBwbWbwb", "value": 12 },
        "D": { "pattern": "bwbwBWbwB", "value": 13 },
        "E": { "pattern": "BwbwBWbwb", "value": 14 },
        "F": { "pattern": "bwBwBWbwb", "value": 15 },
        "G": { "pattern": "bwbwbWBwB", "value": 16 },
        "H": { "pattern": "BwbwbWBwb", "value": 17 },
        "I": { "pattern": "bwBwbWBwb", "value": 18 },
        "J": { "pattern": "bwbwBWBwb", "value": 19 },
        "K": { "pattern": "BwbwbwbWB", "value": 20 },
        "L": { "pattern": "bwBwbwbWB", "value": 21 },
        "M": { "pattern": "BwBwbwbWb", "value": 22 },
        "N": { "pattern": "bwbwBwbWB", "value": 23 },
        "O": { "pattern": "BwbwBwbWb", "value": 24 },
        "P": { "pattern": "bwBwBwbWb", "value": 25 },
        "Q": { "pattern": "bwbwbwBWB", "value": 26 },
        "R": { "pattern": "BwbwbwBWb", "value": 27 },
        "S": { "pattern": "bwBwbwBWb", "value": 28 },
        "T": { "pattern": "bwbwBwBWb", "value": 29 },
        "U": { "pattern": "BWbwbwbwB", "value": 30 },
        "V": { "pattern": "bWBwbwbwB", "value": 31 },
        "W": { "pattern": "BWBwbwbwb", "value": 32 },
        "X": { "pattern": "bWbwBwbwB", "value": 33 },
        "Y": { "pattern": "BWbwBwbwb", "value": 34 },
        "Z": { "pattern": "bWBwBwbwb", "value": 35 },
        "-": { "pattern": "bWbwbwBwB", "value": 36 },
        ".": { "pattern": "BWbwbwBwb", "value": 37 },
        " ": { "pattern": "bWBwbwBwb", "value": 38 },
        "$": { "pattern": "bWbWbWbwb", "value": 39 },
        "/": { "pattern": "bWbWbwbWb", "value": 40 },
        "+": { "pattern": "bWbwbWbWb", "value": 41 },
        "%": { "pattern": "bwbWbWbWb", "value": 42 },
        START: { pattern: "bWbwBwBwb" }
      }
    });
  };
  Code392.prototype.initValue = function initValue(value2, width, height) {
    this.width = width;
    this.height = height;
    this.value = value2;
    this.dataLength = value2.length;
    this.pattern = [];
    this.patternString = "";
  };
  Code392.prototype.prepareValues = function prepareValues() {
    var this$1 = this;
    var minBaseUnit = this.minBaseUnitLength;
    var minRatio = this.minRatio;
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    var baseUnit;
    var ratio = this.maxRatio;
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code39 encoding: the current height is " + this.height + "px and the minimum height is " + minHeight + "px.");
    }
    baseUnit = this.getBaseUnit(ratio);
    while (baseUnit < minBaseUnit && ratio > minRatio) {
      ratio = parseFloat((ratio - 0.1).toFixed(1));
      baseUnit = this$1.getBaseUnit(ratio);
    }
    if (baseUnit < minBaseUnit) {
      var minWidth = Math.ceil(this.getBaseWidth(minRatio) * minBaseUnit);
      throw new Error("Insufficient width for Code39 encoding: the current width is " + this.width + 'px and the minimum width for value "' + this.value + '" is ' + minWidth + "px.");
    }
    this.ratio = ratio;
    this.baseUnit = baseUnit;
    this.patternString = this.patternString.substring(0, this.patternString.length - 1);
    this.pattern = this.pattern.concat(this.patternString.replace(/ratio/g, ratio).split(this.splitCharacter));
  };
  Code392.prototype.getBaseUnit = function getBaseUnit(ratio) {
    return this.width / this.getBaseWidth(ratio);
  };
  Code392.prototype.getBaseWidth = function getBaseWidth(ratio) {
    var characterLength = 3 * (ratio + 2);
    return this.quietZoneLength + characterLength * (this.dataLength + 2) + this.gapWidth * (this.dataLength + 1);
  };
  Code392.prototype.addStart = function addStart() {
    this.addPattern(this.characterMap.START.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addBase = function addBase(character) {
    this.addPattern(character.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addStop = function addStop() {
    this.addPattern(this.characterMap.START.pattern);
  };
  Code392.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i36 = 0; i36 < pattern.length; i36++) {
      this$1.patternString += this$1.patternMappings[pattern.charAt(i36)];
    }
  };
  Code392.prototype.addCharacterGap = function addCharacterGap() {
    this.patternString += this.gapWidth + this.splitCharacter;
  };
  return Code392;
}(Code39Base);
setDefaultOptions(Code39, {
  addCheckSum: false
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39-extended.js
var Code39ExtendedBase = {
  addCharacter: function addCharacter(character) {
    if (this.characterMap[character]) {
      this.addBase(this.characterMap[character]);
    } else if (character.charCodeAt(0) > 127) {
      this.invalidCharacterError(character);
    } else {
      this.addExtended(character.charCodeAt(0));
    }
  },
  addExtended: function addExtended(code) {
    var this$1 = this;
    var patterns;
    for (var i36 = 0; i36 < this.extendedMappings.length; i36++) {
      patterns = this$1.extendedMappings[i36].call(this$1, code);
      if (patterns) {
        for (var patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
          var pattern = patterns[patternIndex];
          this$1.addBase(pattern);
        }
        this$1.dataLength += patterns.length - 1;
        return;
      }
    }
  },
  extendedMappings: [
    function(code) {
      if (97 <= code && code <= 122) {
        return [this.characterMap[this.shiftCharacters[0]], this.characterMap[String.fromCharCode(code - 32)]];
      }
    },
    function(code) {
      if (33 <= code && code <= 58) {
        return [this.characterMap[this.shiftCharacters[1]], this.characterMap[String.fromCharCode(code + 32)]];
      }
    },
    function(code) {
      if (1 <= code && code <= 26) {
        return [this.characterMap[this.shiftCharacters[2]], this.characterMap[String.fromCharCode(code + 64)]];
      }
    },
    function(code) {
      var this$1 = this;
      var result;
      var dataCharacter;
      if (!this.specialAsciiCodes[code]) {
        dataCharacter = Math.floor(code / 32) * 6 + (code - 27) % 32 + 64;
        result = [this.characterMap[this.shiftCharacters[3]], this.characterMap[String.fromCharCode(dataCharacter)]];
      } else {
        result = [];
        for (var i36 = 0; i36 < this.specialAsciiCodes[code].length; i36++) {
          result.push(this$1.characterMap[this$1.shiftCharacters[3]]);
          result.push(this$1.characterMap[this$1.specialAsciiCodes[code][i36]]);
        }
      }
      return result;
    }
  ],
  specialAsciiCodes: {
    "0": ["U"],
    "64": ["V"],
    "96": ["W"],
    "127": ["T", "X", "Y", "Z"]
  },
  shiftValuesAsciiCodes: {
    "39": 36,
    "40": 47,
    "41": 43,
    "42": 37
  },
  characterMap: {
    "+": false,
    "/": false,
    "$": false,
    "%": false
  },
  shiftCharacters: ["SHIFT0", "SHIFT1", "SHIFT2", "SHIFT3"]
};
var Code39Extended = function(Code392) {
  function Code39Extended2() {
    Code392.apply(this, arguments);
  }
  if (Code392) Code39Extended2.__proto__ = Code392;
  Code39Extended2.prototype = Object.create(Code392 && Code392.prototype);
  Code39Extended2.prototype.constructor = Code39Extended2;
  Code39Extended2.prototype.initProperties = function initProperties() {
    Code392.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 39 extended",
      characterMap: {
        SHIFT0: { "pattern": "bWbwbWbWb", "value": 41 },
        SHIFT1: { "pattern": "bWbWbwbWb", "value": 40 },
        SHIFT2: { "pattern": "bWbWbWbwb", "value": 39 },
        SHIFT3: { "pattern": "bwbWbWbWb", "value": 42 }
      }
    });
  };
  return Code39Extended2;
}(Code39);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93.js
var extend4 = Object.assign;
var Code93 = function(Code39Base2) {
  function Code932() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2) Code932.__proto__ = Code39Base2;
  Code932.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code932.prototype.constructor = Code932;
  Code932.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend4(this, {
      name: "Code 93",
      cCheckSumTotal: 20,
      kCheckSumTotal: 15,
      checkSumMod: 47,
      characterMap: {
        "0": { "pattern": "131112", "value": 0 },
        "1": { "pattern": "111213", "value": 1 },
        "2": { "pattern": "111312", "value": 2 },
        "3": { "pattern": "111411", "value": 3 },
        "4": { "pattern": "121113", "value": 4 },
        "5": { "pattern": "121212", "value": 5 },
        "6": { "pattern": "121311", "value": 6 },
        "7": { "pattern": "111114", "value": 7 },
        "8": { "pattern": "131211", "value": 8 },
        "9": { "pattern": "141111", "value": 9 },
        "A": { "pattern": "211113", "value": 10 },
        "B": { "pattern": "211212", "value": 11 },
        "C": { "pattern": "211311", "value": 12 },
        "D": { "pattern": "221112", "value": 13 },
        "E": { "pattern": "221211", "value": 14 },
        "F": { "pattern": "231111", "value": 15 },
        "G": { "pattern": "112113", "value": 16 },
        "H": { "pattern": "112212", "value": 17 },
        "I": { "pattern": "112311", "value": 18 },
        "J": { "pattern": "122112", "value": 19 },
        "K": { "pattern": "132111", "value": 20 },
        "L": { "pattern": "111123", "value": 21 },
        "M": { "pattern": "111222", "value": 22 },
        "N": { "pattern": "111321", "value": 23 },
        "O": { "pattern": "121122", "value": 24 },
        "P": { "pattern": "131121", "value": 25 },
        "Q": { "pattern": "212112", "value": 26 },
        "R": { "pattern": "212211", "value": 27 },
        "S": { "pattern": "211122", "value": 28 },
        "T": { "pattern": "211221", "value": 29 },
        "U": { "pattern": "221121", "value": 30 },
        "V": { "pattern": "222111", "value": 31 },
        "W": { "pattern": "112122", "value": 32 },
        "X": { "pattern": "112221", "value": 33 },
        "Y": { "pattern": "122121", "value": 34 },
        "Z": { "pattern": "123111", "value": 35 },
        "-": { "pattern": "121131", "value": 36 },
        ".": { "pattern": "311112", "value": 37 },
        " ": { "pattern": "311211", "value": 38 },
        "$": { "pattern": "321111", "value": 39 },
        "/": { "pattern": "112131", "value": 40 },
        "+": { "pattern": "113121", "value": 41 },
        "%": { "pattern": "211131", "value": 42 },
        SHIFT0: { "pattern": "122211", "value": 46 },
        SHIFT1: { "pattern": "311121", "value": 45 },
        SHIFT2: { "pattern": "121221", "value": 43 },
        SHIFT3: { "pattern": "312111", "value": 44 },
        START: { "pattern": "111141" },
        TERMINATION_BAR: "1"
      }
    });
  };
  Code932.prototype.initValue = function initValue(value2, width, height) {
    this.value = value2;
    this.width = width;
    this.height = height;
    this.pattern = [];
    this.values = [];
    this.dataLength = value2.length;
  };
  Code932.prototype.prepareValues = function prepareValues() {
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code93 encoding: the current height is " + this.height + "px, the minimum required height is " + minHeight + "px.");
    }
    this.setBaseUnit();
    if (this.baseUnit < this.minBaseUnitLength) {
      var minWidth = Math.ceil(this.minBaseUnitLength * (this.width / this.baseUnit));
      throw new Error("Insufficient width for Code93 encoding: the current width is " + this.width + 'px and the minimum required width for value "' + this.value + '" is ' + minWidth + "px.");
    }
  };
  Code932.prototype.setBaseUnit = function setBaseUnit() {
    var checkSumLength = 2;
    this.baseUnit = this.width / (9 * (this.dataLength + 2 + checkSumLength) + this.quietZoneLength + 1);
  };
  Code932.prototype.addStart = function addStart() {
    var pattern = this.characterMap.START.pattern;
    this.addPattern(pattern);
  };
  Code932.prototype.addStop = function addStop() {
    this.addStart();
    this.pattern.push(this.characterMap.TERMINATION_BAR);
  };
  Code932.prototype.addBase = function addBase(charData) {
    this.addPattern(charData.pattern);
    this.values.push(charData.value);
  };
  Code932.prototype.pushCheckSum = function pushCheckSum() {
    var this$1 = this;
    var checkValues = this._getCheckValues();
    var charData;
    this.checksum = checkValues.join("");
    for (var i36 = 0; i36 < checkValues.length; i36++) {
      charData = this$1.characterMap[this$1._findCharacterByValue(checkValues[i36])];
      this$1.addPattern(charData.pattern);
    }
  };
  Code932.prototype._getCheckValues = function _getCheckValues() {
    var this$1 = this;
    var values5 = this.values;
    var length = values5.length;
    var wightedSum = 0;
    var cValue;
    var kValue;
    var idx;
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx, this$1.cCheckSumTotal);
    }
    cValue = wightedSum % this.checkSumMod;
    wightedSum = this.weightedValue(cValue, 1, this.kCheckSumTotal);
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx + 1, this$1.kCheckSumTotal);
    }
    kValue = wightedSum % this.checkSumMod;
    return [cValue, kValue];
  };
  Code932.prototype._findCharacterByValue = function _findCharacterByValue(value2) {
    var this$1 = this;
    for (var character in this$1.characterMap) {
      if (this$1.characterMap[character].value === value2) {
        return character;
      }
    }
  };
  Code932.prototype.weightedValue = function weightedValue(value2, index, total3) {
    return (index % total3 || total3) * value2;
  };
  Code932.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value2;
    for (var i36 = 0; i36 < pattern.length; i36++) {
      value2 = parseInt(pattern.charAt(i36), 10);
      this$1.pattern.push(value2);
    }
  };
  return Code932;
}(Code39Base);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93-extended.js
var Code93Extended = function(Code932) {
  function Code93Extended2() {
    Code932.apply(this, arguments);
  }
  if (Code932) Code93Extended2.__proto__ = Code932;
  Code93Extended2.prototype = Object.create(Code932 && Code932.prototype);
  Code93Extended2.prototype.constructor = Code93Extended2;
  Code93Extended2.prototype.initProperties = function initProperties() {
    Code932.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 93 extended",
      pushCheckSum: function() {
        var this$1 = this;
        var checkValues = this._getCheckValues();
        var value2;
        this.checksum = checkValues.join("");
        for (var i36 = 0; i36 < checkValues.length; i36++) {
          value2 = checkValues[i36];
          if (this$1.shiftValuesAsciiCodes[value2]) {
            this$1.addExtended(this$1.shiftValuesAsciiCodes[value2]);
          } else {
            var characterByValue = this$1._findCharacterByValue(value2);
            this$1.addPattern(this$1.characterMap[characterByValue].pattern);
          }
        }
      }
    });
  };
  return Code93Extended2;
}(Code93);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/postnet.js
var numberRegex = /^\d+$/;
var extend5 = Object.assign;
var Postnet = function(Encoding2) {
  function Postnet2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Postnet2.__proto__ = Encoding2;
  Postnet2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Postnet2.prototype.constructor = Postnet2;
  Postnet2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Postnet",
      START: "2",
      VALID_CODE_LENGTHS: [5, 9, 11],
      DIGIT_SEPARATOR: "-",
      characterMap: ["22111", "11122", "11212", "11221", "12112", "12121", "12211", "21112", "21121", "21211"]
    });
  };
  Postnet2.prototype.initValue = function initValue(value2, width, height) {
    this.height = height;
    this.width = width;
    this.baseHeight = height / 2;
    this.value = value2.replace(new RegExp(this.DIGIT_SEPARATOR, "g"), "");
    this.pattern = [];
    this.validate(this.value);
    this.checkSum = 0;
    this.setBaseUnit();
  };
  Postnet2.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i36 = 0; i36 < value2.length; i36++) {
      this$1.addCharacter(value2.charAt(i36));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.START);
    this.pattern.pop();
  };
  Postnet2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    this.checkSum += parseInt(character, 10);
    this.addPattern(pattern);
  };
  Postnet2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = (10 - this.checkSum % 10) % 10;
    this.addCharacter(this.checksum);
  };
  Postnet2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 3;
    this.baseUnit = this.width / ((this.value.length + 1) * 10 + startStopLength + this.quietZoneLength);
  };
  Postnet2.prototype.validate = function validate(value2) {
    if (!numberRegex.test(value2)) {
      this.invalidCharacterError(value2.match(/[^0-9]/)[0]);
    }
    if (!inArray(value2.length, this.VALID_CODE_LENGTHS)) {
      throw new Error("Invalid value length. Valid lengths for the Postnet symbology are " + this.VALID_CODE_LENGTHS.join(",") + ".");
    }
  };
  Postnet2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var y1;
    for (var i36 = 0; i36 < pattern.length; i36++) {
      y1 = this$1.height - this$1.baseHeight * pattern.charAt(i36);
      this$1.pattern.push({ width: 1, y1, y2: this$1.height });
      this$1.pattern.push(1);
    }
  };
  return Postnet2;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code128.js
var numberRegex2 = /^\d+$/;
var alphanumericRegex = /^[a-z0-9]+$/i;
var extend6 = Object.assign;
var State128 = function(Class) {
  function State1282(encoding) {
    Class.call(this);
    this.encoding = encoding;
    this.initProperties();
  }
  if (Class) State1282.__proto__ = Class;
  State1282.prototype = Object.create(Class && Class.prototype);
  State1282.prototype.constructor = State1282;
  State1282.prototype.initProperties = function initProperties() {
  };
  State1282.prototype.addStart = function addStart() {
  };
  State1282.prototype.is = function is() {
  };
  State1282.prototype.isCode = function isCode() {
    return false;
  };
  State1282.prototype.move = function move() {
  };
  State1282.prototype.pushState = function pushState() {
  };
  return State1282;
}(class_default);
var State128AB = function(State1282) {
  function State128AB2(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
    this._initMoves(states);
  }
  if (State1282) State128AB2.__proto__ = State1282;
  State128AB2.prototype = Object.create(State1282 && State1282.prototype);
  State128AB2.prototype.constructor = State128AB2;
  State128AB2.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    deepExtend(this, {
      FNC4: "FNC4",
      SHIFT: 98
    });
  };
  State128AB2.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128AB2.prototype.is = function is(value2, index) {
    var code = value2.charCodeAt(index);
    return this.isCode(code);
  };
  State128AB2.prototype.move = function move(encodingState) {
    var idx = 0;
    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {
      idx++;
    }
  };
  State128AB2.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var states = this.states, value2 = encodingState.value, maxLength = value2.length, code;
    if (inArray("C", states)) {
      var numberMatch = value2.substr(encodingState.index).match(/\d{4,}/g);
      if (numberMatch) {
        maxLength = value2.indexOf(numberMatch[0], encodingState.index);
      }
    }
    while ((code = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code) && encodingState.index < maxLength) {
      this$1.encoding.addPattern(this$1.getValue(code));
      encodingState.index++;
    }
  };
  State128AB2.prototype._initMoves = function _initMoves(states) {
    this._moves = [];
    if (inArray(this.FNC4, states)) {
      this._moves.push(this._moveFNC);
    }
    if (inArray(this.shiftKey, states)) {
      this._moves.push(this._shiftState);
    }
    this._moves.push(this._moveState);
  };
  State128AB2.prototype._moveFNC = function _moveFNC(encodingState) {
    if (encodingState.fnc) {
      encodingState.fnc = false;
      return encodingState.previousState === this.key;
    }
  };
  State128AB2.prototype._shiftState = function _shiftState(encodingState) {
    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {
      this.encoding.addPattern(this.SHIFT);
      encodingState.shifted = true;
      return true;
    }
  };
  State128AB2.prototype._moveState = function _moveState() {
    this.encoding.addPattern(this.MOVE);
    return true;
  };
  return State128AB2;
}(State128);
var states128 = {};
states128.A = function(State128AB2) {
  function State128A() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2) State128A.__proto__ = State128AB2;
  State128A.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128A.prototype.constructor = State128A;
  State128A.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend6(this, {
      key: "A",
      shiftKey: "B",
      MOVE: 101,
      START: 103
    });
  };
  State128A.prototype.isCode = function isCode(code) {
    return 0 <= code && code < 96;
  };
  State128A.prototype.getValue = function getValue(code) {
    if (code < 32) {
      return code + 64;
    }
    return code - 32;
  };
  return State128A;
}(State128AB);
states128.B = function(State128AB2) {
  function State128B() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2) State128B.__proto__ = State128AB2;
  State128B.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128B.prototype.constructor = State128B;
  State128B.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend6(this, {
      key: "B",
      shiftKey: "A",
      MOVE: 100,
      START: 104
    });
  };
  State128B.prototype.isCode = function isCode(code) {
    return 32 <= code && code < 128;
  };
  State128B.prototype.getValue = function getValue(code) {
    return code - 32;
  };
  return State128B;
}(State128AB);
states128.C = function(State1282) {
  function State128C() {
    State1282.apply(this, arguments);
  }
  if (State1282) State128C.__proto__ = State1282;
  State128C.prototype = Object.create(State1282 && State1282.prototype);
  State128C.prototype.constructor = State128C;
  State128C.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend6(this, {
      key: "C",
      MOVE: 99,
      START: 105
    });
  };
  State128C.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128C.prototype.is = function is(value2, index) {
    var next4 = getSubstring(value2, index, 4);
    return (index + 4 <= value2.length || value2.length === 2) && numberRegex2.test(next4);
  };
  State128C.prototype.move = function move() {
    this.encoding.addPattern(this.MOVE);
  };
  State128C.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var code;
    while ((code = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex2.test(code) && code.length === 2) {
      this$1.encoding.addPattern(parseInt(code, 10));
      encodingState.index += 2;
    }
  };
  State128C.prototype.getValue = function getValue(code) {
    return code;
  };
  return State128C;
}(State128);
states128.FNC4 = function(State1282) {
  function State128FNC4(encoding, states) {
    State1282.call(this, encoding);
    this._initSubStates(states);
  }
  if (State1282) State128FNC4.__proto__ = State1282;
  State128FNC4.prototype = Object.create(State1282 && State1282.prototype);
  State128FNC4.prototype.constructor = State128FNC4;
  State128FNC4.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend6(this, {
      key: "FNC4",
      dependentStates: ["A", "B"]
    });
  };
  State128FNC4.prototype.addStart = function addStart(encodingState) {
    var code = encodingState.value.charCodeAt(0) - 128, subState = this._getSubState(code);
    this.encoding[subState].addStart();
  };
  State128FNC4.prototype.is = function is(value2, index) {
    var code = value2.charCodeAt(index);
    return this.isCode(code);
  };
  State128FNC4.prototype.isCode = function isCode(code) {
    return 128 <= code && code < 256;
  };
  State128FNC4.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var subState = this._initSubState(encodingState), encoding = this.encoding, length = subState.value.length;
    var code;
    encodingState.index += length;
    if (length < 3) {
      for (; subState.index < length; subState.index++) {
        code = subState.value.charCodeAt(subState.index);
        subState.state = this$1._getSubState(code);
        if (subState.previousState !== subState.state) {
          subState.previousState = subState.state;
          encoding[subState.state].move(subState);
        }
        encoding.addPattern(encoding[subState.state].MOVE);
        encoding.addPattern(encoding[subState.state].getValue(code));
      }
    } else {
      if (subState.state !== subState.previousState) {
        encoding[subState.state].move(subState);
      }
      this._pushStart(subState);
      encoding.pushData(subState, this.subStates);
      if (encodingState.index < encodingState.value.length) {
        this._pushStart(subState);
      }
    }
    encodingState.fnc = true;
    encodingState.state = subState.state;
  };
  State128FNC4.prototype._pushStart = function _pushStart(subState) {
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
  };
  State128FNC4.prototype._initSubState = function _initSubState(encodingState) {
    var subState = {
      value: this._getAll(encodingState.value, encodingState.index),
      index: 0
    };
    subState.state = this._getSubState(subState.value.charCodeAt(0));
    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;
    return subState;
  };
  State128FNC4.prototype._initSubStates = function _initSubStates(states) {
    var this$1 = this;
    this.subStates = [];
    for (var i36 = 0; i36 < states.length; i36++) {
      if (inArray(states[i36], this$1.dependentStates)) {
        this$1.subStates.push(states[i36]);
      }
    }
  };
  State128FNC4.prototype._getSubState = function _getSubState(code) {
    var this$1 = this;
    for (var i36 = 0; i36 < this.subStates.length; i36++) {
      if (this$1.encoding[this$1.subStates[i36]].isCode(code)) {
        return this$1.subStates[i36];
      }
    }
  };
  State128FNC4.prototype._getAll = function _getAll(value2, index) {
    var code;
    var result = "";
    var i36 = index;
    while ((code = value2.charCodeAt(i36++)) && this.isCode(code)) {
      result += String.fromCharCode(code - 128);
    }
    return result;
  };
  return State128FNC4;
}(State128);
states128.FNC1 = function(State1282) {
  function States128FNC1(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
  }
  if (State1282) States128FNC1.__proto__ = State1282;
  States128FNC1.prototype = Object.create(State1282 && State1282.prototype);
  States128FNC1.prototype.constructor = States128FNC1;
  States128FNC1.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend6(this, {
      key: "FNC1",
      startState: "C",
      startAI: "(",
      endAI: ")",
      dependentStates: ["C", "B"],
      applicationIdentifiers: {
        "22": { max: 29, type: "alphanumeric" },
        "402": { length: 17 },
        "7004": { max: 4, type: "alphanumeric" },
        "242": { max: 6, type: "alphanumeric" },
        "8020": { max: 25, type: "alphanumeric" },
        "703": { min: 3, max: 30, type: "alphanumeric" },
        "8008": { min: 8, max: 12, type: "alphanumeric" },
        "253": { min: 13, max: 17, type: "alphanumeric" },
        "8003": { min: 14, max: 30, type: "alphanumeric" },
        multiKey: [{
          ids: ["15", "17", "8005", "8100"],
          ranges: [
            [11, 13],
            [310, 316],
            [320, 336],
            [340, 369]
          ],
          type: { length: 6 }
        }, {
          ids: ["240", "241", "250", "251", "400", "401", "403", "7002", "8004", "8007", "8110"],
          ranges: [[90 - 99]],
          type: { max: 30, type: "alphanumeric" }
        }, {
          ids: ["7001"],
          ranges: [[410, 414]],
          type: { length: 13 }
        }, {
          ids: ["10", "21", "254", "420", "8002"],
          type: { max: 20, type: "alphanumeric" }
        }, {
          ids: ["00", "8006", "8017", "8018"],
          type: { length: 18 }
        }, {
          ids: ["01", "02", "8001"],
          type: { length: 14 }
        }, {
          ids: ["422"],
          ranges: [
            [424, 426]
          ],
          type: { length: 3 }
        }, {
          ids: ["20", "8102"],
          type: { length: 2 }
        }, {
          ids: ["30", "37"],
          type: { max: 8, type: "alphanumeric" }
        }, {
          ids: ["390", "392"],
          type: { max: 15, type: "alphanumeric" }
        }, {
          ids: ["421", "423"],
          type: { min: 3, max: 15, type: "alphanumeric" }
        }, {
          ids: ["391", "393"],
          type: { min: 3, max: 18, type: "alphanumeric" }
        }, {
          ids: ["7003", "8101"],
          type: { length: 10 }
        }]
      },
      START: 102
    });
  };
  States128FNC1.prototype.addStart = function addStart() {
    this.encoding[this.startState].addStart();
  };
  States128FNC1.prototype.is = function is() {
    return inArray(this.key, this.states);
  };
  States128FNC1.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var encoding = this.encoding, value2 = encodingState.value.replace(/\s/g, ""), regexSeparators = new RegExp("[" + this.startAI + this.endAI + "]", "g"), index = encodingState.index, subState = {
      state: this.startState
    }, current4, nextStart, separatorLength;
    encoding.addPattern(this.START);
    var trueCondition = true;
    while (trueCondition) {
      subState.index = 0;
      separatorLength = value2.charAt(index) === this$1.startAI ? 2 : 0;
      current4 = separatorLength > 0 ? this$1.getBySeparator(value2, index) : this$1.getByLength(value2, index);
      if (current4.ai.length) {
        nextStart = index + separatorLength + current4.id.length + current4.ai.length;
      } else {
        nextStart = value2.indexOf(this$1.startAI, index + 1);
        if (nextStart < 0) {
          if (index + current4.ai.max + current4.id.length + separatorLength < value2.length) {
            throw new Error("Separators are required after variable length identifiers");
          }
          nextStart = value2.length;
        }
      }
      subState.value = value2.substring(index, nextStart).replace(regexSeparators, "");
      this$1.validate(current4, subState.value);
      encoding.pushData(subState, this$1.dependentStates);
      if (nextStart >= value2.length) {
        break;
      }
      index = nextStart;
      if (subState.state !== this$1.startState) {
        encoding[this$1.startState].move(subState);
        subState.state = this$1.startState;
      }
      if (!current4.ai.length) {
        encoding.addPattern(this$1.START);
      }
    }
    encodingState.index = encodingState.value.length;
  };
  States128FNC1.prototype.validate = function validate(current4, value2) {
    var code = value2.substr(current4.id.length), ai = current4.ai;
    if (!ai.type && !numberRegex2.test(code)) {
      throw new Error("Application identifier " + current4.id + " is numeric only but contains non numeric character(s).");
    }
    if (ai.type === "alphanumeric" && !alphanumericRegex.test(code)) {
      throw new Error("Application identifier " + current4.id + " is alphanumeric only but contains non alphanumeric character(s).");
    }
    if (ai.length && ai.length !== code.length) {
      throw new Error("Application identifier " + current4.id + " must be " + ai.length + " characters long.");
    }
    if (ai.min && ai.min > code.length) {
      throw new Error("Application identifier " + current4.id + " must be at least " + ai.min + " characters long.");
    }
    if (ai.max && ai.max < code.length) {
      throw new Error("Application identifier " + current4.id + " must be at most " + ai.max + " characters long.");
    }
  };
  States128FNC1.prototype.getByLength = function getByLength(value2, index) {
    var this$1 = this;
    var id;
    var applicationIdentifier;
    for (var i36 = 2; i36 <= 4; i36++) {
      id = getSubstring(value2, index, i36);
      applicationIdentifier = this$1.getApplicationIdentifier(id) || this$1.getApplicationIdentifier(id.substring(0, id.length - 1));
      if (applicationIdentifier) {
        return {
          id,
          ai: applicationIdentifier
        };
      }
    }
    this.unsupportedAIError(id);
  };
  States128FNC1.prototype.unsupportedAIError = function unsupportedAIError(id) {
    throw new Error("'" + id + "' is not a supported Application Identifier");
  };
  States128FNC1.prototype.getBySeparator = function getBySeparator(value2, index) {
    var start = value2.indexOf(this.startAI, index), end = value2.indexOf(this.endAI, start), id = value2.substring(start + 1, end), ai = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substr(id.length - 1));
    if (!ai) {
      this.unsupportedAIError(id);
    }
    return {
      ai,
      id
    };
  };
  States128FNC1.prototype.getApplicationIdentifier = function getApplicationIdentifier(id) {
    var applicationIdentifier = this.applicationIdentifiers, multiKey = applicationIdentifier.multiKey;
    if (applicationIdentifier[id]) {
      return applicationIdentifier[id];
    }
    for (var i36 = 0; i36 < multiKey.length; i36++) {
      if (multiKey[i36].ids && inArray(id, multiKey[i36].ids)) {
        return multiKey[i36].type;
      } else if (multiKey[i36].ranges) {
        var ranges = multiKey[i36].ranges;
        for (var j2 = 0; j2 < ranges.length; j2++) {
          if (ranges[j2][0] <= id && id <= ranges[j2][1]) {
            return multiKey[i36].type;
          }
        }
      }
    }
  };
  return States128FNC1;
}(State128);
var Code128Base = function(Encoding2) {
  function Code128Base2(options) {
    Encoding2.call(this, options);
    this._initStates();
  }
  if (Encoding2) Code128Base2.__proto__ = Encoding2;
  Code128Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code128Base2.prototype.constructor = Code128Base2;
  Code128Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend6(this, {
      characterMap: [
        212222,
        222122,
        222221,
        121223,
        121322,
        131222,
        122213,
        122312,
        132212,
        221213,
        221312,
        231212,
        112232,
        122132,
        122231,
        113222,
        123122,
        123221,
        223211,
        221132,
        221231,
        213212,
        223112,
        312131,
        311222,
        321122,
        321221,
        312212,
        322112,
        322211,
        212123,
        212321,
        232121,
        111323,
        131123,
        131321,
        112313,
        132113,
        132311,
        211313,
        231113,
        231311,
        112133,
        112331,
        132131,
        113123,
        113321,
        133121,
        313121,
        211331,
        231131,
        213113,
        213311,
        213131,
        311123,
        311321,
        331121,
        312113,
        312311,
        332111,
        314111,
        221411,
        431111,
        111224,
        111422,
        121124,
        121421,
        141122,
        141221,
        112214,
        112412,
        122114,
        122411,
        142112,
        142211,
        241211,
        221114,
        413111,
        241112,
        134111,
        111242,
        121142,
        121241,
        114212,
        124112,
        124211,
        411212,
        421112,
        421211,
        212141,
        214121,
        412121,
        111143,
        111341,
        131141,
        114113,
        114311,
        411113,
        411311,
        113141,
        114131,
        311141,
        411131,
        211412,
        211214,
        211232,
        2331112
      ],
      STOP: 106
    });
  };
  Code128Base2.prototype._initStates = function _initStates() {
    var this$1 = this;
    for (var i36 = 0; i36 < this.states.length; i36++) {
      this$1[this$1.states[i36]] = new states128[this$1.states[i36]](this$1, this$1.states);
    }
  };
  Code128Base2.prototype.initValue = function initValue(value2, width, height) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.height = height;
    this.checkSum = 0;
    this.totalUnits = 0;
    this.index = 0;
    this.position = 1;
  };
  Code128Base2.prototype.addData = function addData() {
    var encodingState = {
      value: this.value,
      index: 0,
      state: ""
    };
    if (this.value.length === 0) {
      return;
    }
    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);
    this.addStart(encodingState);
    this.pushData(encodingState, this.states);
    this.addCheckSum();
    this.addStop();
    this.setBaseUnit();
  };
  Code128Base2.prototype.pushData = function pushData(encodingState, states) {
    var this$1 = this;
    var trueCondition = true;
    while (trueCondition) {
      this$1[encodingState.state].pushState(encodingState);
      if (encodingState.index >= encodingState.value.length) {
        break;
      }
      if (!encodingState.shifted) {
        encodingState.previousState = encodingState.state;
        encodingState.state = this$1.getNextState(encodingState, states);
        this$1[encodingState.state].move(encodingState);
      } else {
        var temp = encodingState.state;
        encodingState.state = encodingState.previousState;
        encodingState.previousState = temp;
        encodingState.shifted = false;
      }
    }
  };
  Code128Base2.prototype.addStart = function addStart(encodingState) {
    this[encodingState.state].addStart(encodingState);
    this.position = 1;
  };
  Code128Base2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = this.checkSum % 103;
    this.addPattern(this.checksum);
  };
  Code128Base2.prototype.addStop = function addStop() {
    this.addPattern(this.STOP);
  };
  Code128Base2.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code128Base2.prototype.addPattern = function addPattern(code) {
    var this$1 = this;
    var pattern = this.characterMap[code].toString();
    var value2;
    for (var i36 = 0; i36 < pattern.length; i36++) {
      value2 = parseInt(pattern.charAt(i36), 10);
      this$1.pattern.push(value2);
      this$1.totalUnits += value2;
    }
    this.checkSum += code * this.position++;
  };
  Code128Base2.prototype.getNextState = function getNextState(encodingState, states) {
    var this$1 = this;
    for (var i36 = 0; i36 < states.length; i36++) {
      if (this$1[states[i36]].is(encodingState.value, encodingState.index)) {
        return states[i36];
      }
    }
    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));
  };
  return Code128Base2;
}(Encoding);
var Code128a = function(Code128Base2) {
  function Code128a2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code128a2.__proto__ = Code128Base2;
  Code128a2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128a2.prototype.constructor = Code128a2;
  Code128a2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128 A",
      states: ["A"]
    });
  };
  return Code128a2;
}(Code128Base);
var Code128b = function(Code128Base2) {
  function Code128b2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code128b2.__proto__ = Code128Base2;
  Code128b2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128b2.prototype.constructor = Code128b2;
  Code128b2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128 B",
      states: ["B"]
    });
  };
  return Code128b2;
}(Code128Base);
var Code128c = function(Code128Base2) {
  function Code128c2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code128c2.__proto__ = Code128Base2;
  Code128c2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128c2.prototype.constructor = Code128c2;
  Code128c2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128 C",
      states: ["C"]
    });
  };
  return Code128c2;
}(Code128Base);
var Code128 = function(Code128Base2) {
  function Code1282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code1282.__proto__ = Code128Base2;
  Code1282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code1282.prototype.constructor = Code1282;
  Code1282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128",
      states: ["C", "B", "A", "FNC4"]
    });
  };
  return Code1282;
}(Code128Base);
var CodeGS1128 = function(Code128Base2) {
  function CodeGS11282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) CodeGS11282.__proto__ = Code128Base2;
  CodeGS11282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  CodeGS11282.prototype.constructor = CodeGS11282;
  CodeGS11282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code GS1-128",
      states: ["FNC1", "C", "B"]
    });
  };
  return CodeGS11282;
}(Code128Base);
function getSubstring(value2, index, count) {
  return value2.substring(index, index + count);
}

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/msi.js
var extend7 = Object.assign;
var MsiBase = function(Encoding2) {
  function MsiBase2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) MsiBase2.__proto__ = Encoding2;
  MsiBase2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  MsiBase2.prototype.constructor = MsiBase2;
  MsiBase2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend7(this, {
      characterMap: [
        "12121212",
        "12121221",
        "12122112",
        "12122121",
        "12211212",
        "12211221",
        "12212112",
        "12212121",
        "21121212",
        "21121221"
      ],
      START: "21",
      STOP: "121",
      checkSumType: "",
      checkSums
    });
  };
  MsiBase2.prototype.initValue = function initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.checkSumLength = 0;
    this.width = width;
  };
  MsiBase2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 7;
    this.baseUnit = this.width / (12 * (this.value.length + this.checkSumLength) + this.quietZoneLength + startStopLength);
  };
  MsiBase2.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i36 = 0; i36 < value2.length; i36++) {
      this$1.addCharacter(value2.charAt(i36));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  MsiBase2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    if (!pattern) {
      this.invalidCharacterError(character);
    }
    this.addPattern(pattern);
  };
  MsiBase2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i36 = 0; i36 < pattern.length; i36++) {
      this$1.pattern.push(parseInt(pattern.charAt(i36), 10));
    }
  };
  MsiBase2.prototype.addCheckSum = function addCheckSum() {
    var this$1 = this;
    var checkSumFunction = this.checkSums[this.checkSumType];
    var checkValues = checkSumFunction.call(this.checkSums, this.value);
    this.checksum = checkValues.join("");
    for (var i36 = 0; i36 < checkValues.length; i36++) {
      this$1.checkSumLength++;
      this$1.addPattern(this$1.characterMap[checkValues[i36]]);
    }
  };
  return MsiBase2;
}(Encoding);
var MsiMod10 = function(MsiBase2) {
  function MsiMod102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod102.__proto__ = MsiBase2;
  MsiMod102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod102.prototype.constructor = MsiMod102;
  MsiMod102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo10",
      checkSumType: "Modulo10"
    });
  };
  return MsiMod102;
}(MsiBase);
var MsiMod11 = function(MsiBase2) {
  function MsiMod112() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod112.__proto__ = MsiBase2;
  MsiMod112.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod112.prototype.constructor = MsiMod112;
  MsiMod112.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo11",
      checkSumType: "Modulo11"
    });
  };
  return MsiMod112;
}(MsiBase);
var MsiMod1010 = function(MsiBase2) {
  function MsiMod10102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod10102.__proto__ = MsiBase2;
  MsiMod10102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod10102.prototype.constructor = MsiMod10102;
  MsiMod10102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo10 Modulo10",
      checkSumType: "Modulo10Modulo10"
    });
  };
  return MsiMod10102;
}(MsiBase);
var MsiMod1110 = function(MsiBase2) {
  function MsiMod11102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod11102.__proto__ = MsiBase2;
  MsiMod11102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod11102.prototype.constructor = MsiMod11102;
  MsiMod11102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo11 Modulo10",
      checkSumType: "Modulo11Modulo10"
    });
  };
  return MsiMod11102;
}(MsiBase);
var checkSums = {
  Modulo10: function Modulo10(value2) {
    var checkValues = [0, ""], odd = value2.length % 2, idx, evenSum, oddSum;
    for (idx = 0; idx < value2.length; idx++) {
      checkValues[(idx + odd) % 2] += parseInt(value2.charAt(idx), 10);
    }
    oddSum = checkValues[0];
    evenSum = (checkValues[1] * 2).toString();
    for (idx = 0; idx < evenSum.length; idx++) {
      oddSum += parseInt(evenSum.charAt(idx), 10);
    }
    return [(10 - oddSum % 10) % 10];
  },
  Modulo11: function Modulo11(value2) {
    var weightedSum = 0, mod = 11, length = value2.length, weight, checkValue;
    for (var i36 = 0; i36 < length; i36++) {
      weight = ((length - i36) % 6 || 6) + 1;
      weightedSum += weight * value2.charAt(i36);
    }
    checkValue = (mod - weightedSum % mod) % mod;
    if (checkValue !== 10) {
      return [checkValue];
    }
    return [1, 0];
  },
  Modulo11Modulo10: function Modulo11Modulo10(value2) {
    var checkValues = this.Modulo11(value2), mod11Value;
    mod11Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod11Value));
  },
  Modulo10Modulo10: function Modulo10Modulo10(value2) {
    var checkValues = this.Modulo10(value2), mod10Value;
    mod10Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod10Value));
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean13.js
var extend8 = Object.assign;
var Ean13 = function(Encoding2) {
  function Ean132() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Ean132.__proto__ = Encoding2;
  Ean132.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Ean132.prototype.constructor = Ean132;
  Ean132.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend8(this, {
      name: "EAN 13",
      keyTable: [
        "000000",
        "001011",
        "001101",
        "001110",
        "010011",
        "011001",
        "011100",
        "010101",
        "010110",
        "011010"
      ],
      characterMap: {
        digits: [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2]
        ],
        start: [1, 1, 1],
        middle: [1, 1, 1, 1, 1]
      }
    });
  };
  Ean132.prototype.initValue = function initValue(value2, width, height) {
    var valueAsString = String(value2);
    if (valueAsString.length !== 12 || /\D/.test(valueAsString)) {
      throw new Error('The value of the "EAN13" encoding should be 12 symbols');
    }
    this.pattern = [];
    this.options.height = height;
    this.baseUnit = width / (95 + this.quietZoneLength);
    this.value = valueAsString;
    this.checksum = this.calculateChecksum();
    this.leftKey = valueAsString[0];
    this.leftPart = valueAsString.substr(1, 6);
    this.rightPart = valueAsString.substr(7) + this.checksum;
  };
  Ean132.prototype.addData = function addData() {
    this.addPieces(this.characterMap.start);
    this.addSide(this.leftPart, this.leftKey);
    this.addPieces(this.characterMap.middle);
    this.addSide(this.rightPart);
    this.addPieces(this.characterMap.start);
  };
  Ean132.prototype.addSide = function addSide(leftPart, key) {
    var this$1 = this;
    for (var i36 = 0; i36 < leftPart.length; i36++) {
      if (key && parseInt(this$1.keyTable[key].charAt(i36), 10)) {
        this$1.addPieces(Array.prototype.slice.call(this$1.characterMap.digits[leftPart.charAt(i36)]).reverse(), true);
      } else {
        this$1.addPieces(this$1.characterMap.digits[leftPart.charAt(i36)], true);
      }
    }
  };
  Ean132.prototype.addPieces = function addPieces(arrToAdd, limitedHeight) {
    var this$1 = this;
    for (var i36 = 0; i36 < arrToAdd.length; i36++) {
      if (limitedHeight) {
        this$1.pattern.push({
          y1: 0,
          y2: this$1.options.height * 0.95,
          width: arrToAdd[i36]
        });
      } else {
        this$1.pattern.push(arrToAdd[i36]);
      }
    }
  };
  Ean132.prototype.calculateChecksum = function calculateChecksum() {
    var odd = 0, even = 0, value2 = this.value.split("").reverse().join("");
    for (var i36 = 0; i36 < value2.length; i36++) {
      if (i36 % 2) {
        even += parseInt(value2.charAt(i36), 10);
      } else {
        odd += parseInt(value2.charAt(i36), 10);
      }
    }
    var checksum = (10 - (3 * odd + even) % 10) % 10;
    return checksum;
  };
  return Ean132;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean8.js
var extend9 = Object.assign;
var Ean8 = function(Ean132) {
  function Ean82() {
    Ean132.apply(this, arguments);
  }
  if (Ean132) Ean82.__proto__ = Ean132;
  Ean82.prototype = Object.create(Ean132 && Ean132.prototype);
  Ean82.prototype.constructor = Ean82;
  Ean82.prototype.initProperties = function initProperties() {
    Ean132.prototype.initProperties.call(this);
    extend9(this, {
      name: "EAN 8"
    });
  };
  Ean82.prototype.initValue = function initValue(value2, width, height) {
    if (value2.length !== 7 || /\D/.test(value2)) {
      throw new Error("Invalid value provided");
    }
    this.value = value2;
    this.options.height = height;
    this.checksum = this.calculateChecksum(this.value);
    this.leftPart = this.value.substr(0, 4);
    this.rightPart = this.value.substr(4) + this.checksum;
    this.pattern = [];
    this.baseUnit = width / (67 + this.quietZoneLength);
  };
  return Ean82;
}(Ean13);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/main.js
var Encodings = {
  code11: Code11,
  code39: Code39,
  code39extended: Code39Extended,
  code93: Code93,
  code93extended: Code93Extended,
  code128: Code128,
  code128a: Code128a,
  code128b: Code128b,
  code128c: Code128c
};
Encodings["gs1-128"] = CodeGS1128;
Encodings.msimod10 = MsiMod10;
Encodings.msimod11 = MsiMod11;
Encodings.msimod1010 = MsiMod1010;
Encodings.msimod1110 = MsiMod1110;
Encodings.postnet = Postnet;
Encodings.ean8 = Ean8;
Encodings.ean13 = Ean13;

// node_modules/@progress/kendo-charts/dist/es/barcode/surface-size.js
function surfaceSize(element, surfaceType) {
  var display = element.style.display;
  if (surfaceType === "canvas") {
    element.style.display = "block";
  }
  var size = {
    width: element.clientWidth,
    height: element.clientHeight
  };
  element.style.display = display;
  return size;
}

// node_modules/@progress/kendo-charts/dist/es/barcode/barcode.js
var DEFAULT_BARCODE_WIDTH = 300;
var DEFAULT_BARCODE_HEIGHT = 100;
var Barcode = function(Class) {
  function Barcode2(element, options, errorHandler) {
    if (errorHandler === void 0) errorHandler = defaultErrorHandler;
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this._setOptions(options);
    if (options && defined(options.value)) {
      this.redraw();
    }
  }
  if (Class) Barcode2.__proto__ = Class;
  Barcode2.prototype = Object.create(Class && Class.prototype);
  Barcode2.prototype.constructor = Barcode2;
  Barcode2.prototype.destroy = function destroy() {
    this._destroySurface();
  };
  Barcode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-barcode");
  };
  Barcode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Barcode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  Barcode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Barcode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  Barcode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Barcode2.prototype.setOptions = function setOptions(options) {
    this._setOptions(options);
    this._initSurface();
    this.redraw();
  };
  Barcode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size.width,
      height: size.height
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Barcode2.prototype.getSize = function getSize() {
    return {
      width: this.element.offsetWidth,
      height: this.element.offsetHeight
    };
  };
  Barcode2.prototype._resize = function _resize() {
    this.redraw();
  };
  Barcode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Barcode2.prototype._render = function _render() {
    var options = this.options;
    var value2 = options.value;
    var textOptions = options.text;
    var textMargin = getSpacing(textOptions.margin);
    var size = this._getSize();
    var border = options.border || {};
    var encoding = this.encoding;
    var contentBox = new box_default(0, 0, size.width, size.height).unpad(border.width).unpad(options.padding);
    var barHeight = contentBox.height();
    var encodedValue;
    var textToDisplay;
    var textHeight;
    var visual = new drawing_exports.Group();
    this.contentBox = contentBox;
    visual.append(this._getBackground(size));
    if (textOptions.visible) {
      textHeight = drawing_exports.util.measureText(value2, { font: textOptions.font }).height;
      barHeight -= textHeight + textMargin.top + textMargin.bottom;
    }
    try {
      encodedValue = encoding.encode(value2, contentBox.width(), barHeight);
    } catch (error) {
      this.onError(error);
      return visual;
    }
    if (textOptions.visible) {
      textToDisplay = value2;
      if (options.checksum && defined(encoding.checksum)) {
        textToDisplay += " " + encoding.checksum;
      }
      visual.append(this._getText(textToDisplay));
    }
    this.barHeight = barHeight;
    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);
    visual.append(this._bandsGroup);
    return visual;
  };
  Barcode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  Barcode2.prototype._getSize = function _getSize() {
    var element = this.element;
    var elementSize2 = surfaceSize(element, this.options.renderAs);
    var size = new geometry_exports.Size(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);
    if (elementSize2.width > 0) {
      size.width = elementSize2.width;
    }
    if (elementSize2.height > 0) {
      size.height = elementSize2.height;
    }
    if (this.options.width) {
      size.width = this.options.width;
    }
    if (this.options.height) {
      size.height = this.options.height;
    }
    return size;
  };
  Barcode2.prototype.value = function value2(value$1) {
    if (!defined(value$1)) {
      return this.options.value;
    }
    this.options.value = String(value$1);
    this.redraw();
  };
  Barcode2.prototype._getBands = function _getBands(pattern, baseUnit) {
    var this$1 = this;
    var contentBox = this.contentBox;
    var offsetX = contentBox.x1;
    var stepX;
    var patternItem;
    var group = new drawing_exports.Group();
    for (var i36 = 0; i36 < pattern.length; i36++) {
      patternItem = isObject(pattern[i36]) ? pattern[i36] : {
        width: pattern[i36],
        y1: 0,
        y2: this$1.barHeight
      };
      stepX = patternItem.width * baseUnit;
      if (i36 % 2) {
        var rect = geometry_exports.Rect.fromPoints(
          new geometry_exports.Point(offsetX, patternItem.y1 + contentBox.y1),
          new geometry_exports.Point(offsetX + stepX, patternItem.y2 + contentBox.y1)
        );
        var path = drawing_exports.Path.fromRect(rect, {
          fill: {
            color: this$1.options.color
          },
          stroke: null
        });
        group.append(path);
      }
      offsetX += stepX;
    }
    return group;
  };
  Barcode2.prototype._getBackground = function _getBackground(size) {
    var options = this.options;
    var border = options.border || {};
    var box = new box_default(0, 0, size.width, size.height).unpad(border.width / 2);
    var path = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: options.background
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
    return path;
  };
  Barcode2.prototype._getText = function _getText(value2) {
    var textOptions = this.options.text;
    var text = this._textbox = new text_box_default(value2, {
      font: textOptions.font,
      color: textOptions.color,
      align: "center",
      vAlign: "bottom",
      margin: textOptions.margin
    });
    text.reflow(this.contentBox);
    text.renderVisual();
    return text.visual;
  };
  Barcode2.prototype._setOptions = function _setOptions(options) {
    this.type = (options.type || this.options.type).toLowerCase();
    if (this.type === "upca") {
      this.type = "ean13";
      options.value = "0" + options.value;
    }
    if (this.type === "upce") {
      this.type = "ean8";
      options.value = "0" + options.value;
    }
    if (!Encodings[this.type]) {
      throw new Error("Encoding '" + this.type + "' is not supported.");
    }
    this.encoding = new Encodings[this.type]();
    this.options = deepExtend({}, this.options, options);
  };
  return Barcode2;
}(class_default);
setDefaultOptions(Barcode, {
  name: "Barcode",
  renderAs: "svg",
  value: "",
  type: "code39",
  checksum: false,
  width: 0,
  height: 0,
  color: "black",
  background: "white",
  text: {
    visible: true,
    font: "16px Consolas, Monaco, Sans Mono, monospace, sans-serif",
    color: "black",
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  },
  border: {
    width: 0,
    dashType: "solid",
    color: "black"
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/qrcode/utils.js
var extend10 = Object.assign;
function splitInto(str, chunkLength) {
  var result = [];
  var idx = 0;
  while (idx < str.length) {
    result.push(str.substring(idx, idx + chunkLength));
    idx += chunkLength;
  }
  return result;
}
function toBitsString(value2, length) {
  var bitString = Number(value2).toString(2);
  if (bitString.length < length) {
    bitString = new Array(length - bitString.length + 1).join(0) + bitString;
  }
  return bitString;
}
function toDecimal(value2) {
  return parseInt(value2, 2);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/free-cell-visitor.js
var FreeCellVisitor = function(Class) {
  function FreeCellVisitor2(matrix) {
    Class.call(this);
    this.matrix = matrix;
    this.row = matrix.length - 1;
    this.column = matrix.length - 1;
    this.startColumn = this.column;
    this.dir = -1;
    this.c = 0;
  }
  if (Class) FreeCellVisitor2.__proto__ = Class;
  FreeCellVisitor2.prototype = Object.create(Class && Class.prototype);
  FreeCellVisitor2.prototype.constructor = FreeCellVisitor2;
  FreeCellVisitor2.prototype.move = function move() {
    this.row += this.dir * this.c;
    this.c ^= 1;
    this.column = this.startColumn - this.c;
  };
  FreeCellVisitor2.prototype.getNextCell = function getNextCell() {
    var this$1 = this;
    while (this.matrix[this.row][this.column] !== void 0) {
      this$1.move();
      if (this$1.row < 0 || this$1.row >= this$1.matrix.length) {
        this$1.dir = -this$1.dir;
        this$1.startColumn -= this$1.startColumn !== 8 ? 2 : 3;
        this$1.column = this$1.startColumn;
        this$1.row = this$1.dir < 0 ? this$1.matrix.length - 1 : 0;
      }
    }
    return {
      row: this.row,
      column: this.column
    };
  };
  FreeCellVisitor2.prototype.getNextRemainderCell = function getNextRemainderCell() {
    this.move();
    if (this.matrix[this.row][this.column] === void 0) {
      return {
        row: this.row,
        column: this.column
      };
    }
  };
  return FreeCellVisitor2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding-result.js
var EncodingResult = function(Class) {
  function EncodingResult2(dataString, version) {
    Class.call(this);
    this.dataString = dataString;
    this.version = version;
  }
  if (Class) EncodingResult2.__proto__ = Class;
  EncodingResult2.prototype = Object.create(Class && Class.prototype);
  EncodingResult2.prototype.constructor = EncodingResult2;
  return EncodingResult2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/iso-encoder.js
var IsoEncoder = function(Class) {
  function IsoEncoder2() {
    Class.apply(this, arguments);
  }
  if (Class) IsoEncoder2.__proto__ = Class;
  IsoEncoder2.prototype = Object.create(Class && Class.prototype);
  IsoEncoder2.prototype.constructor = IsoEncoder2;
  IsoEncoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var modes = getModes(inputString), dataCodewordsCount = getDataCodewordsCount(modes), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = getDataString(modes, version);
    return new EncodingResult(dataString, version);
  };
  return IsoEncoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/qr-data-mode.js
var QRDataMode = function(Class) {
  function QRDataMode2() {
    Class.call(this);
    this.initProperties();
  }
  if (Class) QRDataMode2.__proto__ = Class;
  QRDataMode2.prototype = Object.create(Class && Class.prototype);
  QRDataMode2.prototype.constructor = QRDataMode2;
  QRDataMode2.prototype.initProperties = function initProperties() {
    extend10(this, {
      modeIndicator: "",
      bitsInCharacterCount: []
    });
  };
  QRDataMode2.prototype.getVersionIndex = function getVersionIndex(version) {
    if (version < 10) {
      return 0;
    } else if (version > 26) {
      return 2;
    }
    return 1;
  };
  QRDataMode2.prototype.getBitsCharacterCount = function getBitsCharacterCount(version) {
    return this.bitsInCharacterCount[this.getVersionIndex(version || 40)];
  };
  QRDataMode2.prototype.getModeCountString = function getModeCountString(length, version) {
    return this.modeIndicator + toBitsString(length, this.getBitsCharacterCount(version));
  };
  QRDataMode2.prototype.encode = function encode() {
  };
  QRDataMode2.prototype.getStringBitsLength = function getStringBitsLength() {
  };
  QRDataMode2.prototype.getValue = function getValue() {
  };
  return QRDataMode2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/numeric-data-mode.js
var NumericQRDataMode = function(QRDataMode2) {
  function NumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2) NumericQRDataMode2.__proto__ = QRDataMode2;
  NumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  NumericQRDataMode2.prototype.constructor = NumericQRDataMode2;
  NumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend10(this, {
      bitsInCharacterCount: [10, 12, 14],
      modeIndicator: "0001"
    });
  };
  NumericQRDataMode2.prototype.getValue = function getValue(character) {
    return parseInt(character, 10);
  };
  NumericQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, parts = splitInto(str, 3), result = mode.getModeCountString(str.length, version);
    var i36;
    for (i36 = 0; i36 < parts.length - 1; i36++) {
      result += toBitsString(parts[i36], 10);
    }
    return result + toBitsString(parts[i36], 1 + 3 * parts[i36].length);
  };
  NumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    var mod3 = inputLength % 3;
    return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);
  };
  return NumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/alpha-numeric-data-mode.js
var AlphaNumericQRDataMode = function(QRDataMode2) {
  function AlphaNumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2) AlphaNumericQRDataMode2.__proto__ = QRDataMode2;
  AlphaNumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  AlphaNumericQRDataMode2.prototype.constructor = AlphaNumericQRDataMode2;
  AlphaNumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend10(this, {
      characters: {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15,
        "G": 16,
        "H": 17,
        "I": 18,
        "J": 19,
        "K": 20,
        "L": 21,
        "M": 22,
        "N": 23,
        "O": 24,
        "P": 25,
        "Q": 26,
        "R": 27,
        "S": 28,
        "T": 29,
        "U": 30,
        "V": 31,
        "W": 32,
        "X": 33,
        "Y": 34,
        "Z": 35,
        " ": 36,
        "$": 37,
        "%": 38,
        "*": 39,
        "+": 40,
        "-": 41,
        ".": 42,
        "/": 43,
        ":": 44
      },
      bitsInCharacterCount: [9, 11, 13],
      modeIndicator: "0010"
    });
  };
  AlphaNumericQRDataMode2.prototype.getValue = function getValue(character) {
    return this.characters[character];
  };
  AlphaNumericQRDataMode2.prototype.encode = function encode(str, version) {
    var this$1 = this;
    var parts = splitInto(str, 2), result = this.getModeCountString(str.length, version), value2;
    var i36;
    for (i36 = 0; i36 < parts.length - 1; i36++) {
      value2 = 45 * this$1.getValue(parts[i36].charAt(0)) + this$1.getValue(parts[i36].charAt(1));
      result += toBitsString(value2, 11);
    }
    value2 = parts[i36].length === 2 ? 45 * this.getValue(parts[i36].charAt(0)) + this.getValue(parts[i36].charAt(1)) : this.getValue(parts[i36].charAt(0));
    return result + toBitsString(value2, 1 + 5 * parts[i36].length);
  };
  AlphaNumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);
  };
  return AlphaNumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/byte-data-mode.js
var ByteQRDataMode = function(QRDataMode2) {
  function ByteQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2) ByteQRDataMode2.__proto__ = QRDataMode2;
  ByteQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  ByteQRDataMode2.prototype.constructor = ByteQRDataMode2;
  ByteQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend10(this, {
      bitsInCharacterCount: [8, 16, 16],
      modeIndicator: "0100"
    });
  };
  ByteQRDataMode2.prototype.getValue = function getValue(character) {
    var code = character.charCodeAt(0);
    if (code <= 127 || 160 <= code && code <= 255) {
      return code;
    }
    throw new Error('Unsupported character in QR Code: "' + character + '".');
  };
  ByteQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, result = mode.getModeCountString(str.length, version);
    for (var i36 = 0; i36 < str.length; i36++) {
      result += toBitsString(mode.getValue(str.charAt(i36)), 8);
    }
    return result;
  };
  ByteQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;
  };
  return ByteQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/data-mode-instances.js
var NUMERIC = "numeric";
var ALPHA_NUMERIC = "alphanumeric";
var BYTE = "byte";
var DataModeInstances = {};
DataModeInstances[NUMERIC] = new NumericQRDataMode();
DataModeInstances[ALPHA_NUMERIC] = new AlphaNumericQRDataMode();
DataModeInstances[BYTE] = new ByteQRDataMode();

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/utf8-encoder.js
var BYTE2 = "byte";
var Utf8Encoder = function(Class) {
  function Utf8Encoder2() {
    Class.call(this);
    this.initProperties();
    this.mode = DataModeInstances[this.encodingMode];
  }
  if (Class) Utf8Encoder2.__proto__ = Class;
  Utf8Encoder2.prototype = Object.create(Class && Class.prototype);
  Utf8Encoder2.prototype.constructor = Utf8Encoder2;
  Utf8Encoder2.prototype.initProperties = function initProperties() {
    extend10(this, {
      encodingMode: BYTE2,
      utfBOM: "111011111011101110111111",
      initialModeCountStringLength: 20,
      ranges: [128, 2048, 65536, 2097152, 67108864]
    });
  };
  Utf8Encoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var data = this.encode(inputString), dataCodewordsCount = this.getDataCodewordsCount(data), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = this.mode.getModeCountString(data.length / 8, version) + data;
    return new EncodingResult(dataString, version);
  };
  Utf8Encoder2.prototype.getDataCodewordsCount = function getDataCodewordsCount2(data) {
    var dataLength = data.length, dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);
    return dataCodewordsCount;
  };
  Utf8Encoder2.prototype.encode = function encode(str) {
    var this$1 = this;
    var result = this.utfBOM;
    for (var i36 = 0; i36 < str.length; i36++) {
      result += this$1.encodeCharacter(str.charCodeAt(i36));
    }
    return result;
  };
  Utf8Encoder2.prototype.encodeCharacter = function encodeCharacter(code) {
    var bytesCount = this.getBytesCount(code), bc = bytesCount - 1, result = "";
    if (bytesCount === 1) {
      result = toBitsString(code, 8);
    } else {
      var significantOnes = 8 - bytesCount;
      for (var i36 = 0; i36 < bc; i36++) {
        result = toBitsString(code >> i36 * 6 & 63 | 128, 8) + result;
      }
      result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;
    }
    return result;
  };
  Utf8Encoder2.prototype.getBytesCount = function getBytesCount(code) {
    var ranges = this.ranges;
    for (var i36 = 0; i36 < ranges.length; i36++) {
      if (code < ranges[i36]) {
        return i36 + 1;
      }
    }
  };
  return Utf8Encoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/version-codewords.js
var VersionsCodewordsInformation = [{
  L: {
    groups: [
      [1, 19]
    ],
    totalDataCodewords: 19,
    errorCodewordsPerBlock: 7
  },
  M: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 10
  },
  Q: {
    groups: [
      [1, 13]
    ],
    totalDataCodewords: 13,
    errorCodewordsPerBlock: 13
  },
  H: {
    groups: [
      [1, 9]
    ],
    totalDataCodewords: 9,
    errorCodewordsPerBlock: 17
  }
}, {
  L: {
    groups: [
      [1, 34]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 10
  },
  M: {
    groups: [
      [1, 28]
    ],
    totalDataCodewords: 28,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [1, 22]
    ],
    totalDataCodewords: 22,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [1, 55]
    ],
    totalDataCodewords: 55,
    errorCodewordsPerBlock: 15
  },
  M: {
    groups: [
      [1, 44]
    ],
    totalDataCodewords: 44,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [2, 17]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 13]
    ],
    totalDataCodewords: 26,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [1, 80]
    ],
    totalDataCodewords: 80,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [2, 32]
    ],
    totalDataCodewords: 64,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 24]
    ],
    totalDataCodewords: 48,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [4, 9]
    ],
    totalDataCodewords: 36,
    errorCodewordsPerBlock: 16
  }
}, {
  L: {
    groups: [
      [1, 108]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [2, 43]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [2, 15],
      [2, 16]
    ],
    totalDataCodewords: 62,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 11],
      [2, 12]
    ],
    totalDataCodewords: 46,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [2, 68]
    ],
    totalDataCodewords: 136,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 27]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [4, 19]
    ],
    totalDataCodewords: 76,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [4, 15]
    ],
    totalDataCodewords: 60,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [2, 78]
    ],
    totalDataCodewords: 156,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [4, 31]
    ],
    totalDataCodewords: 124,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 14],
      [4, 15]
    ],
    totalDataCodewords: 88,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [4, 13],
      [1, 14]
    ],
    totalDataCodewords: 66,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 97]
    ],
    totalDataCodewords: 194,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [2, 38],
      [2, 39]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 18],
      [2, 19]
    ],
    totalDataCodewords: 110,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [4, 14],
      [2, 15]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 116]
    ],
    totalDataCodewords: 232,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 36],
      [2, 37]
    ],
    totalDataCodewords: 182,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 16],
      [4, 17]
    ],
    totalDataCodewords: 132,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [4, 12],
      [4, 13]
    ],
    totalDataCodewords: 100,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 68],
      [2, 69]
    ],
    totalDataCodewords: 274,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 43],
      [1, 44]
    ],
    totalDataCodewords: 216,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [6, 19],
      [2, 20]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [6, 15],
      [2, 16]
    ],
    totalDataCodewords: 122,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 81]
    ],
    totalDataCodewords: 324,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [1, 50],
      [4, 51]
    ],
    totalDataCodewords: 254,
    errorCodewordsPerBlock: 30
  },
  Q: {
    groups: [
      [4, 22],
      [4, 23]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [3, 12],
      [8, 13]
    ],
    totalDataCodewords: 140,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 92],
      [2, 93]
    ],
    totalDataCodewords: 370,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [6, 36],
      [2, 37]
    ],
    totalDataCodewords: 290,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 20],
      [6, 21]
    ],
    totalDataCodewords: 206,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [7, 14],
      [4, 15]
    ],
    totalDataCodewords: 158,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 107]
    ],
    totalDataCodewords: 428,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 37],
      [1, 38]
    ],
    totalDataCodewords: 334,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [8, 20],
      [4, 21]
    ],
    totalDataCodewords: 244,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [12, 11],
      [4, 12]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [3, 115],
      [1, 116]
    ],
    totalDataCodewords: 461,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 40],
      [5, 41]
    ],
    totalDataCodewords: 365,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [11, 16],
      [5, 17]
    ],
    totalDataCodewords: 261,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [11, 12],
      [5, 13]
    ],
    totalDataCodewords: 197,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 87],
      [1, 88]
    ],
    totalDataCodewords: 523,
    errorCodewordsPerBlock: 22
  },
  M: {
    groups: [
      [5, 41],
      [5, 42]
    ],
    totalDataCodewords: 415,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [5, 24],
      [7, 25]
    ],
    totalDataCodewords: 295,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 12],
      [7, 13]
    ],
    totalDataCodewords: 223,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 98],
      [1, 99]
    ],
    totalDataCodewords: 589,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [7, 45],
      [3, 46]
    ],
    totalDataCodewords: 453,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 19],
      [2, 20]
    ],
    totalDataCodewords: 325,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [3, 15],
      [13, 16]
    ],
    totalDataCodewords: 253,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [1, 107],
      [5, 108]
    ],
    totalDataCodewords: 647,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [10, 46],
      [1, 47]
    ],
    totalDataCodewords: 507,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 22],
      [15, 23]
    ],
    totalDataCodewords: 367,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [17, 15]
    ],
    totalDataCodewords: 283,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [5, 120],
      [1, 121]
    ],
    totalDataCodewords: 721,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [9, 43],
      [4, 44]
    ],
    totalDataCodewords: 563,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [1, 23]
    ],
    totalDataCodewords: 397,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [19, 15]
    ],
    totalDataCodewords: 313,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [3, 113],
      [4, 114]
    ],
    totalDataCodewords: 795,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 44],
      [11, 45]
    ],
    totalDataCodewords: 627,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 21],
      [4, 22]
    ],
    totalDataCodewords: 445,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [9, 13],
      [16, 14]
    ],
    totalDataCodewords: 341,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [3, 107],
      [5, 108]
    ],
    totalDataCodewords: 861,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 41],
      [13, 42]
    ],
    totalDataCodewords: 669,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [15, 24],
      [5, 25]
    ],
    totalDataCodewords: 485,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [15, 15],
      [10, 16]
    ],
    totalDataCodewords: 385,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 116],
      [4, 117]
    ],
    totalDataCodewords: 932,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 42]
    ],
    totalDataCodewords: 714,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [6, 23]
    ],
    totalDataCodewords: 512,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [19, 16],
      [6, 17]
    ],
    totalDataCodewords: 406,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [2, 111],
      [7, 112]
    ],
    totalDataCodewords: 1006,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 46]
    ],
    totalDataCodewords: 782,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [16, 25]
    ],
    totalDataCodewords: 568,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [34, 13]
    ],
    totalDataCodewords: 442,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [4, 121],
      [5, 122]
    ],
    totalDataCodewords: 1094,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 47],
      [14, 48]
    ],
    totalDataCodewords: 860,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [14, 25]
    ],
    totalDataCodewords: 614,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [16, 15],
      [14, 16]
    ],
    totalDataCodewords: 464,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 117],
      [4, 118]
    ],
    totalDataCodewords: 1174,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 45],
      [14, 46]
    ],
    totalDataCodewords: 914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [16, 25]
    ],
    totalDataCodewords: 664,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [30, 16],
      [2, 17]
    ],
    totalDataCodewords: 514,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 106],
      [4, 107]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 47],
      [13, 48]
    ],
    totalDataCodewords: 1e3,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [22, 25]
    ],
    totalDataCodewords: 718,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [13, 16]
    ],
    totalDataCodewords: 538,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [10, 114],
      [2, 115]
    ],
    totalDataCodewords: 1370,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [19, 46],
      [4, 47]
    ],
    totalDataCodewords: 1062,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [28, 22],
      [6, 23]
    ],
    totalDataCodewords: 754,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [33, 16],
      [4, 17]
    ],
    totalDataCodewords: 596,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 122],
      [4, 123]
    ],
    totalDataCodewords: 1468,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [22, 45],
      [3, 46]
    ],
    totalDataCodewords: 1128,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [8, 23],
      [26, 24]
    ],
    totalDataCodewords: 808,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [12, 15],
      [28, 16]
    ],
    totalDataCodewords: 628,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [3, 117],
      [10, 118]
    ],
    totalDataCodewords: 1531,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 45],
      [23, 46]
    ],
    totalDataCodewords: 1193,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [4, 24],
      [31, 25]
    ],
    totalDataCodewords: 871,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [31, 16]
    ],
    totalDataCodewords: 661,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [7, 116],
      [7, 117]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [21, 45],
      [7, 46]
    ],
    totalDataCodewords: 1267,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 23],
      [37, 24]
    ],
    totalDataCodewords: 911,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [26, 16]
    ],
    totalDataCodewords: 701,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [5, 115],
      [10, 116]
    ],
    totalDataCodewords: 1735,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [19, 47],
      [10, 48]
    ],
    totalDataCodewords: 1373,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 24],
      [25, 25]
    ],
    totalDataCodewords: 985,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [25, 16]
    ],
    totalDataCodewords: 745,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [3, 116]
    ],
    totalDataCodewords: 1843,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [2, 46],
      [29, 47]
    ],
    totalDataCodewords: 1455,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [42, 24],
      [1, 25]
    ],
    totalDataCodewords: 1033,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [28, 16]
    ],
    totalDataCodewords: 793,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115]
    ],
    totalDataCodewords: 1955,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [10, 46],
      [23, 47]
    ],
    totalDataCodewords: 1541,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [10, 24],
      [35, 25]
    ],
    totalDataCodewords: 1115,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [35, 16]
    ],
    totalDataCodewords: 845,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115],
      [1, 116]
    ],
    totalDataCodewords: 2071,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [21, 47]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [29, 24],
      [19, 25]
    ],
    totalDataCodewords: 1171,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [46, 16]
    ],
    totalDataCodewords: 901,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [6, 116]
    ],
    totalDataCodewords: 2191,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [23, 47]
    ],
    totalDataCodewords: 1725,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [44, 24],
      [7, 25]
    ],
    totalDataCodewords: 1231,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [59, 16],
      [1, 17]
    ],
    totalDataCodewords: 961,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [12, 121],
      [7, 122]
    ],
    totalDataCodewords: 2306,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [12, 47],
      [26, 48]
    ],
    totalDataCodewords: 1812,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [39, 24],
      [14, 25]
    ],
    totalDataCodewords: 1286,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [41, 16]
    ],
    totalDataCodewords: 986,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 121],
      [14, 122]
    ],
    totalDataCodewords: 2434,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 47],
      [34, 48]
    ],
    totalDataCodewords: 1914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [46, 24],
      [10, 25]
    ],
    totalDataCodewords: 1354,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [2, 15],
      [64, 16]
    ],
    totalDataCodewords: 1054,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 122],
      [4, 123]
    ],
    totalDataCodewords: 2566,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [29, 46],
      [14, 47]
    ],
    totalDataCodewords: 1992,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [49, 24],
      [10, 25]
    ],
    totalDataCodewords: 1426,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [24, 15],
      [46, 16]
    ],
    totalDataCodewords: 1096,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [4, 122],
      [18, 123]
    ],
    totalDataCodewords: 2702,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [13, 46],
      [32, 47]
    ],
    totalDataCodewords: 2102,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [48, 24],
      [14, 25]
    ],
    totalDataCodewords: 1502,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [42, 15],
      [32, 16]
    ],
    totalDataCodewords: 1142,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [20, 117],
      [4, 118]
    ],
    totalDataCodewords: 2812,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [40, 47],
      [7, 48]
    ],
    totalDataCodewords: 2216,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [43, 24],
      [22, 25]
    ],
    totalDataCodewords: 1582,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [10, 15],
      [67, 16]
    ],
    totalDataCodewords: 1222,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [19, 118],
      [6, 119]
    ],
    totalDataCodewords: 2956,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [18, 47],
      [31, 48]
    ],
    totalDataCodewords: 2334,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [34, 24],
      [34, 25]
    ],
    totalDataCodewords: 1666,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [20, 15],
      [61, 16]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 30
  }
}];

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js
var terminator = "0000";
var NUMERIC2 = "numeric";
var ALPHA_NUMERIC2 = "alphanumeric";
var BYTE3 = "byte";
var powersOfTwo = { "1": 0 };
var powersOfTwoResult = { "0": 1 };
var irregularAlignmentPatternsStartDistance = {
  15: 20,
  16: 20,
  18: 24,
  19: 24,
  22: 20,
  24: 22,
  26: 24,
  28: 20,
  30: 20,
  31: 24,
  32: 28,
  33: 24,
  36: 18,
  37: 22,
  39: 20,
  40: 24
};
var finderPattern = [1, 0, 1, 1, 1];
var alignmentPattern = [1, 0, 1];
var errorCorrectionPatterns = { L: "01", M: "00", Q: "11", H: "10" };
var formatMaskPattern = "101010000010010";
var formatGeneratorPolynomial = "10100110111";
var versionGeneratorPolynomial = "1111100100101";
var paddingCodewords = ["11101100", "00010001"];
var finderPatternValue = 93;
var maskPatternConditions = [
  function(row, column) {
    return (row + column) % 2 === 0;
  },
  function(row, column) {
    return row % 2 === 0;
  },
  function(row, column) {
    return column % 3 === 0;
  },
  function(row, column) {
    return (row + column) % 3 === 0;
  },
  function(row, column) {
    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;
  },
  function(row, column) {
    return row * column % 2 + row * column % 3 === 0;
  },
  function(row, column) {
    return (row * column % 2 + row * column % 3) % 2 === 0;
  },
  function(row, column) {
    return ((row + column) % 2 + row * column % 3) % 2 === 0;
  }
];
var numberRegex3 = /^\d+/;
var alphaPattern = "A-Z0-9 $%*+./:-";
var alphaExclusiveSet = "A-Z $%*+./:-";
var alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+");
var alphaNumericRegex = new RegExp("^[" + alphaPattern + "]+");
var byteRegex = new RegExp("^[^" + alphaPattern + "]+");
var initMinNumericBeforeAlpha = 8;
var initMinNumericBeforeByte = 5;
var initMinAlphaBeforeByte = 8;
var minNumericBeforeAlpha = 17;
var minNumericBeforeByte = 9;
var minAlphaBeforeByte = 16;
var generatorPolynomials = [[1, 0], [1, 25, 0]];
function fillFunctionCell(matrices, bit, x5, y) {
  for (var i36 = 0; i36 < matrices.length; i36++) {
    matrices[i36][x5][y] = bit;
  }
}
function fillDataCell(matrices, bit, x5, y) {
  for (var i36 = 0; i36 < maskPatternConditions.length; i36++) {
    matrices[i36][x5][y] = maskPatternConditions[i36](x5, y) ? bit ^ 1 : parseInt(bit, 10);
  }
}
function fillData(matrices, blocks) {
  var cellVisitor = new FreeCellVisitor(matrices[0]), block, codewordIdx, cell;
  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
    block = blocks[blockIdx];
    codewordIdx = 0;
    while (block.length > 0) {
      for (var i36 = 0; i36 < block.length; i36++) {
        for (var j2 = 0; j2 < 8; j2++) {
          cell = cellVisitor.getNextCell();
          fillDataCell(matrices, block[i36][codewordIdx].charAt(j2), cell.row, cell.column);
        }
      }
      codewordIdx++;
      while (block[0] && codewordIdx === block[0].length) {
        block.splice(0, 1);
      }
    }
  }
  while (cell = cellVisitor.getNextRemainderCell()) {
    fillDataCell(matrices, 0, cell.row, cell.column);
  }
}
function padDataString(initialDataString, totalDataCodewords) {
  var dataBitsCount = totalDataCodewords * 8, terminatorIndex = 0, paddingCodewordIndex = 0;
  var dataString = initialDataString;
  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {
    dataString += terminator.charAt(terminatorIndex++);
  }
  if (dataString.length % 8 !== 0) {
    dataString += new Array(9 - dataString.length % 8).join("0");
  }
  while (dataString.length < dataBitsCount) {
    dataString += paddingCodewords[paddingCodewordIndex];
    paddingCodewordIndex ^= 1;
  }
  return dataString;
}
function generatePowersOfTwo() {
  var result;
  var power;
  for (power = 1; power < 255; power++) {
    result = powersOfTwoResult[power - 1] * 2;
    if (result > 255) {
      result = result ^ 285;
    }
    powersOfTwoResult[power] = result;
    powersOfTwo[result] = power;
  }
  result = powersOfTwoResult[power - 1] * 2 ^ 285;
  powersOfTwoResult[power] = result;
  powersOfTwoResult[-1] = 0;
}
function xorPolynomials(x5, y) {
  var result = [], idx = x5.length - 2;
  for (var i36 = idx; i36 >= 0; i36--) {
    result[i36] = x5[i36] ^ y[i36];
  }
  return result;
}
function multiplyPolynomials(x5, y) {
  var result = [];
  for (var i36 = 0; i36 < x5.length; i36++) {
    for (var j2 = 0; j2 < y.length; j2++) {
      if (result[i36 + j2] === void 0) {
        result[i36 + j2] = (x5[i36] + (y[j2] >= 0 ? y[j2] : 0)) % 255;
      } else {
        result[i36 + j2] = powersOfTwo[powersOfTwoResult[result[i36 + j2]] ^ powersOfTwoResult[(x5[i36] + y[j2]) % 255]];
      }
    }
  }
  return result;
}
function generateGeneratorPolynomials() {
  var maxErrorCorrectionCodeWordsCount = 68;
  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {
    var firstPolynomial = generatorPolynomials[idx - 1], secondPolynomial = [idx, 0];
    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);
  }
}
generatePowersOfTwo();
generateGeneratorPolynomials();
function multiplyByConstant(polynomial, power) {
  var result = [], idx = polynomial.length - 1;
  do {
    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];
    idx--;
  } while (polynomial[idx] !== void 0);
  return result;
}
function generateErrorCodewords(data, errorCodewordsCount) {
  var generator = generatorPolynomials[errorCodewordsCount - 1], result = new Array(errorCodewordsCount).concat(data), generatorPolynomial = new Array(result.length - generator.length).concat(generator), steps = data.length, errorCodewords = [], divisor, idx;
  for (idx = 0; idx < steps; idx++) {
    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);
    generatorPolynomial.splice(0, 1);
    result = xorPolynomials(divisor, result);
  }
  for (idx = result.length - 1; idx >= 0; idx--) {
    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);
  }
  return errorCodewords;
}
function getBlocks(dataStream, versionCodewordsInformation) {
  var codewordStart = 0, dataBlocks = [], errorBlocks = [], dataBlock, versionGroups = versionCodewordsInformation.groups, blockCodewordsCount, groupBlocksCount, messagePolynomial, codeword;
  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {
    groupBlocksCount = versionGroups[groupIdx][0];
    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {
      blockCodewordsCount = versionGroups[groupIdx][1];
      dataBlock = [];
      messagePolynomial = [];
      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {
        codeword = dataStream.substring(codewordStart, codewordStart + 8);
        dataBlock.push(codeword);
        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);
        codewordStart += 8;
      }
      dataBlocks.push(dataBlock);
      errorBlocks.push(generateErrorCodewords(
        messagePolynomial,
        versionCodewordsInformation.errorCodewordsPerBlock
      ));
    }
  }
  return [dataBlocks, errorBlocks];
}
function chooseMode(str, minNumericBeforeAlpha2, minNumericBeforeByte2, minAlphaBeforeByte2, previousMode) {
  var numeric = numberRegex3.exec(str), numericMatch = numeric ? numeric[0] : "", alpha = alphaRegex.exec(str), alphaMatch = alpha ? alpha[0] : "", alphaNumeric = alphaNumericRegex.exec(str), alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "", mode, modeString;
  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha2 || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte2 && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {
    mode = NUMERIC2;
    modeString = numericMatch;
  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte2 || previousMode === ALPHA_NUMERIC2)) {
    mode = ALPHA_NUMERIC2;
    modeString = numericMatch || alphaMatch;
  } else {
    mode = BYTE3;
    if (alphaNumericMatch) {
      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];
    } else {
      modeString = byteRegex.exec(str)[0];
    }
  }
  return {
    mode,
    modeString
  };
}
function getModes(inputString) {
  var modes = [], previousMode, idx = 0;
  var str = inputString;
  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));
  previousMode = modes[0].mode;
  str = str.substr(modes[0].modeString.length);
  while (str.length > 0) {
    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);
    if (nextMode.mode !== previousMode) {
      previousMode = nextMode.mode;
      modes.push(nextMode);
      idx++;
    } else {
      modes[idx].modeString += nextMode.modeString;
    }
    str = str.substr(nextMode.modeString.length);
  }
  return modes;
}
function getDataCodewordsCount(modes) {
  var length = 0, mode;
  for (var i36 = 0; i36 < modes.length; i36++) {
    mode = DataModeInstances[modes[i36].mode];
    length += mode.getStringBitsLength(modes[i36].modeString.length);
  }
  return Math.ceil(length / 8);
}
function getVersion(dataCodewordsCount, errorCorrectionLevel) {
  var x5 = 0, y = VersionsCodewordsInformation.length - 1, version = Math.floor(VersionsCodewordsInformation.length / 2);
  do {
    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {
      y = version;
    } else {
      x5 = version;
    }
    version = x5 + Math.floor((y - x5) / 2);
  } while (y - x5 > 1);
  if (dataCodewordsCount <= VersionsCodewordsInformation[x5][errorCorrectionLevel].totalDataCodewords) {
    return version + 1;
  }
  return y + 1;
}
function getDataString(modes, version) {
  var dataString = "", mode;
  for (var i36 = 0; i36 < modes.length; i36++) {
    mode = DataModeInstances[modes[i36].mode];
    dataString += mode.encode(modes[i36].modeString, version);
  }
  return dataString;
}
function encodeFormatInformation(format) {
  var formatNumber = toDecimal(format), encodedString, result = "";
  if (formatNumber === 0) {
    return "101010000010010";
  }
  encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);
  for (var i36 = 0; i36 < encodedString.length; i36++) {
    result += encodedString.charAt(i36) ^ formatMaskPattern.charAt(i36);
  }
  return result;
}
function encodeBCH(value2, generatorPolynomial, codeLength) {
  var generatorNumber = toDecimal(generatorPolynomial), polynomialLength = generatorPolynomial.length - 1, valueNumber = value2 << polynomialLength, length = codeLength - polynomialLength, valueString = toBitsString(value2, length), result = dividePolynomials(valueNumber, generatorNumber);
  result = valueString + toBitsString(result, polynomialLength);
  return result;
}
function dividePolynomials(numberX, numberY) {
  var yLength = numberY.toString(2).length, xLength = numberX.toString(2).length;
  var x5 = numberX;
  do {
    x5 ^= numberY << xLength - yLength;
    xLength = x5.toString(2).length;
  } while (xLength >= yLength);
  return x5;
}
function getNumberAt(str, idx) {
  return parseInt(str.charAt(idx), 10);
}
function initMatrices(version) {
  var matrices = [], modules = 17 + 4 * version;
  for (var i36 = 0; i36 < maskPatternConditions.length; i36++) {
    matrices[i36] = new Array(modules);
    for (var j2 = 0; j2 < modules; j2++) {
      matrices[i36][j2] = new Array(modules);
    }
  }
  return matrices;
}
function addFormatInformation(matrices, formatString) {
  var matrix = matrices[0], x5, y, idx = 0, length = formatString.length;
  for (x5 = 0, y = 8; x5 <= 8; x5++) {
    if (x5 !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x5, y);
    }
  }
  for (x5 = 8, y = 7; y >= 0; y--) {
    if (y !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x5, y);
    }
  }
  idx = 0;
  for (y = matrix.length - 1, x5 = 8; y >= matrix.length - 8; y--) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x5, y);
  }
  fillFunctionCell(matrices, 1, matrix.length - 8, 8);
  for (x5 = matrix.length - 7, y = 8; x5 < matrix.length; x5++) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x5, y);
  }
}
function encodeVersionInformation(version) {
  return encodeBCH(version, versionGeneratorPolynomial, 18);
}
function addVersionInformation(matrices, dataString) {
  var matrix = matrices[0], modules = matrix.length, x1 = 0, y1 = modules - 11, x22 = modules - 11, y2 = 0, quotient, mod, value2;
  for (var idx = 0; idx < dataString.length; idx++) {
    quotient = Math.floor(idx / 3);
    mod = idx % 3;
    value2 = getNumberAt(dataString, dataString.length - idx - 1);
    fillFunctionCell(matrices, value2, x1 + quotient, y1 + mod);
    fillFunctionCell(matrices, value2, x22 + mod, y2 + quotient);
  }
}
function addCentricPattern(matrices, pattern, x5, y) {
  var size = pattern.length + 2, length = pattern.length + 1, value2;
  for (var i36 = 0; i36 < pattern.length; i36++) {
    for (var j2 = i36; j2 < size - i36; j2++) {
      value2 = pattern[i36];
      fillFunctionCell(matrices, value2, x5 + j2, y + i36);
      fillFunctionCell(matrices, value2, x5 + i36, y + j2);
      fillFunctionCell(matrices, value2, x5 + length - j2, y + length - i36);
      fillFunctionCell(matrices, value2, x5 + length - i36, y + length - j2);
    }
  }
}
function addFinderSeparator(matrices, direction, x5, y) {
  var nextX = x5, nextY = y, matrix = matrices[0];
  do {
    fillFunctionCell(matrices, 0, nextX, y);
    fillFunctionCell(matrices, 0, x5, nextY);
    nextX += direction[0];
    nextY += direction[1];
  } while (nextX >= 0 && nextX < matrix.length);
}
function addFinderPatterns(matrices) {
  var modules = matrices[0].length;
  addCentricPattern(matrices, finderPattern, 0, 0);
  addFinderSeparator(matrices, [-1, -1], 7, 7);
  addCentricPattern(matrices, finderPattern, modules - 7, 0);
  addFinderSeparator(matrices, [1, -1], modules - 8, 7);
  addCentricPattern(matrices, finderPattern, 0, modules - 7);
  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);
}
function addAlignmentPatterns(matrices, version) {
  if (version < 2) {
    return;
  }
  var matrix = matrices[0], modules = matrix.length, pointsCount = Math.floor(version / 7), points = [6], startDistance, distance, idx = 0;
  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {
    distance = (modules - 13 - startDistance) / pointsCount;
  } else {
    startDistance = distance = (modules - 13) / (pointsCount + 1);
  }
  points.push(points[idx++] + startDistance);
  while (points[idx] + distance < modules) {
    points.push(points[idx++] + distance);
  }
  for (var i36 = 0; i36 < points.length; i36++) {
    for (var j2 = 0; j2 < points.length; j2++) {
      if (matrix[points[i36]][points[j2]] === void 0) {
        addCentricPattern(matrices, alignmentPattern, points[i36] - 2, points[j2] - 2);
      }
    }
  }
}
function addTimingFunctions(matrices) {
  var row = 6, column = 6, value2 = 1, modules = matrices[0].length;
  for (var i36 = 8; i36 < modules - 8; i36++) {
    fillFunctionCell(matrices, value2, row, i36);
    fillFunctionCell(matrices, value2, i36, column);
    value2 ^= 1;
  }
}
function scoreMaskMatrixes(matrices) {
  var scores = [], previousBits = [], darkModules = [], patterns = [], adjacentSameBits = [], matrix, i36, row = 0, column = 1, modulesLength = matrices[0].length;
  for (i36 = 0; i36 < matrices.length; i36++) {
    scores[i36] = 0;
    darkModules[i36] = 0;
    adjacentSameBits[i36] = [0, 0];
    patterns[i36] = [0, 0];
    previousBits[i36] = [];
  }
  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {
    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {
      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {
        matrix = matrices[matrixIndex];
        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);
        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {
          scores[matrixIndex] += 3;
        }
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);
      }
    }
  }
  var total3 = modulesLength * modulesLength, minIdx, min4 = Number.MAX_VALUE;
  for (i36 = 0; i36 < scores.length; i36++) {
    scores[i36] += calculateDarkModulesRatioScore(darkModules[i36], total3);
    if (scores[i36] < min4) {
      min4 = scores[i36];
      minIdx = i36;
    }
  }
  return minIdx;
}
function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {
  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;
  if (patterns[idx][rowColumn] === finderPatternValue) {
    scores[idx] += 40;
  }
}
function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {
  if (previousBits[idx][rowColumn] === bit) {
    adjacentBits[idx][rowColumn]++;
  } else {
    previousBits[idx][rowColumn] = bit;
    if (adjacentBits[idx][rowColumn] >= 5) {
      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;
    }
    adjacentBits[idx][rowColumn] = 1;
  }
}
function calculateDarkModulesRatioScore(darkModules, total3) {
  var percent = Math.floor(darkModules / total3 * 100), mod5 = percent % 5, previous = Math.abs(percent - mod5 - 50), next = Math.abs(percent + 5 - mod5 - 50), score = 10 * Math.min(previous / 5, next / 5);
  return score;
}
function createQRCodeDataEncoder(encoding) {
  if (encoding && encoding.toLowerCase().indexOf("utf_8") >= 0) {
    return new Utf8Encoder();
  }
  return new IsoEncoder();
}
function encodeData(inputString, errorCorrectionLevel, encoding) {
  var encoder = createQRCodeDataEncoder(encoding), encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel), version = encodingResult.version, versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel], dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords), blocks = getBlocks(dataString, versionInformation), matrices = initMatrices(version);
  addFinderPatterns(matrices);
  addAlignmentPatterns(matrices, version);
  addTimingFunctions(matrices);
  if (version >= 7) {
    addVersionInformation(matrices, toBitsString(0, 18));
  }
  addFormatInformation(matrices, toBitsString(0, 15));
  fillData(matrices, blocks);
  var minIdx = scoreMaskMatrixes(matrices), optimalMatrix = matrices[minIdx];
  if (version >= 7) {
    addVersionInformation([optimalMatrix], encodeVersionInformation(version));
  }
  var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);
  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));
  return optimalMatrix;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/qrcode.js
var round2 = Math.round;
var crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];
var squarePattern = [[0, 1], [1, 1], [1, 0]];
var QRCodeDefaults = {
  DEFAULT_SIZE: 200,
  QUIET_ZONE_LENGTH: 4,
  DEFAULT_ERROR_CORRECTION_LEVEL: "L",
  DEFAULT_BACKGROUND: "#fff",
  DEFAULT_DARK_MODULE_COLOR: "#000",
  MIN_BASE_UNIT_SIZE: 1,
  DEFAULT_LOGO_SIZE: 7
};
var QRCode = function(Class) {
  function QRCode2(element, options, errorHandler) {
    if (errorHandler === void 0) errorHandler = defaultErrorHandler;
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.wrapper = this.element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this.setOptions(options);
  }
  if (Class) QRCode2.__proto__ = Class;
  QRCode2.prototype = Object.create(Class && Class.prototype);
  QRCode2.prototype.constructor = QRCode2;
  QRCode2.prototype.destroy = function destroy() {
    this._destroySurface();
  };
  QRCode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-qrcode");
  };
  QRCode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  QRCode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  QRCode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  QRCode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  QRCode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  QRCode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size,
      height: size
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  QRCode2.prototype.getSize = function getSize() {
    var element = this.element;
    var elementWidth = element.clientWidth;
    var elementHeight = element.clientHeight;
    var size = { width: 0, height: 0 };
    if (elementWidth > 0) {
      size.width = elementWidth;
    }
    if (elementHeight) {
      size.height = elementHeight;
    }
    return size;
  };
  QRCode2.prototype._resize = function _resize() {
    this.redraw();
  };
  QRCode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  QRCode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  QRCode2.prototype._render = function _render() {
    var value2 = this._value, baseUnit, border = this.options.border || {}, padding = this.options.padding || 0, borderWidth = border.width || 0, quietZoneSize, matrix, size, dataSize, contentSize;
    border.width = borderWidth;
    var visual = new drawing_exports.Group();
    try {
      if (value2) {
        matrix = encodeData(value2, this.options.errorCorrection, this.options.encoding);
        size = this._getSize();
        contentSize = size - 2 * (borderWidth + padding);
        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);
        dataSize = matrix.length * baseUnit;
        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;
        visual.append(this._renderBackground(size, border));
        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));
        if (this._hasCustomLogo()) {
          visual.append(this._renderLogo(size, baseUnit));
        } else if (this._isSwiss()) {
          visual.append(this._renderSwissCode(size, baseUnit));
        }
      }
    } catch (error) {
      this.onError(error);
    }
    return visual;
  };
  QRCode2.prototype._renderLogo = function _renderLogo(qrSize, baseUnit) {
    var image;
    var imageRect;
    var center = round2(qrSize / 2);
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    var logoUrl = this.options.overlay.imageUrl;
    var position = {
      x: center - logoSize.width / 2,
      y: center - logoSize.height / 2
    };
    imageRect = new geometry_exports.Rect(
      new geometry_exports.Point(position.x, position.y),
      new geometry_exports.Size(logoSize.width, logoSize.height)
    );
    image = new drawing_exports.Image(logoUrl, imageRect);
    return image;
  };
  QRCode2.prototype._renderSwissCode = function _renderSwissCode(qrSize, baseUnit) {
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    logoSize = Math.max(logoSize.width, logoSize.height);
    var crossSize = logoSize / 4;
    var crossOffset = crossSize / 2;
    var center = qrSize / 2;
    var start = {};
    var visual = new drawing_exports.Group();
    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);
    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, "#fff"));
    start.x = start.y = center - logoSize / 2;
    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));
    start.x = center + crossOffset - logoSize / 2;
    start.y = center + crossOffset + crossSize - logoSize / 2;
    visual.append(this._renderShape(start, crossSize, crossPattern, "#fff"));
    return visual;
  };
  QRCode2.prototype._renderShape = function _renderShape(start, step, pattern, color) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color
      },
      stroke: null
    });
    path.moveTo(start.x, start.y);
    for (var i36 = 0; i36 < pattern.length; i36++) {
      path.lineTo(start.x + step * pattern[i36][0], start.y + step * pattern[i36][1]);
    }
    path.close();
    return path;
  };
  QRCode2.prototype._getSize = function _getSize() {
    var size;
    if (this.options.size) {
      size = parseInt(this.options.size, 10);
    } else {
      var element = this.element;
      var elementSize2 = surfaceSize(element, this.options.renderAs);
      var min4 = Math.min(elementSize2.width, elementSize2.height);
      if (min4 > 0) {
        size = min4;
      } else {
        size = QRCodeDefaults.DEFAULT_SIZE;
      }
    }
    return size;
  };
  QRCode2.prototype._calculateBaseUnit = function _calculateBaseUnit(size, matrixSize) {
    var baseUnit = Math.floor(size / matrixSize);
    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      var minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);
      this.onError(new Error(
        "Insufficient size for QR Code: the current size is " + size + "px and the minimum size is " + minSize + "px."
      ));
    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      baseUnit--;
    }
    return baseUnit;
  };
  QRCode2.prototype._renderMatrix = function _renderMatrix(matrix, baseUnit, quietZoneSize) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color: this.options.color
      },
      stroke: null
    });
    for (var row = 0; row < matrix.length; row++) {
      var y = quietZoneSize + row * baseUnit;
      var column = 0;
      while (column < matrix.length) {
        while (matrix[row][column] === 0 && column < matrix.length) {
          column++;
        }
        if (column < matrix.length) {
          var x5 = column;
          while (matrix[row][column] === 1) {
            column++;
          }
          var x1 = round2(quietZoneSize + x5 * baseUnit);
          var y1 = round2(y);
          var x22 = round2(quietZoneSize + column * baseUnit);
          var y2 = round2(y + baseUnit);
          path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x22, y2).lineTo(x22, y1).close();
        }
      }
    }
    return path;
  };
  QRCode2.prototype._renderBackground = function _renderBackground(size, border) {
    var box = new box_default(0, 0, size, size).unpad(border.width / 2);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: this.options.background
      },
      stroke: {
        color: border.color,
        width: border.width
      }
    });
    return background;
  };
  QRCode2.prototype.setOptions = function setOptions(options) {
    var newOptions = options || {};
    this.options = extend10(this.options, newOptions);
    if (options.value !== void 0) {
      this._value = String(this.options.value);
    }
    this._initSurface();
    this.redraw();
  };
  QRCode2.prototype.value = function value2(value$1) {
    if (value$1 === void 0) {
      return this._value;
    }
    this._value = String(value$1);
    this.redraw();
  };
  QRCode2.prototype._hasCustomLogo = function _hasCustomLogo() {
    return Boolean(this.options.overlay.imageUrl);
  };
  QRCode2.prototype._isSwiss = function _isSwiss() {
    return this.options.overlay.type === "swiss";
  };
  QRCode2.prototype._getLogoSize = function _getLogoSize(defautLogoSize) {
    var width = this.options.overlay.width;
    var height = this.options.overlay.height;
    if (!width && !height) {
      width = height = defautLogoSize;
    } else if (width && !height) {
      height = width;
    } else if (!width && height) {
      width = height;
    }
    return {
      width,
      height
    };
  };
  return QRCode2;
}(class_default);
setDefaultOptions(QRCode, {
  name: "QRCode",
  renderAs: "svg",
  encoding: "ISO_8859_1",
  value: "",
  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,
  background: QRCodeDefaults.DEFAULT_BACKGROUND,
  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,
  size: "",
  padding: 0,
  border: {
    color: "",
    width: 0
  },
  overlay: {
    type: "image",
    imageUrl: "",
    width: 0,
    height: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/map/datums.js
var WGS84 = {
  a: 6378137,
  // Semi-major radius
  b: 6356752314245179e-9,
  // Semi-minor radius
  f: 0.0033528106647474805,
  // Flattening
  e: 0.08181919084262149
  // Eccentricity
};
var datums = {
  WGS84
};

// node_modules/@progress/kendo-charts/dist/es/map/location.js
function toSquare(value2) {
  return value2 * value2;
}
var math = Math;
var abs = math.abs;
var atan = math.atan;
var atan2 = math.atan2;
var cos = math.cos;
var sin = math.sin;
var tan = math.tan;
var Location = function(Class) {
  function Location2(lat, lng) {
    Class.call(this);
    this.initProperties();
    if (arguments.length === 1) {
      this.lat = lat[0];
      this.lng = lat[1];
    } else {
      this.lat = lat;
      this.lng = lng;
    }
  }
  if (Class) Location2.__proto__ = Class;
  Location2.prototype = Object.create(Class && Class.prototype);
  Location2.prototype.constructor = Location2;
  Location2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      DISTANCE_ITERATIONS: 100,
      DISTANCE_CONVERGENCE: 1e-12,
      DISTANCE_PRECISION: 2,
      FORMAT: "{0:N6}{1:N6}"
    });
  };
  Location2.prototype.toArray = function toArray() {
    return [
      this.lat,
      this.lng
    ];
  };
  Location2.prototype.equals = function equals(loc) {
    return loc && loc.lat === this.lat && loc.lng === this.lng;
  };
  Location2.prototype.clone = function clone3() {
    return new Location2(this.lat, this.lng);
  };
  Location2.prototype.round = function round$1(precision) {
    this.lng = round(this.lng, precision);
    this.lat = round(this.lat, precision);
    return this;
  };
  Location2.prototype.wrap = function wrap() {
    this.lng = this.lng % 180;
    this.lat = this.lat % 90;
    return this;
  };
  Location2.prototype.distanceTo = function distanceTo(dest, datum) {
    return this.greatCircleTo(dest, datum).distance;
  };
  Location2.prototype.destination = function destination(distance, initialBearing, initialDatum) {
    var bearing = rad(initialBearing);
    var datum = initialDatum || datums.WGS84;
    var fromLat = rad(this.lat);
    var fromLng = rad(this.lng);
    var dToR = distance / datum.a;
    var lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));
    var lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));
    return new Location2(deg(lat), deg(lng));
  };
  Location2.prototype.greatCircleTo = function greatCircleTo(initialDest, initialDatum) {
    var this$1 = this;
    var dest = Location2.create(dest);
    var datum = initialDatum || datums.WGS84;
    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {
      return {
        distance: 0,
        azimuthFrom: 0,
        azimuthTo: 0
      };
    }
    var a38 = datum.a;
    var b2 = datum.b;
    var f4 = datum.f;
    var L = rad(dest.lng - this.lng);
    var U1 = atan((1 - f4) * tan(rad(this.lat)));
    var sinU1 = sin(U1);
    var cosU1 = cos(U1);
    var U2 = atan((1 - f4) * tan(rad(dest.lat)));
    var sinU2 = sin(U2);
    var cosU2 = cos(U2);
    var lambda = L;
    var prevLambda;
    var i36 = this.DISTANCE_ITERATIONS;
    var converged = false;
    var sinLambda;
    var cosLambda;
    var sino;
    var cosA2;
    var coso;
    var cos2om;
    var sigma;
    while (!converged && i36-- > 0) {
      sinLambda = sin(lambda);
      cosLambda = cos(lambda);
      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = atan2(sino, coso);
      var sinA = cosU1 * cosU2 * sinLambda / sino;
      cosA2 = 1 - toSquare(sinA);
      cos2om = 0;
      if (cosA2 !== 0) {
        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;
      }
      prevLambda = lambda;
      var C3 = f4 / 16 * cosA2 * (4 + f4 * (4 - 3 * cosA2));
      lambda = L + (1 - C3) * f4 * sinA * (sigma + C3 * sino * (cos2om + C3 * coso * (-1 + 2 * toSquare(cos2om))));
      converged = abs(lambda - prevLambda) <= this$1.DISTANCE_CONVERGENCE;
    }
    var u22 = cosA2 * (toSquare(a38) - toSquare(b2)) / toSquare(b2);
    var A = 1 + u22 / 16384 * (4096 + u22 * (-768 + u22 * (320 - 175 * u22)));
    var B = u22 / 1024 * (256 + u22 * (-128 + u22 * (74 - 47 * u22)));
    var deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));
    var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
    var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
    return {
      distance: round(b2 * A * (sigma - deltao), this.DISTANCE_PRECISION),
      azimuthFrom: deg(azimuthFrom),
      azimuthTo: deg(azimuthTo)
    };
  };
  Location2.prototype.toString = function toString() {
    return String(this.lat) + "," + String(this.lng);
  };
  Location2.fromLngLat = function fromLngLat(lngAndLat) {
    return new Location2(lngAndLat[1], lngAndLat[0]);
  };
  Location2.fromLatLng = function fromLatLng(lngAndLat) {
    return new Location2(lngAndLat[0], lngAndLat[1]);
  };
  Location2.create = function create2(a38, b2) {
    if (defined(a38)) {
      if (a38 instanceof Location2) {
        return a38.clone();
      } else if (arguments.length === 1 && a38.length === 2) {
        return Location2.fromLatLng(a38);
      }
      return new Location2(a38, b2);
    }
  };
  return Location2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/crs.js
var math2 = Math;
var atan3 = math2.atan;
var exp = math2.exp;
var pow = math2.pow;
var sin2 = math2.sin;
var log2 = math2.log;
var tan2 = math2.tan;
var Point4 = geometry_exports.Point;
var PI = math2.PI;
var PI_DIV_2 = PI / 2;
var PI_DIV_4 = PI / 4;
var DEG_TO_RAD = PI / 180;
var WGS842 = datums.WGS84;
var Mercator = function(Class) {
  function Mercator2(options) {
    Class.call(this);
    this.initProperties();
    this._initOptions(options);
  }
  if (Class) Mercator2.__proto__ = Class;
  Mercator2.prototype = Object.create(Class && Class.prototype);
  Mercator2.prototype.constructor = Mercator2;
  Mercator2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Mercator2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      MAX_LNG: 180,
      MAX_LAT: 85.0840590501,
      INVERSE_ITERATIONS: 15,
      INVERSE_CONVERGENCE: 1e-12
    });
  };
  Mercator2.prototype.forward = function forward(loc, clamp) {
    var proj = this, options = proj.options, datum = options.datum, r27 = datum.a, lng0 = options.centralMeridian, lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT), lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng, x5 = rad(lng - lng0) * r27, y = proj._projectLat(lat);
    return new Point4(x5, y);
  };
  Mercator2.prototype._projectLat = function _projectLat(lat) {
    var datum = this.options.datum, ecc = datum.e, r27 = datum.a, y = rad(lat), ts = tan2(PI_DIV_4 + y / 2), con = ecc * sin2(y), p9 = pow((1 - con) / (1 + con), ecc / 2);
    return r27 * log2(ts * p9);
  };
  Mercator2.prototype.inverse = function inverse2(point, clamp) {
    var proj = this, options = proj.options, datum = options.datum, r27 = datum.a, lng0 = options.centralMeridian, lng = point.x / (DEG_TO_RAD * r27) + lng0, lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);
    if (clamp) {
      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);
    }
    return new Location(lat, lng);
  };
  Mercator2.prototype._inverseY = function _inverseY(y) {
    var proj = this, datum = proj.options.datum, r27 = datum.a, ecc = datum.e, ecch = ecc / 2, ts = exp(-y / r27), phi = PI_DIV_2 - 2 * atan3(ts), i36;
    for (i36 = 0; i36 <= proj.INVERSE_ITERATIONS; i36++) {
      var con = ecc * sin2(phi), p9 = pow((1 - con) / (1 + con), ecch), dphi = PI_DIV_2 - 2 * atan3(ts * p9) - phi;
      phi += dphi;
      if (math2.abs(dphi) <= proj.INVERSE_CONVERGENCE) {
        break;
      }
    }
    return deg(phi);
  };
  return Mercator2;
}(class_default);
setDefaultOptions(Mercator, {
  centralMeridian: 0,
  datum: WGS842
});
var SphericalMercator = function(Mercator2) {
  function SphericalMercator2() {
    Mercator2.apply(this, arguments);
  }
  if (Mercator2) SphericalMercator2.__proto__ = Mercator2;
  SphericalMercator2.prototype = Object.create(Mercator2 && Mercator2.prototype);
  SphericalMercator2.prototype.constructor = SphericalMercator2;
  SphericalMercator2.prototype.initProperties = function initProperties() {
    Mercator2.prototype.initProperties.call(this);
    deepExtend(this, {
      MAX_LAT: 85.0511287798
    });
  };
  SphericalMercator2.prototype._projectLat = function _projectLat(lat) {
    var r27 = this.options.datum.a, y = rad(lat), ts = tan2(PI_DIV_4 + y / 2);
    return r27 * log2(ts);
  };
  SphericalMercator2.prototype._inverseY = function _inverseY(y) {
    var r27 = this.options.datum.a, ts = exp(-y / r27);
    return deg(PI_DIV_2 - 2 * atan3(ts));
  };
  return SphericalMercator2;
}(Mercator);
var Equirectangular = function(Class) {
  function Equirectangular2() {
    Class.apply(this, arguments);
  }
  if (Class) Equirectangular2.__proto__ = Class;
  Equirectangular2.prototype = Object.create(Class && Class.prototype);
  Equirectangular2.prototype.constructor = Equirectangular2;
  Equirectangular2.prototype.forward = function forward(loc) {
    return new Point4(loc.lng, loc.lat);
  };
  Equirectangular2.prototype.inverse = function inverse2(point) {
    return new Location(point.y, point.x);
  };
  return Equirectangular2;
}(class_default);
var EPSG3857 = function(Class) {
  function EPSG38572() {
    Class.call(this);
    var crs = this, proj = crs._proj = new SphericalMercator();
    var c10 = this.c = 2 * PI * proj.options.datum.a;
    this._tm = geometry_exports.transform().translate(0.5, 0.5).scale(1 / c10, -1 / c10);
    this._itm = geometry_exports.transform().scale(c10, -c10).translate(-0.5, -0.5);
  }
  if (Class) EPSG38572.__proto__ = Class;
  EPSG38572.prototype = Object.create(Class && Class.prototype);
  EPSG38572.prototype.constructor = EPSG38572;
  EPSG38572.prototype.toPoint = function toPoint(loc, scale, clamp) {
    var point = this._proj.forward(loc, clamp);
    return point.transform(this._tm).scale(scale || 1);
  };
  EPSG38572.prototype.toLocation = function toLocation(point, scale, clamp) {
    var newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);
    return this._proj.inverse(newPoint, clamp);
  };
  return EPSG38572;
}(class_default);
var EPSG3395 = function(Class) {
  function EPSG33952() {
    Class.call(this);
    this._proj = new Mercator();
  }
  if (Class) EPSG33952.__proto__ = Class;
  EPSG33952.prototype = Object.create(Class && Class.prototype);
  EPSG33952.prototype.constructor = EPSG33952;
  EPSG33952.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG33952.prototype.toLocation = function toLocation(point) {
    return this._proj.inverse(point);
  };
  return EPSG33952;
}(class_default);
var EPSG4326 = function(Class) {
  function EPSG43262() {
    Class.call(this);
    this._proj = new Equirectangular();
  }
  if (Class) EPSG43262.__proto__ = Class;
  EPSG43262.prototype = Object.create(Class && Class.prototype);
  EPSG43262.prototype.constructor = EPSG43262;
  EPSG43262.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG43262.prototype.toLocation = function toLocation(point) {
    return this._proj.inverse(point);
  };
  return EPSG43262;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/utils.js
var proxy = function(method, context) {
  return method.bind(context);
};
var convertToHtml = function(html2) {
  var div = document.createElement("div");
  div.innerHTML = html2;
  return div.firstChild;
};
var appendHtml = function(html2, element) {
  var div = document.createElement("div");
  div.innerHTML = html2;
  while (div.childNodes.length > 0) {
    element.appendChild(div.childNodes[0]);
  }
};
var removeChildren = function(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
};
var prepend = function(element, originElement) {
  originElement.insertBefore(element, originElement.firstChild);
};
var wrapInner = function(parent, wrapper2) {
  parent.appendChild(wrapper2);
  while (parent.firstChild !== wrapper2) {
    wrapper2.appendChild(parent.firstChild);
  }
};
var toHyphens = function(str) {
  var result = str.replace(/([a-z][A-Z])/g, function(g2) {
    return g2.charAt(0) + "-" + g2.charAt(1).toLowerCase();
  });
  return result;
};
var toPixels = function(value2) {
  var result;
  if (value2 && String(value2).endsWith("px")) {
    result = value2;
  } else {
    result = String(value2) + "px";
  }
  return result;
};
var hasNativeScrolling = function(userAgent) {
  var ref2 = getSupportedFeatures(userAgent);
  var mobileOS = ref2.mobileOS;
  return mobileOS.ios || mobileOS.android;
};
var setDefaultEvents = function(type, events) {
  var proto = type.prototype;
  if (proto.events) {
    events.forEach(function(event) {
      if (proto.events.indexOf(event) < 0) {
        proto.events.push(event);
      }
    });
  } else {
    proto.events = events;
  }
};
var wheelDeltaY = function(e39) {
  var deltaY = e39.wheelDeltaY;
  var delta;
  if (e39.wheelDelta) {
    if (deltaY === void 0 || deltaY) {
      delta = e39.wheelDelta;
    }
  } else if (e39.detail && e39.axis === e39.VERTICAL_AXIS) {
    delta = -e39.detail * 10;
  }
  return delta;
};
var renderPos = function(pos) {
  var result = [];
  if (pos) {
    var parts = toHyphens(pos).split("-");
    for (var i36 = 0; i36 < parts.length; i36++) {
      result.push("k-pos-" + parts[i36]);
    }
  }
  return result.join(" ");
};

// node_modules/@progress/kendo-charts/dist/es/map/attribution.js
var Attribution = function(Observable2) {
  function Attribution2(element, options) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options);
    this.items = [];
    addClass(this.element, "k-widget k-attribution");
  }
  if (Observable2) Attribution2.__proto__ = Observable2;
  Attribution2.prototype = Object.create(Observable2 && Observable2.prototype);
  Attribution2.prototype.constructor = Attribution2;
  Attribution2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Attribution2.prototype.filter = function filter(extent, zoom) {
    this._extent = extent;
    this._zoom = zoom;
    this._render();
  };
  Attribution2.prototype.add = function add3(item) {
    var newItem = item;
    if (defined(item)) {
      if (typeof item === "string") {
        newItem = {
          text: item
        };
      }
      this.items.push(newItem);
      this._render();
    }
  };
  Attribution2.prototype.remove = function remove(text) {
    var this$1 = this;
    var result = [];
    for (var i36 = 0; i36 < this.items.length; i36++) {
      var item = this$1.items[i36];
      if (item.text !== text) {
        result.push(item);
      }
    }
    this.items = result;
    this._render();
  };
  Attribution2.prototype.clear = function clear3() {
    this.items = [];
    removeChildren(this.element);
  };
  Attribution2.prototype._render = function _render() {
    var this$1 = this;
    var result = [];
    for (var i36 = 0; i36 < this.items.length; i36++) {
      var item = this$1.items[i36];
      var text = this$1._itemText(item);
      if (text !== "") {
        result.push(text);
      }
    }
    if (result.length > 0) {
      removeChildren(this.element);
      var html2 = result.join(this.options.separator);
      appendHtml(html2, this.element);
      this.showElement();
    } else {
      this.hideElement();
    }
  };
  Attribution2.prototype.hideElement = function hideElement() {
    this.element.style.display = "none";
  };
  Attribution2.prototype.showElement = function showElement() {
    this.element.style.display = "";
  };
  Attribution2.prototype._itemText = function _itemText(item) {
    var text = "";
    var inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);
    var inArea = this._inArea(item.extent);
    if (inZoomLevel && inArea) {
      text += item.text;
    }
    return text;
  };
  Attribution2.prototype._inZoomLevel = function _inZoomLevel(min4, max3) {
    var result = true;
    var newMin = valueOrDefault(min4, -Number.MAX_VALUE);
    var newMax = valueOrDefault(max3, Number.MAX_VALUE);
    result = this._zoom > newMin && this._zoom < newMax;
    return result;
  };
  Attribution2.prototype._inArea = function _inArea(area) {
    var result = true;
    if (area) {
      result = area.contains(this._extent);
    }
    return result;
  };
  return Attribution2;
}(observable_default);
setDefaultOptions(Attribution, {
  name: "Attribution",
  separator: "&nbsp;|&nbsp;"
});

// node_modules/@progress/kendo-charts/dist/es/map/navigator.js
var PAN = "pan";
var directionsMap = {
  up: {
    className: "k-navigator-n",
    iconClass: "k-i-caret-alt-up"
  },
  down: {
    className: "k-navigator-s",
    iconClass: "k-i-caret-alt-down"
  },
  right: {
    className: "k-navigator-e",
    iconClass: "k-i-caret-alt-right"
  },
  left: {
    className: "k-navigator-w",
    iconClass: "k-i-caret-alt-left"
  }
};
function createButton(direction, iconOptions) {
  var html2 = '<button class="k-button k-button-square k-rounded-full k-button-flat k-button-flat-base k-icon-button ' + directionsMap[direction].className + '" aria-label="move ' + direction + '">' + renderIcon({ icon: "caret-alt-" + direction, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html2);
}
var Navigator2 = function(Observable2) {
  function Navigator3(element, options) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options);
    var navigateUpButton = createButton("up", options.icons);
    var navigateRightlButton = createButton("right", options.icons);
    var navigateDownButton = createButton("down", options.icons);
    var navigateLeftButton = createButton("left", options.icons);
    this.element.appendChild(navigateUpButton);
    this.element.appendChild(navigateRightlButton);
    this.element.appendChild(navigateDownButton);
    this.element.appendChild(navigateLeftButton);
    addClass(this.element, "k-widget k-navigator");
    on(this.element, "click", ".k-button", proxy(this._click, this));
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = proxy(this._keydown, this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable2) Navigator3.__proto__ = Observable2;
  Navigator3.prototype = Object.create(Observable2 && Observable2.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.destroy = function destroy() {
    this.dispose();
  };
  Navigator3.prototype.dispose = function dispose() {
    off(this._keyroot, "keydown", this._keydownHandler);
  };
  Navigator3.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  Navigator3.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Navigator3.prototype._pan = function _pan(x5, y) {
    var panStep = this.options.panStep;
    this.trigger(PAN, {
      x: x5 * panStep,
      y: y * panStep
    });
  };
  Navigator3.prototype._click = function _click(e39) {
    var x5 = 0;
    var y = 0;
    var button = e39.currentTarget;
    if (button.matches(".k-navigator-n")) {
      y = 1;
    } else if (button.matches(".k-navigator-s")) {
      y = -1;
    } else if (button.matches(".k-navigator-e")) {
      x5 = 1;
    } else if (button.matches(".k-navigator-w")) {
      x5 = -1;
    }
    this._pan(x5, y);
    e39.preventDefault();
  };
  Navigator3.prototype._keydown = function _keydown(e39) {
    switch (e39.which) {
      case keys_default.UP:
        this._pan(0, 1);
        e39.preventDefault();
        break;
      case keys_default.DOWN:
        this._pan(0, -1);
        e39.preventDefault();
        break;
      case keys_default.RIGHT:
        this._pan(1, 0);
        e39.preventDefault();
        break;
      case keys_default.LEFT:
        this._pan(-1, 0);
        e39.preventDefault();
        break;
      default:
        break;
    }
  };
  return Navigator3;
}(observable_default);
setDefaultOptions(Navigator2, {
  name: "Navigator",
  panStep: 1
});
setDefaultEvents(Navigator2, [
  PAN
]);

// node_modules/@progress/kendo-charts/dist/es/map/zoom.js
function createButton2(direction, icon, iconOptions) {
  var html2 = '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-zoom-' + direction + '" title="zoom-' + direction + '" aria-label="zoom-' + direction + '">' + renderIcon({ icon, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html2);
}
var PLUS = 187;
var MINUS = 189;
var FF_PLUS = 61;
var FF_MINUS = 173;
var CHANGE = "change";
var ZoomControl = function(Observable2) {
  function ZoomControl2(element, options, iconOptions) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options);
    var zoomInButton = createButton2("in", "plus", iconOptions);
    var zoomOutButton = createButton2("out", "minus", iconOptions);
    this.element.appendChild(zoomInButton);
    this.element.appendChild(zoomOutButton);
    this.element.setAttribute("role", "group");
    addClass(this.element, "k-widget k-zoom-control k-button-group k-group-horizontal");
    this._clickHandler = this._click.bind(this);
    on(this.element, "click", ".k-button", this._clickHandler);
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = this._keydown.bind(this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable2) ZoomControl2.__proto__ = Observable2;
  ZoomControl2.prototype = Object.create(Observable2 && Observable2.prototype);
  ZoomControl2.prototype.constructor = ZoomControl2;
  ZoomControl2.prototype.destroy = function destroy() {
    if (this.element) {
      off(this.element, "click", this._clickHandler);
    }
    if (this._keyroot) {
      off(this._keyroot, "keydown", this._keydownHandler);
    }
  };
  ZoomControl2.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  ZoomControl2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  ZoomControl2.prototype._change = function _change(direction) {
    var zoomStep = this.options.zoomStep;
    this.trigger(CHANGE, { delta: direction * zoomStep });
  };
  ZoomControl2.prototype._click = function _click(e39) {
    var button = e39.currentTarget;
    var direction = 1;
    if (hasClasses(button, "k-zoom-out")) {
      direction = -1;
    }
    this._change(direction);
    e39.preventDefault();
  };
  ZoomControl2.prototype._keydown = function _keydown(e39) {
    switch (e39.which) {
      case keys_default.NUMPAD_PLUS:
      case PLUS:
      case FF_PLUS:
        this._change(1);
        break;
      case keys_default.NUMPAD_MINUS:
      case MINUS:
      case FF_MINUS:
        this._change(-1);
        break;
      default:
        break;
    }
  };
  return ZoomControl2;
}(observable_default);
setDefaultOptions(ZoomControl, {
  name: "ZoomControl",
  zoomStep: 1
});
setDefaultEvents(ZoomControl, [
  CHANGE
]);

// node_modules/@progress/kendo-charts/dist/es/map/extent.js
var math3 = Math;
var max = math3.max;
var min = math3.min;
var Extent = function(Class) {
  function Extent2(initialNw, initialSe) {
    Class.call(this);
    var nw = Location.create(initialNw);
    var se = Location.create(initialSe);
    if (nw.lng + 180 > se.lng + 180 && nw.lat + 90 < se.lat + 90) {
      this.se = nw;
      this.nw = se;
    } else {
      this.se = se;
      this.nw = nw;
    }
  }
  if (Class) Extent2.__proto__ = Class;
  Extent2.prototype = Object.create(Class && Class.prototype);
  Extent2.prototype.constructor = Extent2;
  var staticAccessors2 = { World: { configurable: true } };
  Extent2.prototype.contains = function contains(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se.lng + 180 && lat + 90 >= se.lat + 90 && lat + 90 <= nw.lat + 90;
  };
  Extent2.prototype.center = function center() {
    var nw = this.nw;
    var se = this.se;
    var lng = nw.lng + (se.lng - nw.lng) / 2;
    var lat = nw.lat + (se.lat - nw.lat) / 2;
    return new Location(lat, lng);
  };
  Extent2.prototype.containsAny = function containsAny(locs) {
    var this$1 = this;
    var result = false;
    for (var i36 = 0; i36 < locs.length; i36++) {
      result = result || this$1.contains(locs[i36]);
    }
    return result;
  };
  Extent2.prototype.include = function include(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    nw.lng = min(nw.lng, lng);
    nw.lat = max(nw.lat, lat);
    se.lng = max(se.lng, lng);
    se.lat = min(se.lat, lat);
  };
  Extent2.prototype.includeAll = function includeAll(locs) {
    var this$1 = this;
    for (var i36 = 0; i36 < locs.length; i36++) {
      this$1.include(locs[i36]);
    }
  };
  Extent2.prototype.edges = function edges() {
    var nw = this.nw, se = this.se;
    return {
      nw: this.nw,
      ne: new Location(nw.lat, se.lng),
      se: this.se,
      sw: new Location(se.lat, nw.lng)
    };
  };
  Extent2.prototype.toArray = function toArray() {
    var nw = this.nw, se = this.se;
    return [
      nw,
      new Location(nw.lat, se.lng),
      se,
      new Location(se.lat, nw.lng)
    ];
  };
  Extent2.prototype.overlaps = function overlaps(extent) {
    return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());
  };
  Extent2.create = function create2(a38, b2) {
    if (a38 instanceof Extent2) {
      return a38;
    } else if (a38 && b2) {
      return new Extent2(a38, b2);
    } else if (a38 && a38.length === 4 && !b2) {
      return new Extent2([
        a38[0],
        a38[1]
      ], [
        a38[2],
        a38[3]
      ]);
    }
  };
  staticAccessors2.World.get = function() {
    return new Extent2([90, -180], [-90, 180]);
  };
  Object.defineProperties(Extent2, staticAccessors2);
  return Extent2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/constants.js
var SHOW_TOOLTIP2 = "showTooltip";
var HIDE_TOOLTIP2 = "hideTooltip";
var CENTER_CHANGE = "centerChange";
var ZOOM_CHANGE = "zoomChange";
var INIT = "init";

// node_modules/@progress/kendo-charts/dist/es/map/tooltip/tooltip.js
var Tooltip2 = function(Class) {
  function Tooltip3(widgetService, options) {
    Class.call(this);
    this.widgetService = widgetService;
    this.options = deepExtend({}, this.options, options);
    this.offset = { x: 0, y: 0 };
  }
  if (Class) Tooltip3.__proto__ = Class;
  Tooltip3.prototype = Object.create(Class && Class.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  var prototypeAccessors4 = { anchor: { configurable: true } };
  Tooltip3.prototype.show = function show2(anchor, args) {
    if (this.location === args.location) {
      return;
    }
    this.anchor = anchor;
    this.location = args.location;
    this.widgetService.notify(
      SHOW_TOOLTIP2,
      Object.assign({ anchor: this.anchor }, args)
    );
    this.visible = true;
  };
  Tooltip3.prototype.hide = function hide2() {
    if (this.widgetService) {
      this.widgetService.notify(HIDE_TOOLTIP2);
    }
    this.visible = false;
    this.location = null;
  };
  prototypeAccessors4.anchor.get = function() {
    return this._anchor;
  };
  prototypeAccessors4.anchor.set = function(anchor) {
    var documentPoint = this.widgetService.widget._toDocumentCoordinates({
      x: anchor.left - this.offset.x,
      y: anchor.top - this.offset.y
    });
    this._anchor = {
      left: documentPoint.left,
      top: documentPoint.top
    };
  };
  Tooltip3.prototype.destroy = function destroy() {
    this.widgetService = null;
  };
  Object.defineProperties(Tooltip3.prototype, prototypeAccessors4);
  return Tooltip3;
}(class_default);
setDefaultOptions(Tooltip2, {
  border: {
    width: 1
  },
  opacity: 1
});

// node_modules/@progress/kendo-charts/dist/es/map/layers/layer.js
var Layer = function(Class) {
  function Layer2(map3, options) {
    Class.call(this);
    this.support = getSupportedFeatures();
    this._initOptions(options);
    this.map = map3;
    var element = document.createElement("div");
    addClass(element, "k-layer");
    element.style.zIndex = this.options.zIndex;
    element.style.opacity = this.options.opacity;
    this.element = element;
    map3.scrollElement.appendChild(this.element);
    this._beforeReset = this._beforeReset.bind(this);
    this._reset = this._reset.bind(this);
    this._resize = this._resize.bind(this);
    this._panEnd = this._panEnd.bind(this);
    this._activate();
    this._updateAttribution();
  }
  if (Class) Layer2.__proto__ = Class;
  Layer2.prototype = Object.create(Class && Class.prototype);
  Layer2.prototype.constructor = Layer2;
  Layer2.prototype.destroy = function destroy() {
    this._deactivate();
  };
  Layer2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Layer2.prototype.show = function show2() {
    this.reset();
    this._activate();
    this._applyExtent(true);
  };
  Layer2.prototype.hide = function hide2() {
    this._deactivate();
    this._setVisibility(false);
  };
  Layer2.prototype.reset = function reset() {
    this._beforeReset();
    this._reset();
  };
  Layer2.prototype._reset = function _reset() {
    this._applyExtent();
  };
  Layer2.prototype._beforeReset = function _beforeReset() {
  };
  Layer2.prototype._resize = function _resize() {
  };
  Layer2.prototype._panEnd = function _panEnd() {
    this._applyExtent();
  };
  Layer2.prototype._applyExtent = function _applyExtent() {
    var options = this.options;
    var zoom = this.map.zoom();
    var matchMinZoom = !defined(options.minZoom) || zoom >= options.minZoom;
    var matchMaxZoom = !defined(options.maxZoom) || zoom <= options.maxZoom;
    var extent = Extent.create(options.extent);
    var inside = !extent || extent.overlaps(this.map.extent());
    this._setVisibility(matchMinZoom && matchMaxZoom && inside);
  };
  Layer2.prototype._setVisibility = function _setVisibility(visible) {
    this.element.style.display = visible ? "" : "none";
  };
  Layer2.prototype._activate = function _activate() {
    var map3 = this.map;
    this._deactivate();
    map3.bind("beforeReset", this._beforeReset);
    map3.bind("reset", this._reset);
    map3.bind("resize", this._resize);
    map3.bind("panEnd", this._panEnd);
  };
  Layer2.prototype._deactivate = function _deactivate() {
    var map3 = this.map;
    map3.unbind("beforeReset", this._beforeReset);
    map3.unbind("reset", this._reset);
    map3.unbind("resize", this._resize);
    map3.unbind("panEnd", this._panEnd);
  };
  Layer2.prototype._updateAttribution = function _updateAttribution() {
    var attribution = this.map.attribution;
    if (attribution) {
      attribution.add(this.options.attribution);
    }
  };
  Layer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  Layer2.prototype._hasData = function _hasData() {
    return this._data && this._data.length > 0;
  };
  Layer2.prototype._layerIndex = function _layerIndex() {
    var layers = this.map.layers || [];
    return layers.indexOf(this);
  };
  return Layer2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/tile.js
var math4 = Math;
var Point5 = geometry_exports.Point;
function compileTemplate(template) {
  if (isFunction(template)) {
    return template;
  }
  return template_service_default.compile(template);
}
function roundPoint(point) {
  return new Point5(round(point.x), round(point.y));
}
function renderSize(size) {
  var newSize = size;
  if (typeof size !== "string") {
    newSize += "px";
  }
  return newSize;
}
var TileLayer = function(Layer2) {
  function TileLayer2(map3, options) {
    Layer2.call(this, map3, options);
    if (typeof this.options.subdomains === "string") {
      this.options.subdomains = this.options.subdomains.split("");
    }
    var viewType = this._viewType();
    this._view = new viewType(this.element, this.options);
  }
  if (Layer2) TileLayer2.__proto__ = Layer2;
  TileLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  TileLayer2.prototype.constructor = TileLayer2;
  TileLayer2.prototype.destroy = function destroy() {
    Layer2.prototype.destroy.call(this);
    this._view.destroy();
    this._view = null;
  };
  TileLayer2.prototype._beforeReset = function _beforeReset() {
    var map3 = this.map;
    var origin = map3.locationToLayer(map3.extent().nw).round();
    this._view.viewOrigin(origin);
  };
  TileLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._updateView();
    this._view.reset();
  };
  TileLayer2.prototype._viewType = function _viewType() {
    return TileView;
  };
  TileLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    if (!this.support.mobileOS) {
      if (!this._pan) {
        this._pan = throttle(this._render.bind(this), 100);
      }
      this.map.bind("pan", this._pan);
    }
  };
  TileLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    if (this._pan) {
      this.map.unbind("pan", this._pan);
    }
  };
  TileLayer2.prototype._updateView = function _updateView() {
    var view = this._view, map3 = this.map, extent = map3.extent(), extentToPoint = {
      nw: map3.locationToLayer(extent.nw).round(),
      se: map3.locationToLayer(extent.se).round()
    };
    view.center(map3.locationToLayer(map3.center()));
    view.extent(extentToPoint);
    view.zoom(map3.zoom());
  };
  TileLayer2.prototype._resize = function _resize() {
    this._render();
  };
  TileLayer2.prototype._panEnd = function _panEnd(e39) {
    Layer2.prototype._panEnd.call(this, e39);
    this._render();
  };
  TileLayer2.prototype._render = function _render() {
    this._updateView();
    this._view.render();
  };
  return TileLayer2;
}(Layer);
setDefaultOptions(TileLayer, {
  tileSize: 256,
  subdomains: ["a", "b", "c"],
  urlTemplate: "",
  zIndex: 1
});
var TileView = function(Class) {
  function TileView2(element, options) {
    Class.call(this);
    this.element = element;
    this._initOptions(options);
    this.pool = new TilePool();
  }
  if (Class) TileView2.__proto__ = Class;
  TileView2.prototype = Object.create(Class && Class.prototype);
  TileView2.prototype.constructor = TileView2;
  TileView2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  TileView2.prototype.center = function center(center$1) {
    this._center = center$1;
  };
  TileView2.prototype.extent = function extent(extent$1) {
    this._extent = extent$1;
  };
  TileView2.prototype.viewOrigin = function viewOrigin(origin) {
    this._viewOrigin = origin;
  };
  TileView2.prototype.zoom = function zoom(zoom$1) {
    this._zoom = zoom$1;
  };
  TileView2.prototype.pointToTileIndex = function pointToTileIndex(point) {
    return new Point5(math4.floor(point.x / this.options.tileSize), math4.floor(point.y / this.options.tileSize));
  };
  TileView2.prototype.tileCount = function tileCount() {
    var size = this.size(), firstTileIndex = this.pointToTileIndex(this._extent.nw), nw = this._extent.nw, point = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);
    return {
      x: math4.ceil((math4.abs(point.x) + size.width) / this.options.tileSize),
      y: math4.ceil((math4.abs(point.y) + size.height) / this.options.tileSize)
    };
  };
  TileView2.prototype.size = function size() {
    var nw = this._extent.nw, se = this._extent.se, diff = se.clone().translate(-nw.x, -nw.y);
    return {
      width: diff.x,
      height: diff.y
    };
  };
  TileView2.prototype.indexToPoint = function indexToPoint(index) {
    var x5 = index.x, y = index.y;
    return new Point5(x5 * this.options.tileSize, y * this.options.tileSize);
  };
  TileView2.prototype.subdomainText = function subdomainText() {
    var subdomains = this.options.subdomains;
    return subdomains[this.subdomainIndex++ % subdomains.length];
  };
  TileView2.prototype.destroy = function destroy() {
    removeChildren(this.element);
    this.pool.empty();
  };
  TileView2.prototype.reset = function reset() {
    this.pool.reset();
    this.subdomainIndex = 0;
    this.render();
  };
  TileView2.prototype.render = function render() {
    var this$1 = this;
    var size = this.tileCount(), firstTileIndex = this.pointToTileIndex(this._extent.nw), tile, x5, y;
    for (x5 = 0; x5 < size.x; x5++) {
      for (y = 0; y < size.y; y++) {
        tile = this$1.createTile({
          x: firstTileIndex.x + x5,
          y: firstTileIndex.y + y
        });
        if (!tile.visible) {
          tile.show();
        }
      }
    }
  };
  TileView2.prototype.createTile = function createTile(currentIndex) {
    var options = this.tileOptions(currentIndex);
    var tile = this.pool.get(this._center, options);
    if (!tile.element.parentNode) {
      this.element.append(tile.element);
    }
    return tile;
  };
  TileView2.prototype.tileOptions = function tileOptions(currentIndex) {
    var index = this.wrapIndex(currentIndex), point = this.indexToPoint(currentIndex), origin = this._viewOrigin, offset = point.clone().translate(-origin.x, -origin.y);
    return {
      index,
      currentIndex,
      point,
      offset: roundPoint(offset),
      zoom: this._zoom,
      size: this.options.tileSize,
      subdomain: this.subdomainText(),
      urlTemplate: this.options.urlTemplate,
      errorUrlTemplate: this.options.errorUrlTemplate
    };
  };
  TileView2.prototype.wrapIndex = function wrapIndex(index) {
    var boundary = math4.pow(2, this._zoom);
    return {
      x: this.wrapValue(index.x, boundary),
      y: limitValue(index.y, 0, boundary - 1)
    };
  };
  TileView2.prototype.wrapValue = function wrapValue(value2, boundary) {
    var remainder = math4.abs(value2) % boundary;
    var wrappedValue = value2;
    if (value2 >= 0) {
      wrappedValue = remainder;
    } else {
      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);
    }
    return wrappedValue;
  };
  return TileView2;
}(class_default);
var ImageTile = function(Class) {
  function ImageTile2(id, options) {
    Class.call(this);
    this.id = id;
    this.visible = true;
    this._initOptions(options);
    this.createElement();
    this.show();
  }
  if (Class) ImageTile2.__proto__ = Class;
  ImageTile2.prototype = Object.create(Class && Class.prototype);
  ImageTile2.prototype.constructor = ImageTile2;
  ImageTile2.prototype.destroy = function destroy() {
    var element = this.element;
    var parentNode = element ? element.parentNode : null;
    if (element) {
      if (parentNode) {
        parentNode.removeChild(element);
      }
      this.element = null;
    }
  };
  ImageTile2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  ImageTile2.prototype.createElement = function createElement93() {
    var el = document.createElement("img");
    var size = this.options.size + "px";
    el.setAttribute("alt", "");
    el.style.position = "absolute";
    el.style.display = "block";
    el.style.width = el.style.maxWidth = size;
    el.style.height = el.style.maxHeight = size;
    this.element = el;
  };
  ImageTile2.prototype.show = function show2() {
    var element = this.element;
    element.style.top = renderSize(this.options.offset.y);
    element.style.left = renderSize(this.options.offset.x);
    var url = this.url();
    if (url) {
      element.setAttribute("src", url);
    }
    element.style.visibility = "visible";
    this.visible = true;
  };
  ImageTile2.prototype.hide = function hide2() {
    this.element.style.visibility = "hidden";
    this.visible = false;
  };
  ImageTile2.prototype.url = function url() {
    var urlResult = compileTemplate(this.options.urlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.errorUrl = function errorUrl() {
    var urlResult = compileTemplate(this.options.errorUrlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.urlOptions = function urlOptions() {
    var options = this.options;
    return {
      zoom: options.zoom,
      subdomain: options.subdomain,
      z: options.zoom,
      x: options.index.x,
      y: options.index.y,
      s: options.subdomain,
      quadkey: options.quadkey,
      q: options.quadkey,
      culture: options.culture,
      c: options.culture
    };
  };
  return ImageTile2;
}(class_default);
setDefaultOptions(ImageTile, {
  urlTemplate: "",
  errorUrlTemplate: ""
});
var TilePool = function(Class) {
  function TilePool2() {
    Class.call(this);
    this._items = [];
  }
  if (Class) TilePool2.__proto__ = Class;
  TilePool2.prototype = Object.create(Class && Class.prototype);
  TilePool2.prototype.constructor = TilePool2;
  TilePool2.prototype.get = function get3(center, options) {
    if (this._items.length >= this.options.maxSize) {
      this._remove(center);
    }
    return this._create(options);
  };
  TilePool2.prototype.empty = function empty() {
    var items = this._items;
    for (var i36 = 0; i36 < items.length; i36++) {
      items[i36].destroy();
    }
    this._items = [];
  };
  TilePool2.prototype.reset = function reset() {
    var items = this._items;
    for (var i36 = 0; i36 < items.length; i36++) {
      items[i36].hide();
    }
  };
  TilePool2.prototype._create = function _create(options) {
    var items = this._items;
    var tile;
    var id = hashKey(options.point.toString() + options.offset.toString() + options.zoom + options.urlTemplate);
    for (var i36 = 0; i36 < items.length; i36++) {
      if (items[i36].id === id) {
        tile = items[i36];
        break;
      }
    }
    if (tile) {
      tile.show();
    } else {
      tile = new ImageTile(id, options);
      this._items.push(tile);
    }
    return tile;
  };
  TilePool2.prototype._remove = function _remove(center) {
    var items = this._items;
    var maxDist = -1;
    var index = -1;
    for (var i36 = 0; i36 < items.length; i36++) {
      var dist = items[i36].options.point.distanceTo(center);
      if (dist > maxDist && !items[i36].visible) {
        index = i36;
        maxDist = dist;
      }
    }
    if (index !== -1) {
      items[index].destroy();
      items.splice(index, 1);
    }
  };
  return TilePool2;
}(class_default);
setDefaultOptions(TilePool, {
  maxSize: 100
});

// node_modules/@progress/kendo-charts/dist/es/map/scroller/draggable.js
var extend11 = Object.assign;
var CHANGE2 = "change";
var TapCapture = function(Observable2) {
  function TapCapture2(element, options) {
    Observable2.call(this);
    var that = this, domElement = element[0] || element;
    that.capture = false;
    if (domElement.addEventListener) {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._press, that), true);
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._release, that), true);
      });
    } else {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._press, that));
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._release, that));
      });
    }
    that.bind([
      "press",
      "release"
    ], options || {});
  }
  if (Observable2) TapCapture2.__proto__ = Observable2;
  TapCapture2.prototype = Object.create(Observable2 && Observable2.prototype);
  TapCapture2.prototype.constructor = TapCapture2;
  TapCapture2.prototype.captureNext = function captureNext() {
    this.capture = true;
  };
  TapCapture2.prototype.cancelCapture = function cancelCapture() {
    this.capture = false;
  };
  TapCapture2.prototype._press = function _press(e39) {
    var that = this;
    that.trigger("press");
    if (that.capture) {
      e39.preventDefault();
    }
  };
  TapCapture2.prototype._release = function _release(e39) {
    var that = this;
    that.trigger("release");
    if (that.capture) {
      e39.preventDefault();
      that.cancelCapture();
    }
  };
  return TapCapture2;
}(observable_default);
var PaneDimension = function(Observable2) {
  function PaneDimension2(options) {
    Observable2.call(this);
    var that = this;
    that.forcedEnabled = false;
    extend11(that, options);
    that.scale = 1;
    if (that.horizontal) {
      that.measure = "offsetWidth";
      that.scrollSize = "scrollWidth";
      that.axis = "x";
    } else {
      that.measure = "offsetHeight";
      that.scrollSize = "scrollHeight";
      that.axis = "y";
    }
  }
  if (Observable2) PaneDimension2.__proto__ = Observable2;
  PaneDimension2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneDimension2.prototype.constructor = PaneDimension2;
  PaneDimension2.prototype.makeVirtual = function makeVirtual() {
    extend11(this, {
      virtual: true,
      forcedEnabled: true,
      _virtualMin: 0,
      _virtualMax: 0
    });
  };
  PaneDimension2.prototype.virtualSize = function virtualSize(min4, max3) {
    if (this._virtualMin !== min4 || this._virtualMax !== max3) {
      this._virtualMin = min4;
      this._virtualMax = max3;
      this.update();
    }
  };
  PaneDimension2.prototype.outOfBounds = function outOfBounds(offset) {
    return offset > this.max || offset < this.min;
  };
  PaneDimension2.prototype.forceEnabled = function forceEnabled() {
    this.forcedEnabled = true;
  };
  PaneDimension2.prototype.getSize = function getSize() {
    return this.container[this.measure];
  };
  PaneDimension2.prototype.getTotal = function getTotal() {
    return this.element[this.scrollSize];
  };
  PaneDimension2.prototype.rescale = function rescale(scale) {
    this.scale = scale;
  };
  PaneDimension2.prototype.update = function update(silent) {
    var that = this, total3 = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total3 * that.scale, size = that.getSize();
    if (total3 === 0 && !that.forcedEnabled) {
      return;
    }
    that.max = that.virtual ? -that._virtualMin : 0;
    that.size = size;
    that.total = scaledTotal;
    that.min = Math.min(that.max, size - scaledTotal);
    that.minScale = size / total3;
    that.centerOffset = (scaledTotal - size) / 2;
    that.enabled = that.forcedEnabled || scaledTotal > size;
    if (!silent) {
      that.trigger(CHANGE2, that);
    }
  };
  return PaneDimension2;
}(observable_default);
var PaneDimensions = function(Observable2) {
  function PaneDimensions2(options) {
    Observable2.call(this);
    var that = this;
    that.x = new PaneDimension(extend11({
      horizontal: true
    }, options));
    that.y = new PaneDimension(extend11({
      horizontal: false
    }, options));
    that.container = options.container;
    that.forcedMinScale = options.minScale;
    that.maxScale = options.maxScale || 100;
    that.bind(CHANGE2, options);
  }
  if (Observable2) PaneDimensions2.__proto__ = Observable2;
  PaneDimensions2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneDimensions2.prototype.constructor = PaneDimensions2;
  PaneDimensions2.prototype.rescale = function rescale(newScale) {
    this.x.rescale(newScale);
    this.y.rescale(newScale);
    this.refresh();
  };
  PaneDimensions2.prototype.centerCoordinates = function centerCoordinates() {
    return {
      x: Math.min(0, -this.x.centerOffset),
      y: Math.min(0, -this.y.centerOffset)
    };
  };
  PaneDimensions2.prototype.refresh = function refresh() {
    var that = this;
    that.x.update();
    that.y.update();
    that.enabled = that.x.enabled || that.y.enabled;
    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
    that.fitScale = Math.max(that.x.minScale, that.y.minScale);
    that.trigger(CHANGE2);
  };
  return PaneDimensions2;
}(observable_default);
var PaneAxis = function(Observable2) {
  function PaneAxis2(options) {
    Observable2.call(this);
    extend11(this, options);
  }
  if (Observable2) PaneAxis2.__proto__ = Observable2;
  PaneAxis2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneAxis2.prototype.constructor = PaneAxis2;
  PaneAxis2.prototype.outOfBounds = function outOfBounds() {
    return this.dimension.outOfBounds(this.movable[this.axis]);
  };
  PaneAxis2.prototype.dragMove = function dragMove(delta) {
    var that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position = movable[axis] + delta;
    if (!dimension.enabled) {
      return;
    }
    var dragDelta = delta;
    if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {
      dragDelta *= that.resistance;
    }
    movable.translateAxis(axis, dragDelta);
    that.trigger(CHANGE2, that);
  };
  return PaneAxis2;
}(observable_default);
var Pane2 = function(Class) {
  function Pane3(options) {
    Class.call(this);
    var that = this, x5, y, resistance, movable;
    extend11(that, {
      elastic: true
    }, options);
    resistance = that.elastic ? 0.5 : 0;
    movable = that.movable;
    that.x = x5 = new PaneAxis({
      axis: "x",
      dimension: that.dimensions.x,
      resistance,
      movable
    });
    that.y = y = new PaneAxis({
      axis: "y",
      dimension: that.dimensions.y,
      resistance,
      movable
    });
    that.userEvents.bind([
      "press",
      "move",
      "end",
      "gesturestart",
      "gesturechange"
    ], {
      gesturestart: function gesturestart(e39) {
        that.gesture = e39;
        that.offset = elementOffset(that.dimensions.container);
      },
      press: function press(e39) {
        var closestAnchor = e39.event.target.closest("a");
        if (closestAnchor && closestAnchor.matches("[data-navigate-on-press=true]")) {
          e39.sender.cancel();
        }
      },
      gesturechange: function gesturechange(e39) {
        var previousGesture = that.gesture, previousCenter = previousGesture.center, center = e39.center, scaleDelta = e39.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
        if (movable.scale <= minScale && scaleDelta < 1) {
          scaleDelta += (1 - scaleDelta) * 0.8;
        }
        if (movable.scale * scaleDelta >= maxScale) {
          scaleDelta = maxScale / movable.scale;
        }
        var offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
        coordinates = {
          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
        };
        movable.scaleWith(scaleDelta);
        x5.dragMove(coordinates.x);
        y.dragMove(coordinates.y);
        that.dimensions.rescale(movable.scale);
        that.gesture = e39;
        e39.preventDefault();
      },
      move: function move(e39) {
        if (e39.event.target.tagName.match(/textarea|input/i)) {
          return;
        }
        if (x5.dimension.enabled || y.dimension.enabled) {
          x5.dragMove(e39.x.delta);
          y.dragMove(e39.y.delta);
          e39.preventDefault();
        } else {
          e39.touch.skip();
        }
      },
      end: function end(e39) {
        e39.preventDefault();
      }
    });
  }
  if (Class) Pane3.__proto__ = Class;
  Pane3.prototype = Object.create(Class && Class.prototype);
  Pane3.prototype.constructor = Pane3;
  return Pane3;
}(class_default);
var translate = function(x5, y, scale) {
  return "translate3d(" + x5 + "px," + y + "px,0) scale(" + scale + ")";
};
var Movable = function(Observable2) {
  function Movable2(element) {
    Observable2.call(this);
    var that = this;
    that.element = element;
    that.element.style.transformOrigin = "left top";
    that.x = 0;
    that.y = 0;
    that.scale = 1;
    var coordinates = translate(that.x, that.y, that.scale);
    that.element.style.transform = coordinates;
    that._saveCoordinates(coordinates);
  }
  if (Observable2) Movable2.__proto__ = Observable2;
  Movable2.prototype = Object.create(Observable2 && Observable2.prototype);
  Movable2.prototype.constructor = Movable2;
  Movable2.prototype.translateAxis = function translateAxis(axis, by) {
    this[axis] += by;
    this.refresh();
  };
  Movable2.prototype.scaleTo = function scaleTo(scale) {
    this.scale = scale;
    this.refresh();
  };
  Movable2.prototype.scaleWith = function scaleWith(scaleDelta) {
    this.scale *= scaleDelta;
    this.refresh();
  };
  Movable2.prototype.translate = function translate2(coordinates) {
    this.x += coordinates.x;
    this.y += coordinates.y;
    this.refresh();
  };
  Movable2.prototype.moveAxis = function moveAxis(axis, value2) {
    this[axis] = value2;
    this.refresh();
  };
  Movable2.prototype.moveTo = function moveTo(coordinates) {
    extend11(this, coordinates);
    this.refresh();
  };
  Movable2.prototype.refresh = function refresh() {
    var that = this, x5 = that.x, y = that.y, newCoordinates;
    if (that.round) {
      x5 = Math.round(x5);
      y = Math.round(y);
    }
    newCoordinates = translate(x5, y, that.scale);
    if (newCoordinates !== that.coordinates) {
      that.element.style.transform = newCoordinates;
      that._saveCoordinates(newCoordinates);
      that.trigger(CHANGE2);
    }
  };
  Movable2.prototype._saveCoordinates = function _saveCoordinates(coordinates) {
    this.coordinates = coordinates;
  };
  return Movable2;
}(observable_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/shape.js
var Group8 = drawing_exports.Group;
var ShapeLayer = function(Layer2) {
  function ShapeLayer2(map3, options) {
    Layer2.call(this, map3, options);
    this._pan = proxy(this._pan, this);
    this.surface = drawing_exports.Surface.create(this.element, {
      width: map3.scrollElement.clientWidth,
      height: map3.scrollElement.clientHeight
    });
    this._initRoot();
    this.movable = new Movable(this.surface.element);
    this._markers = [];
    this._click = this._handler("shapeClick");
    this.surface.bind("click", this._click);
    this._mouseleave = this._handler("shapeMouseLeave");
    this.surface.bind("mouseleave", this._mouseleave);
    this.surface.bind("mouseenter", this._mouseenter.bind(this));
  }
  if (Layer2) ShapeLayer2.__proto__ = Layer2;
  ShapeLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  ShapeLayer2.prototype.constructor = ShapeLayer2;
  ShapeLayer2.prototype.destroy = function destroy() {
    Layer2.prototype.destroy.call(this);
    this.surface.destroy();
  };
  ShapeLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._translateSurface();
    this._data = this._readData();
    if (this._hasData()) {
      this._load(this._data);
    }
  };
  ShapeLayer2.prototype._initRoot = function _initRoot() {
    this._root = new Group8();
    this.surface.draw(this._root);
  };
  ShapeLayer2.prototype._beforeReset = function _beforeReset() {
    this.surface.clear();
    this._initRoot();
  };
  ShapeLayer2.prototype._resize = function _resize() {
    this.surface.size(this.map.size());
  };
  ShapeLayer2.prototype._readData = function _readData() {
    var data = Layer2.prototype._readData.call(this);
    if (data.type === "FeatureCollection") {
      return data.features;
    }
    if (data.type === "GeometryCollection") {
      return data.geometries;
    }
    return data;
  };
  ShapeLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this._clearMarkers();
    if (!this._loader) {
      this._loader = new GeoJsonLoader(this.map, this.options.style, this);
    }
    var container = new Group8();
    for (var i36 = 0; i36 < data.length; i36++) {
      var shape = this$1._loader.parse(data[i36]);
      if (shape) {
        container.append(shape);
      }
    }
    this._root.clear();
    this._root.append(container);
  };
  ShapeLayer2.prototype.shapeCreated = function shapeCreated(shape) {
    var cancelled = false;
    if (shape instanceof drawing_exports.Circle && this.map.options.renderPointsAsMarkers) {
      cancelled = defined(this._createMarker(shape));
    }
    if (!cancelled) {
      var args = {
        layer: this,
        shape
      };
      cancelled = this.map.trigger("shapeCreated", args);
    }
    return cancelled;
  };
  ShapeLayer2.prototype.featureCreated = function featureCreated(e39) {
    e39.layer = this;
    this.map.trigger("shapeFeatureCreated", e39);
  };
  ShapeLayer2.prototype._createMarker = function _createMarker(shape) {
    var marker = this.map.markers.bind({
      location: shape.location
    }, shape.dataItem);
    if (marker) {
      this._markers.push(marker);
    }
    return marker;
  };
  ShapeLayer2.prototype._clearMarkers = function _clearMarkers() {
    var this$1 = this;
    for (var i36 = 0; i36 < this._markers.length; i36++) {
      this$1.map.markers.remove(this$1._markers[i36]);
    }
    this._markers = [];
  };
  ShapeLayer2.prototype._pan = function _pan() {
    if (!this._panning) {
      this._panning = true;
      this.surface.suspendTracking();
    }
  };
  ShapeLayer2.prototype._panEnd = function _panEnd(e39) {
    Layer2.prototype._panEnd.call(this, e39);
    this._translateSurface();
    this.surface.resumeTracking();
    this._panning = false;
  };
  ShapeLayer2.prototype._translateSurface = function _translateSurface() {
    var map3 = this.map;
    var nw = map3.locationToView(map3.extent().nw);
    if (this.surface.translate) {
      this.surface.translate(nw);
      this.movable.moveTo({
        x: nw.x,
        y: nw.y
      });
    }
  };
  ShapeLayer2.prototype._eventArgs = function _eventArgs(e39) {
    return {
      layer: this,
      layerIndex: this._layerIndex(),
      shape: e39.element,
      shapeIndex: (this._data || []).indexOf(e39.element.dataItem),
      originalEvent: e39.originalEvent
    };
  };
  ShapeLayer2.prototype._handler = function _handler(eventName) {
    var this$1 = this;
    return function(e39) {
      if (e39.element) {
        this$1.map.trigger(eventName, this$1._eventArgs(e39));
      }
    };
  };
  ShapeLayer2.prototype._mouseenter = function _mouseenter(e39) {
    if (!e39.element) {
      return;
    }
    this.map.trigger("shapeMouseEnter", this._eventArgs(e39));
    var shape = e39.element;
    var anchor = this._tooltipAnchor(e39);
    this.map._tooltip.show(anchor, this._tooltipContext(shape));
  };
  ShapeLayer2.prototype._tooltipContext = function _tooltipContext(shape) {
    return {
      type: "shape",
      layerIndex: this._layerIndex(),
      className: "k-map-shape-tooltip",
      dataItem: shape.dataItem,
      location: shape.location
    };
  };
  ShapeLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e39) {
    var cursor = this.map.eventOffset(e39.originalEvent);
    return {
      top: cursor.y,
      left: cursor.x
    };
  };
  ShapeLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    this._panHandler = proxy(this._pan, this);
    this.map.bind("pan", this.panHandler);
  };
  ShapeLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    this.map.unbind("pan", this._panHandler);
  };
  return ShapeLayer2;
}(Layer);
setDefaultOptions(ShapeLayer, {
  autoBind: true,
  zIndex: 100
});
var GeoJsonLoader = function(Class) {
  function GeoJsonLoader2(locator, defaultStyle, observer) {
    Class.call(this);
    this.observer = observer;
    this.locator = locator;
    this.style = defaultStyle;
  }
  if (Class) GeoJsonLoader2.__proto__ = Class;
  GeoJsonLoader2.prototype = Object.create(Class && Class.prototype);
  GeoJsonLoader2.prototype.constructor = GeoJsonLoader2;
  GeoJsonLoader2.prototype.parse = function parse(item) {
    var root = new Group8();
    var unwrap = true;
    if (item.type === "Feature") {
      unwrap = false;
      this._loadGeometryTo(root, item.geometry, item);
      this._featureCreated(root, item);
    } else {
      this._loadGeometryTo(root, item, item);
    }
    if (unwrap && root.children.length < 2) {
      root = root.children[0];
    }
    return root;
  };
  GeoJsonLoader2.prototype._shapeCreated = function _shapeCreated(shape) {
    var cancelled = false;
    if (this.observer && this.observer.shapeCreated) {
      cancelled = this.observer.shapeCreated(shape);
    }
    return cancelled;
  };
  GeoJsonLoader2.prototype._featureCreated = function _featureCreated(group, dataItem) {
    if (this.observer && this.observer.featureCreated) {
      this.observer.featureCreated({
        group,
        dataItem,
        properties: dataItem.properties
      });
    }
  };
  GeoJsonLoader2.prototype._loadGeometryTo = function _loadGeometryTo(container, geometry, dataItem) {
    var this$1 = this;
    var coords = geometry.coordinates;
    var i36;
    var path;
    switch (geometry.type) {
      case "LineString":
        path = this._loadPolygon(container, [coords], dataItem);
        this._setLineFill(path);
        break;
      case "MultiLineString":
        for (i36 = 0; i36 < coords.length; i36++) {
          path = this$1._loadPolygon(container, [coords[i36]], dataItem);
          this$1._setLineFill(path);
        }
        break;
      case "Polygon":
        this._loadPolygon(container, coords, dataItem);
        break;
      case "MultiPolygon":
        for (i36 = 0; i36 < coords.length; i36++) {
          this$1._loadPolygon(container, coords[i36], dataItem);
        }
        break;
      case "Point":
        this._loadPoint(container, coords, dataItem);
        break;
      case "MultiPoint":
        for (i36 = 0; i36 < coords.length; i36++) {
          this$1._loadPoint(container, coords[i36], dataItem);
        }
        break;
      default:
        break;
    }
  };
  GeoJsonLoader2.prototype._setLineFill = function _setLineFill(path) {
    var segments = path.segments;
    if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {
      path.options.fill = null;
    }
  };
  GeoJsonLoader2.prototype._loadShape = function _loadShape(container, shape) {
    if (!this._shapeCreated(shape)) {
      container.append(shape);
    }
    return shape;
  };
  GeoJsonLoader2.prototype._loadPolygon = function _loadPolygon(container, rings, dataItem) {
    var shape = this._buildPolygon(rings);
    shape.dataItem = dataItem;
    shape.location = this.locator.viewToLocation(shape.bbox().center());
    return this._loadShape(container, shape);
  };
  GeoJsonLoader2.prototype._buildPolygon = function _buildPolygon(rings) {
    var this$1 = this;
    var type = rings.length > 1 ? drawing_exports.MultiPath : drawing_exports.Path;
    var path = new type(this.style);
    for (var i36 = 0; i36 < rings.length; i36++) {
      for (var j2 = 0; j2 < rings[i36].length; j2++) {
        var point = this$1.locator.locationToView(Location.fromLngLat(rings[i36][j2]));
        if (j2 === 0) {
          path.moveTo(point.x, point.y);
        } else {
          path.lineTo(point.x, point.y);
        }
      }
    }
    return path;
  };
  GeoJsonLoader2.prototype._loadPoint = function _loadPoint(container, coords, dataItem) {
    var location = Location.fromLngLat(coords);
    var point = this.locator.locationToView(location);
    var circle = new geometry_exports.Circle(point, 10);
    var shape = new drawing_exports.Circle(circle, this.style);
    shape.dataItem = dataItem;
    shape.location = location;
    return this._loadShape(container, shape);
  };
  return GeoJsonLoader2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/bubble.js
var BubbleLayer = function(ShapeLayer2) {
  function BubbleLayer2() {
    ShapeLayer2.apply(this, arguments);
  }
  if (ShapeLayer2) BubbleLayer2.__proto__ = ShapeLayer2;
  BubbleLayer2.prototype = Object.create(ShapeLayer2 && ShapeLayer2.prototype);
  BubbleLayer2.prototype.constructor = BubbleLayer2;
  BubbleLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  BubbleLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.surface.clear();
    if (data.length === 0) {
      return;
    }
    var options = this.options;
    var getValue = getter(options.valueField);
    var newData = data.slice(0);
    newData.sort(function(a38, b2) {
      return getValue(b2) - getValue(a38);
    });
    var scaleType = this._scaleType();
    var scale;
    var getLocation = getter(this.options.locationField);
    for (var i36 = 0; i36 < newData.length; i36++) {
      var dataItem = newData[i36];
      var location = getLocation(dataItem);
      var value2 = getValue(dataItem);
      if (defined(location) && defined(value2)) {
        if (!scale) {
          scale = new scaleType([
            0,
            value2
          ], [
            options.minSize,
            options.maxSize
          ]);
        }
        location = Location.create(location);
        var center = this$1.map.locationToView(location);
        var size = scale.map(value2);
        var symbol = this$1._createSymbol({
          center,
          size,
          style: options.style,
          dataItem,
          location
        });
        symbol.dataItem = dataItem;
        symbol.location = location;
        symbol.value = value2;
        this$1._drawSymbol(symbol);
      }
    }
  };
  BubbleLayer2.prototype._scaleType = function _scaleType() {
    var scale = this.options.scale;
    if (isFunction(scale)) {
      return scale;
    }
    return Scales[scale];
  };
  BubbleLayer2.prototype._createSymbol = function _createSymbol(args) {
    var symbol = this.options.symbol;
    if (!isFunction(symbol)) {
      symbol = Symbols[symbol];
    }
    return symbol(args);
  };
  BubbleLayer2.prototype._drawSymbol = function _drawSymbol(shape) {
    var args = {
      layer: this,
      shape
    };
    var cancelled = this.map.trigger("shapeCreated", args);
    if (!cancelled) {
      this.surface.draw(shape);
    }
  };
  BubbleLayer2.prototype._tooltipContext = function _tooltipContext(shape) {
    return {
      type: "bubble",
      layerIndex: this._layerIndex(),
      className: "k-map-bubble-tooltip",
      dataItem: shape.dataItem,
      location: shape.location,
      value: shape.value
    };
  };
  BubbleLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e39) {
    var shape = e39.element;
    var center = shape.bbox().center();
    return {
      top: center.y,
      left: center.x
    };
  };
  return BubbleLayer2;
}(ShapeLayer);
setDefaultOptions(BubbleLayer, {
  // autoBind: true,
  locationField: "location",
  valueField: "value",
  minSize: 0,
  maxSize: 100,
  scale: "sqrt",
  symbol: "circle",
  // ensure bubble layers are displayed over tile and shape layers
  zIndex: 200
});
var SqrtScale = function(Class) {
  function SqrtScale2(domain, range) {
    Class.call(this);
    this._domain = domain;
    this._range = range;
    var domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);
    var outputRange = range[1] - range[0];
    this._ratio = outputRange / domainRange;
  }
  if (Class) SqrtScale2.__proto__ = Class;
  SqrtScale2.prototype = Object.create(Class && Class.prototype);
  SqrtScale2.prototype.constructor = SqrtScale2;
  SqrtScale2.prototype.map = function map3(value2) {
    var rel = (Math.sqrt(value2) - Math.sqrt(this._domain[0])) * this._ratio;
    return this._range[0] + rel;
  };
  return SqrtScale2;
}(class_default);
var Scales = {
  sqrt: SqrtScale
};
var Symbols = {
  circle: function(args) {
    var geo = new geometry_exports.Circle(args.center, args.size / 2);
    return new drawing_exports.Circle(geo, args.style);
  },
  square: function(args) {
    var path = new drawing_exports.Path(args.style);
    var halfSize = args.size / 2;
    var center = args.center;
    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();
    return path;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/marker.js
var CLICK = "click";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var extend12 = Object.assign;
var MARKER_CLASS_NAME = "k-marker";
var MARKER_CLASS = "." + MARKER_CLASS_NAME;
var MarkerLayer = function(Layer2) {
  function MarkerLayer2(map3, options) {
    Layer2.call(this, map3, options);
    this._markerClickHandler = proxy(this._markerClick, this);
    on(this.element, CLICK, MARKER_CLASS, this._markerClickHandler);
    this.items = [];
    this._load(this._readData());
  }
  if (Layer2) MarkerLayer2.__proto__ = Layer2;
  MarkerLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  MarkerLayer2.prototype.constructor = MarkerLayer2;
  MarkerLayer2.prototype.destroy = function destroy() {
    Layer2.prototype.destroy.call(this);
    off(this.element, CLICK, this._markerClickHandler);
    this.clear();
  };
  MarkerLayer2.prototype.add = function add3(args) {
    var this$1 = this;
    if (isArray(args)) {
      for (var i36 = 0; i36 < args.length; i36++) {
        this$1._addOne(args[i36]);
      }
    } else {
      return this._addOne(args);
    }
  };
  MarkerLayer2.prototype.remove = function remove(marker) {
    marker.destroy();
    var index = (this.items || []).indexOf(marker);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  };
  MarkerLayer2.prototype.clear = function clear3() {
    var this$1 = this;
    for (var i36 = 0; i36 < this.items.length; i36++) {
      this$1.items[i36].destroy();
    }
    this.items = [];
  };
  MarkerLayer2.prototype.update = function update(marker) {
    var location = marker.location();
    if (location) {
      marker.showAt(this.map.locationToView(location));
      var args = {
        marker,
        layer: this
      };
      this.map.trigger("markerActivate", args);
    }
  };
  MarkerLayer2.prototype._reset = function _reset() {
    var this$1 = this;
    Layer2.prototype._reset.call(this);
    var items = this.items;
    for (var i36 = 0; i36 < items.length; i36++) {
      this$1.update(items[i36]);
    }
  };
  MarkerLayer2.prototype.bind = function bind(options, dataItem) {
    var marker = Marker.create(options, this.options);
    marker.dataItem = dataItem;
    var args = {
      marker,
      layer: this
    };
    var cancelled = this.map.trigger("markerCreated", args);
    if (!cancelled) {
      this.add(marker);
      return marker;
    }
  };
  MarkerLayer2.prototype._addOne = function _addOne(arg) {
    var marker = Marker.create(arg, this.options);
    marker.addTo(this);
    return marker;
  };
  MarkerLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  MarkerLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.clear();
    var getLocation = getter(this.options.locationField);
    var getTitle = getter(this.options.titleField);
    for (var i36 = 0; i36 < data.length; i36++) {
      var dataItem = data[i36];
      this$1.bind({
        location: getLocation(dataItem),
        title: getTitle(dataItem)
      }, dataItem);
    }
  };
  MarkerLayer2.prototype._markerClick = function _markerClick(e39) {
    var marker = e39.currentTarget._kendoNode;
    var args = {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker),
      originalEvent: e39
    };
    this.map.trigger("markerClick", args);
  };
  MarkerLayer2.prototype._markerMouseEnter = function _markerMouseEnter(e39) {
    var args = this._createMarkerEventArgs(e39);
    this.map.trigger("markerMouseEnter", args);
  };
  MarkerLayer2.prototype._markerMouseLeave = function _markerMouseLeave(e39) {
    var args = this._createMarkerEventArgs(e39);
    this.map.trigger("markerMouseLeave", args);
  };
  MarkerLayer2.prototype._createMarkerEventArgs = function _createMarkerEventArgs(e39) {
    var marker = e39.marker;
    var args = extend12({}, {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker)
    }, e39);
    return args;
  };
  return MarkerLayer2;
}(Layer);
setDefaultOptions(MarkerLayer, {
  zIndex: 1e3,
  autoBind: true,
  locationField: "location",
  titleField: "title",
  template: ""
});
var Marker = function(Class) {
  function Marker2(options) {
    Class.call(this);
    this.options = options || {};
  }
  if (Class) Marker2.__proto__ = Class;
  Marker2.prototype = Object.create(Class && Class.prototype);
  Marker2.prototype.constructor = Marker2;
  Marker2.prototype.destroy = function destroy() {
    this.layer = null;
    this.unbindEvents();
    this.hide();
  };
  Marker2.prototype.addTo = function addTo(parent) {
    this.layer = parent.markers || parent;
    this.layer.items.push(this);
    this.layer.update(this);
  };
  Marker2.prototype.location = function location(value2) {
    if (value2) {
      this.options.location = Location.create(value2).toArray();
      if (this.layer) {
        this.layer.update(this);
      }
      return this;
    }
    return Location.create(this.options.location);
  };
  Marker2.prototype.showAt = function showAt(point) {
    this.render();
    this._anchor = { left: Math.round(point.x), top: Math.round(point.y) };
    this.element.style.left = toPixels(this._anchor.left);
    this.element.style.top = toPixels(this._anchor.top);
  };
  Marker2.prototype.hide = function hide2() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  };
  Marker2.prototype.bindEvents = function bindEvents2() {
    if (!this.element) {
      return;
    }
    this._mouseEnterHandler = proxy(this._mouseEnter, this);
    on(this.element, MOUSE_ENTER, MARKER_CLASS, this._mouseEnterHandler);
    this._mouseLeaveHandler = proxy(this._mouseLeave, this);
    on(this.element, MOUSE_LEAVE, MARKER_CLASS, this._mouseLeaveHandler);
  };
  Marker2.prototype.unbindEvents = function unbindEvents2() {
    if (!this.element) {
      return;
    }
    off(this.element, MOUSE_ENTER, this._mouseEnterHandler);
    off(this.element, MOUSE_LEAVE, this._mouseLeaveHandler);
  };
  Marker2.prototype.render = function render() {
    if (!this.element) {
      var options = this.options;
      var layer = this.layer;
      var element = document.createElement("span");
      addClass(element, MARKER_CLASS_NAME);
      if (this.options.template) {
        var templateFn = this._compileTemplate(this.options.template);
        var templateHtml = templateFn(this.dataItem);
        var templateElement = convertToHtml(templateHtml);
        element.appendChild(templateElement);
      } else if (options.svgIcon) {
        renderIcon(element, { icon: options.svgIcon, iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: "svg" });
      } else {
        var iconOptions = { icon: "map-marker", iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: this.options.icons.type };
        if (options.shape) {
          if (options.shape === "pinTarget") {
            iconOptions.icon = "map-marker-target";
            renderIcon(element, iconOptions);
          } else if (options.shape === "pin") {
            renderIcon(element, iconOptions);
          } else {
            addClass(element, "k-icon k-icon-xxl k-i-marker-" + toHyphens(options.shape || "pin"));
          }
        } else {
          renderIcon(element, iconOptions);
        }
      }
      if (options.title) {
        element.setAttribute("title", options.title);
      }
      var attributes = options.attributes || {};
      Object.keys(attributes).forEach(function(key) {
        element.setAttribute(key, attributes[key]);
      });
      element._kendoNode = this;
      element.style.zIndex = options.zIndex;
      this.element = element;
      if (layer) {
        layer.element.appendChild(this.element);
      }
      this.bindEvents();
    }
  };
  Marker2.prototype._mouseEnter = function _mouseEnter(e39) {
    var args = this._createEventArgs(e39);
    this.layer._markerMouseEnter(args);
    this.layer.map._tooltip.show({
      top: this._anchor.top - this.element.offsetHeight,
      left: this._anchor.left
    }, this._tooltipContext());
  };
  Marker2.prototype._tooltipContext = function _tooltipContext() {
    return {
      type: "marker",
      layerIndex: this.layer._layerIndex(),
      className: "k-map-marker-tooltip",
      dataItem: this.dataItem,
      title: this.options.title,
      location: this.location()
    };
  };
  Marker2.prototype._mouseLeave = function _mouseLeave(e39) {
    var args = this._createEventArgs(e39);
    this.layer._markerMouseLeave(args);
  };
  Marker2.prototype._createEventArgs = function _createEventArgs(e39) {
    var args = {
      marker: this,
      originalEvent: e39
    };
    return args;
  };
  Marker2.prototype._compileTemplate = function _compileTemplate(template) {
    return template_service_default.compile(template, {
      paramName: "dataItem",
      useWithBlock: false
    });
  };
  Marker2.create = function create2(arg, defaults) {
    if (arg instanceof Marker2) {
      return arg;
    }
    return new Marker2(deepExtend({}, defaults, arg));
  };
  return Marker2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/fx.js
var extend13 = Object.assign;
function animationFrame(callback) {
  window.requestAnimationFrame(callback);
}
var Animation = function(Class) {
  function Animation2() {
    Class.call(this);
    var that = this;
    that._tickProxy = proxy(that._tick, that);
    that._started = false;
  }
  if (Class) Animation2.__proto__ = Class;
  Animation2.prototype = Object.create(Class && Class.prototype);
  Animation2.prototype.constructor = Animation2;
  Animation2.prototype.tick = function tick() {
  };
  Animation2.prototype.done = function done() {
  };
  Animation2.prototype.onEnd = function onEnd() {
  };
  Animation2.prototype.onCancel = function onCancel() {
  };
  Animation2.prototype.start = function start() {
    if (!this.enabled()) {
      return;
    }
    if (!this.done()) {
      this._started = true;
      animationFrame(this._tickProxy);
    } else {
      this.onEnd();
    }
  };
  Animation2.prototype.enabled = function enabled() {
    return true;
  };
  Animation2.prototype.cancel = function cancel() {
    this._started = false;
    this.onCancel();
  };
  Animation2.prototype._tick = function _tick() {
    var that = this;
    if (!that._started) {
      return;
    }
    that.tick();
    if (!that.done()) {
      animationFrame(that._tickProxy);
    } else {
      that._started = false;
      that.onEnd();
    }
  };
  return Animation2;
}(class_default);
var Transition = function(Animation2) {
  function Transition2(options) {
    Animation2.call(this);
    extend13(this, options);
  }
  if (Animation2) Transition2.__proto__ = Animation2;
  Transition2.prototype = Object.create(Animation2 && Animation2.prototype);
  Transition2.prototype.constructor = Transition2;
  Transition2.prototype.done = function done() {
    return this.timePassed() >= this.duration;
  };
  Transition2.prototype.timePassed = function timePassed() {
    return Math.min(this.duration, now() - this.startDate);
  };
  Transition2.prototype.moveTo = function moveTo(options) {
    var that = this, movable = that.movable;
    that.initial = movable[that.axis];
    that.delta = options.location - that.initial;
    that.duration = typeof options.duration === "number" ? options.duration : 300;
    that.tick = that._easeProxy(options.ease);
    that.startDate = now();
    that.start();
  };
  Transition2.prototype._easeProxy = function _easeProxy(ease) {
    var that = this;
    return function() {
      that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
    };
  };
  Transition2.easeOutExpo = function easeOutExpo(t38, b2, c10, d6) {
    return t38 === d6 ? b2 + c10 : c10 * (-Math.pow(2, -10 * t38 / d6) + 1) + b2;
  };
  return Transition2;
}(Animation);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/scroller.js
var extend14 = Object.assign;
var abs2 = Math.abs;
var SNAPBACK_DURATION = 500;
var SCROLLBAR_OPACITY = 0.7;
var FRICTION = 0.96;
var VELOCITY_MULTIPLIER = 10;
var MAX_VELOCITY = 55;
var OUT_OF_BOUNDS_FRICTION = 0.5;
var ANIMATED_SCROLLER_PRECISION = 5;
var PULL = "pull";
var CHANGE3 = "change";
var RESIZE = "resize";
var SCROLL = "scroll";
var MOUSE_WHEEL_ID = 2;
var ZoomSnapBack = function(Animation2) {
  function ZoomSnapBack2(options) {
    Animation2.call(this, options);
    var that = this;
    extend14(that, options);
    that.userEvents.bind("gestureend", that.start.bind(this));
    that.tapCapture.bind("press", that.cancel.bind(this));
  }
  if (Animation2) ZoomSnapBack2.__proto__ = Animation2;
  ZoomSnapBack2.prototype = Object.create(Animation2 && Animation2.prototype);
  ZoomSnapBack2.prototype.constructor = ZoomSnapBack2;
  ZoomSnapBack2.prototype.enabled = function enabled() {
    return this.movable.scale < this.dimensions.minScale;
  };
  ZoomSnapBack2.prototype.done = function done() {
    return this.dimensions.minScale - this.movable.scale < 0.01;
  };
  ZoomSnapBack2.prototype.tick = function tick() {
    var movable = this.movable;
    movable.scaleWith(1.1);
    this.dimensions.rescale(movable.scale);
  };
  ZoomSnapBack2.prototype.onEnd = function onEnd() {
    var movable = this.movable;
    movable.scaleTo(this.dimensions.minScale);
    this.dimensions.rescale(movable.scale);
  };
  return ZoomSnapBack2;
}(Animation);
var DragInertia = function(Animation2) {
  function DragInertia2(options) {
    Animation2.call(this);
    var that = this;
    extend14(that, options, {
      transition: new Transition({
        axis: options.axis,
        movable: options.movable,
        onEnd: function onEnd() {
          that._end();
        }
      })
    });
    that.tapCapture.bind("press", function() {
      that.cancel();
    });
    that.userEvents.bind("end", proxy(that.start, that));
    that.userEvents.bind("gestureend", proxy(that.start, that));
    that.userEvents.bind("tap", proxy(that.onEnd, that));
  }
  if (Animation2) DragInertia2.__proto__ = Animation2;
  DragInertia2.prototype = Object.create(Animation2 && Animation2.prototype);
  DragInertia2.prototype.constructor = DragInertia2;
  DragInertia2.prototype.onCancel = function onCancel() {
    this.transition.cancel();
  };
  DragInertia2.prototype.freeze = function freeze(location) {
    var that = this;
    that.cancel();
    that._moveTo(location);
  };
  DragInertia2.prototype.onEnd = function onEnd() {
    var that = this;
    if (that.paneAxis.outOfBounds()) {
      that._snapBack();
    } else {
      that._end();
    }
  };
  DragInertia2.prototype.done = function done() {
    return abs2(this.velocity) < 1;
  };
  DragInertia2.prototype.start = function start(e39) {
    var that = this, velocity;
    if (!that.dimension.enabled) {
      return;
    }
    if (that.paneAxis.outOfBounds()) {
      if (that.transition._started) {
        that.transition.cancel();
        that.velocity = Math.min(e39.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);
        Animation2.prototype.start.call(this);
      } else {
        that._snapBack();
      }
    } else {
      velocity = e39.touch.id === MOUSE_WHEEL_ID ? 0 : e39.touch[that.axis].velocity;
      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
      that.tapCapture.captureNext();
      Animation2.prototype.start.call(this);
    }
  };
  DragInertia2.prototype.tick = function tick() {
    var that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
    if (!that.elastic && dimension.outOfBounds(location)) {
      location = Math.max(Math.min(location, dimension.max), dimension.min);
      that.velocity = 0;
    }
    that.movable.moveAxis(that.axis, location);
  };
  DragInertia2.prototype._end = function _end() {
    this.tapCapture.cancelCapture();
    this.end();
  };
  DragInertia2.prototype._snapBack = function _snapBack() {
    var that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
    that._moveTo(snapBack);
  };
  DragInertia2.prototype._moveTo = function _moveTo(location) {
    this.transition.moveTo({
      location,
      duration: SNAPBACK_DURATION,
      ease: Transition.easeOutExpo
    });
  };
  return DragInertia2;
}(Animation);
var AnimatedScroller = function(Animation2) {
  function AnimatedScroller2(options) {
    Animation2.call(this, options);
    var that = this;
    extend14(that, options, {
      origin: {},
      destination: {},
      offset: {}
    });
  }
  if (Animation2) AnimatedScroller2.__proto__ = Animation2;
  AnimatedScroller2.prototype = Object.create(Animation2 && Animation2.prototype);
  AnimatedScroller2.prototype.constructor = AnimatedScroller2;
  AnimatedScroller2.prototype.tick = function tick() {
    this._updateCoordinates();
    this.moveTo(this.origin);
  };
  AnimatedScroller2.prototype.done = function done() {
    return abs2(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs2(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
  };
  AnimatedScroller2.prototype.onEnd = function onEnd() {
    this.moveTo(this.destination);
    if (this.callback) {
      this.callback.call();
    }
  };
  AnimatedScroller2.prototype.setCoordinates = function setCoordinates(from, to) {
    this.offset = {};
    this.origin = from;
    this.destination = to;
  };
  AnimatedScroller2.prototype.setCallback = function setCallback(callback) {
    if (callback && isFunction(callback)) {
      this.callback = callback;
    } else {
      callback = void 0;
    }
  };
  AnimatedScroller2.prototype._updateCoordinates = function _updateCoordinates() {
    this.offset = {
      x: (this.destination.x - this.origin.x) / 4,
      y: (this.destination.y - this.origin.y) / 4
    };
    this.origin = {
      y: this.origin.y + this.offset.y,
      x: this.origin.x + this.offset.x
    };
  };
  return AnimatedScroller2;
}(Animation);
var ScrollBar = function(Class) {
  function ScrollBar2(options) {
    Class.call(this);
    var that = this, horizontal = options.axis === "x";
    var orientation = horizontal ? "horizontal" : "vertical";
    var element = convertToHtml('<div class="km-touch-scrollbar km-' + orientation + '-scrollbar" />');
    extend14(that, options, {
      element,
      elementSize: 0,
      movable: new Movable(element),
      scrollMovable: options.movable,
      alwaysVisible: options.alwaysVisible,
      size: horizontal ? "width" : "height"
    });
    that.scrollMovable.bind(CHANGE3, that.refresh.bind(that));
    that.container.appendChild(element);
    if (options.alwaysVisible) {
      that.show();
    }
  }
  if (Class) ScrollBar2.__proto__ = Class;
  ScrollBar2.prototype = Object.create(Class && Class.prototype);
  ScrollBar2.prototype.constructor = ScrollBar2;
  ScrollBar2.prototype.refresh = function refresh() {
    var that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
    if (sizeRatio >= 1) {
      this.element.style.display = "none";
    } else {
      this.element.style.display = "";
    }
    if (position + size > paneSize) {
      size = paneSize - position;
    } else if (position < 0) {
      size += position;
      position = 0;
    }
    if (that.elementSize !== size) {
      that.element.style[that.size] = size + "px";
      that.elementSize = size;
    }
    that.movable.moveAxis(axis, position);
  };
  ScrollBar2.prototype.show = function show2() {
    this.element.style.opacity = SCROLLBAR_OPACITY;
    this.element.style.visibility = "visible";
  };
  ScrollBar2.prototype.hide = function hide2() {
    if (!this.alwaysVisible) {
      this.element.style.opacity = 0;
    }
  };
  return ScrollBar2;
}(class_default);
var Scroller = function(Observable2) {
  function Scroller2(element, options) {
    Observable2.call(this);
    var that = this;
    this.element = element;
    this._initOptions(options);
    var hasScrolling = hasNativeScrolling(navigator.userAgent);
    that._native = that.options.useNative && hasScrolling;
    var scrollHeader = convertToHtml('<div class="km-scroll-header"/>');
    if (that._native) {
      addClass(element, "km-native-scroller");
      prepend(scrollHeader, element);
      extend14(that, {
        scrollElement: element,
        fixedContainer: element.children[0]
      });
      return;
    }
    element.style.overflow = "hidden";
    addClass(element, "km-scroll-wrapper");
    var scrollContainer = convertToHtml('<div class="km-scroll-container"/>');
    wrapInner(element, scrollContainer);
    prepend(scrollHeader, element);
    var inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({
      element: inner,
      container: element,
      forcedEnabled: that.options.zoom
    }), avoidScrolling2 = this.options.avoidScrolling, userEvents = new user_events_default(element, {
      touchAction: "none",
      allowSelection: true,
      preventDragEvent: true,
      captureUpIfMoved: true,
      multiTouch: that.options.zoom,
      supportDoubleTap: that.options.supportDoubleTap,
      start: function start(e39) {
        dimensions.refresh();
        var velocityX = abs2(e39.x.velocity), velocityY = abs2(e39.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = that.fixedContainer.contains(e39.event.target), verticalSwipe = velocityY * 2 >= velocityX;
        if (!originatedFromFixedContainer && !avoidScrolling2(e39) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
          userEvents.capture();
        } else {
          userEvents.cancel();
        }
      }
    }), pane = new Pane2({
      movable,
      dimensions,
      userEvents,
      elastic: that.options.elastic
    }), zoomSnapBack = new ZoomSnapBack({
      movable,
      dimensions,
      userEvents,
      tapCapture
    }), animatedScroller = new AnimatedScroller({
      moveTo: function moveTo(coordinates) {
        that.scrollTo(coordinates.x, coordinates.y);
      }
    });
    movable.bind(CHANGE3, function() {
      that.scrollTop = -movable.y;
      that.scrollLeft = -movable.x;
      that.trigger(SCROLL, {
        scrollTop: that.scrollTop,
        scrollLeft: that.scrollLeft
      });
    });
    if (that.options.mousewheelScrolling) {
      this._wheelScrollHandler = this._wheelScroll.bind(this);
      on(element, "wheel", this._wheelScrollHandler);
    }
    extend14(that, {
      movable,
      dimensions,
      zoomSnapBack,
      animatedScroller,
      userEvents,
      pane,
      tapCapture,
      pulled: false,
      enabled: true,
      scrollElement: inner,
      scrollTop: 0,
      scrollLeft: 0,
      fixedContainer: element.children[0]
    });
    that._initAxis("x");
    that._initAxis("y");
    that._wheelEnd = function() {
      that._wheel = false;
      that.userEvents.end(0, that._wheelY);
    };
    dimensions.refresh();
    if (that.options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  if (Observable2) Scroller2.__proto__ = Observable2;
  Scroller2.prototype = Object.create(Observable2 && Observable2.prototype);
  Scroller2.prototype.constructor = Scroller2;
  Scroller2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Scroller2.prototype._wheelScroll = function _wheelScroll(e39) {
    if (e39.ctrlKey) {
      return;
    }
    if (!this._wheel) {
      this._wheel = true;
      this._wheelY = 0;
      this.userEvents.press(0, this._wheelY);
    }
    clearTimeout(this._wheelTimeout);
    this._wheelTimeout = setTimeout(this._wheelEnd, 50);
    var delta = wheelDeltaY(e39);
    if (delta) {
      this._wheelY += delta;
      this.userEvents.move(0, this._wheelY);
    }
    e39.preventDefault();
  };
  Scroller2.prototype.makeVirtual = function makeVirtual() {
    this.dimensions.y.makeVirtual();
  };
  Scroller2.prototype.virtualSize = function virtualSize(min4, max3) {
    this.dimensions.y.virtualSize(min4, max3);
  };
  Scroller2.prototype.height = function height() {
    return this.dimensions.y.size;
  };
  Scroller2.prototype.scrollHeight = function scrollHeight() {
    return this.scrollElement.scrollHeight;
  };
  Scroller2.prototype.scrollWidth = function scrollWidth() {
    return this.scrollElement.scrollWidth;
  };
  Scroller2.prototype._resize = function _resize() {
    if (!this._native) {
      this.contentResized();
    }
  };
  Scroller2.prototype.setOptions = function setOptions(options) {
    var that = this;
    this._initOptions(options);
    if (options.pullToRefresh) {
      that._initPullToRefresh();
    }
  };
  Scroller2.prototype.reset = function reset() {
    if (this._native) {
      this.scrollElement.scrollTop(0);
    } else {
      this.movable.moveTo({
        x: 0,
        y: 0
      });
      this._scale(1);
    }
  };
  Scroller2.prototype.contentResized = function contentResized() {
    this.dimensions.refresh();
    if (this.pane.x.outOfBounds()) {
      this.movable.moveAxis("x", this.dimensions.x.min);
    }
    if (this.pane.y.outOfBounds()) {
      this.movable.moveAxis("y", this.dimensions.y.min);
    }
  };
  Scroller2.prototype.zoomOut = function zoomOut() {
    var dimensions = this.dimensions;
    dimensions.refresh();
    this._scale(dimensions.fitScale);
    this.movable.moveTo(dimensions.centerCoordinates());
  };
  Scroller2.prototype.enable = function enable() {
    this.enabled = true;
  };
  Scroller2.prototype.disable = function disable() {
    this.enabled = false;
  };
  Scroller2.prototype.scrollTo = function scrollTo(x5, y) {
    if (this._native) {
      this.scrollElement.scrollLeft(abs2(x5));
      this.scrollElement.scrollTop(abs2(y));
    } else {
      this.dimensions.refresh();
      this.movable.moveTo({
        x: x5,
        y
      });
    }
  };
  Scroller2.prototype.animatedScrollTo = function animatedScrollTo(x5, y, callback) {
    var from, to;
    if (this._native) {
      this.scrollTo(x5, y);
    } else {
      from = {
        x: this.movable.x,
        y: this.movable.y
      };
      to = {
        x: x5,
        y
      };
      this.animatedScroller.setCoordinates(from, to);
      this.animatedScroller.setCallback(callback);
      this.animatedScroller.start();
    }
  };
  Scroller2.prototype.pullHandled = function pullHandled() {
  };
  Scroller2.prototype.destroy = function destroy() {
    var element = this.element;
    off(element, "wheel", this._wheelScrollHandler);
    if (this.userEvents) {
      this.userEvents.destroy();
    }
  };
  Scroller2.prototype._scale = function _scale(scale) {
    this.dimensions.rescale(scale);
    this.movable.scaleTo(scale);
  };
  Scroller2.prototype._initPullToRefresh = function _initPullToRefresh() {
  };
  Scroller2.prototype._dragEnd = function _dragEnd() {
  };
  Scroller2.prototype._paneChange = function _paneChange() {
  };
  Scroller2.prototype._initAxis = function _initAxis(axis) {
    var that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
      axis,
      movable,
      dimension,
      container: that.element,
      alwaysVisible: that.options.visibleScrollHints
    });
    dimension.bind(CHANGE3, function() {
      scrollBar.refresh();
    });
    paneAxis.bind(CHANGE3, function() {
      scrollBar.show();
    });
    that[axis + "inertia"] = new DragInertia({
      axis,
      paneAxis,
      movable,
      tapCapture,
      userEvents: that.userEvents,
      dimension,
      elastic: that.options.elastic,
      friction: that.options.friction || FRICTION,
      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,
      end: function end() {
        scrollBar.hide();
        that.trigger("scrollEnd", {
          axis,
          scrollTop: that.scrollTop,
          scrollLeft: that.scrollLeft
        });
      }
    });
  };
  return Scroller2;
}(observable_default);
setDefaultOptions(Scroller, {
  name: "Scroller",
  zoom: false,
  pullOffset: 140,
  visibleScrollHints: false,
  elastic: true,
  useNative: false,
  mousewheelScrolling: true,
  avoidScrolling: function avoidScrolling() {
    return false;
  },
  pullToRefresh: false,
  messages: {
    pullTemplate: "Pull to refresh",
    releaseTemplate: "Release to refresh",
    refreshTemplate: "Refreshing"
  }
});
setDefaultEvents(Scroller, [
  PULL,
  SCROLL,
  RESIZE
]);

// node_modules/@progress/kendo-charts/dist/es/services/map-service.js
var MapService = function MapService2(widget, context) {
  if (context === void 0) context = {};
  this.sender = context.sender || widget;
  this.widget = widget;
  this.rtl = Boolean(context.rtl);
};
MapService.prototype.notify = function notify2(name2, args) {
  if (this.widget) {
    this.widget.trigger(name2, args);
  }
};
var map_service_default = MapService;

// node_modules/@progress/kendo-charts/dist/es/map/map.js
var math5 = Math;
var min2 = math5.min;
var pow2 = math5.pow;
var Point6 = geometry_exports.Point;
var MARKER = "marker";
var LOCATION = "location";
var FRICTION2 = 0.9;
var FRICTION_MOBILE = 0.93;
var MOUSEWHEEL2 = "wheel";
var MOUSEWHEEL_THROTTLE = 50;
var VELOCITY_MULTIPLIER2 = 5;
var DEFAULT_ZOOM_RATE = 1;
var layersMap = {
  bubble: BubbleLayer,
  shape: ShapeLayer,
  tile: TileLayer
};
layersMap[MARKER] = MarkerLayer;
var Map2 = function(Observable2) {
  function Map3(element, options, themeOptions, context) {
    if (options === void 0) options = {};
    if (themeOptions === void 0) themeOptions = {};
    if (context === void 0) context = {};
    Observable2.call(this);
    this._init(element, options, themeOptions, context);
  }
  if (Observable2) Map3.__proto__ = Observable2;
  Map3.prototype = Object.create(Observable2 && Observable2.prototype);
  Map3.prototype.constructor = Map3;
  Map3.prototype.destroy = function destroy() {
    var this$1 = this;
    this.scroller.destroy();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this.navigator) {
      this.navigator.destroy();
    }
    if (this.attribution) {
      this.attribution.destroy();
    }
    if (this.zoomControl) {
      this.zoomControl.destroy();
    }
    if (isArray(this.markers)) {
      this.markers.forEach(function(markerLayer) {
        markerLayer.destroy();
      });
    } else {
      this.markers.destroy();
    }
    for (var i36 = 0; i36 < this.layers.length; i36++) {
      this$1.layers[i36].destroy();
    }
    off(this.element, MOUSEWHEEL2, this._mousewheelHandler);
    Observable2.prototype.destroy.call(this);
  };
  Map3.prototype._init = function _init(element, options, themeOptions, context) {
    if (options === void 0) options = {};
    if (themeOptions === void 0) themeOptions = {};
    if (context === void 0) context = {};
    this.support = getSupportedFeatures();
    this.context = context;
    this.initObserver(context);
    this.initServices(context);
    this._notifyObserver(INIT);
    this._initOptions(options);
    this._setEvents(options);
    this.crs = new EPSG3857();
    this._initElement(element);
    this._viewOrigin = this._getOrigin();
    this._tooltip = this._createTooltip();
    this._initScroller();
    this._initMarkers();
    this._initControls();
    this._initLayers();
    this._reset();
    var mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);
    this._mousewheelHandler = function(e39) {
      e39.preventDefault();
      mousewheelThrottled(e39);
    };
    on(this.element, MOUSEWHEEL2, this._mousewheelHandler);
  };
  Map3.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Map3.prototype._initElement = function _initElement(element) {
    this.element = element;
    addClass(element, "k-map");
    element.style.position = "relative";
    element.setAttribute("data-role", "map");
    removeChildren(element);
    var div = convertToHtml("<div />");
    this.element.appendChild(div);
  };
  Map3.prototype.initServices = function initServices(context) {
    if (context === void 0) context = {};
    this.widgetService = new map_service_default(this, context);
  };
  Map3.prototype.initObserver = function initObserver(context) {
    if (context === void 0) context = {};
    this.observers = [];
    this.addObserver(context.observer);
  };
  Map3.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Map3.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Map3.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Map3.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0) args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    if (!isDefaultPrevented2) {
      Observable2.prototype.trigger.call(this, name2, args);
    }
    return isDefaultPrevented2;
  };
  Map3.prototype._notifyObserver = function _notifyObserver(name2, args) {
    if (args === void 0) args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  };
  Map3.prototype.zoom = function zoom(level) {
    var options = this.options;
    var result;
    if (defined(level)) {
      var zoomLevel = math5.round(limitValue(level, options.minZoom, options.maxZoom));
      if (options.zoom !== zoomLevel) {
        options.zoom = zoomLevel;
        this.widgetService.notify(ZOOM_CHANGE, { zoom: options.zoom });
        this._reset();
      }
      result = this;
    } else {
      result = options.zoom;
    }
    return result;
  };
  Map3.prototype.center = function center(center$1) {
    var result;
    if (center$1) {
      var current4 = Location.create(center$1);
      var previous = Location.create(this.options.center);
      if (!current4.equals(previous)) {
        this.options.center = current4.toArray();
        this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
        this._reset();
      }
      result = this;
    } else {
      result = Location.create(this.options.center);
    }
    return result;
  };
  Map3.prototype.extent = function extent(extent$1) {
    var result;
    if (extent$1) {
      this._setExtent(extent$1);
      result = this;
    } else {
      result = this._getExtent();
    }
    return result;
  };
  Map3.prototype.setOptions = function setOptions(options) {
    if (options === void 0) options = {};
    var element = this.element;
    this.destroy();
    removeChildren(element);
    this._init(element, options, {}, this.context);
    this._reset();
  };
  Map3.prototype.locationToLayer = function locationToLayer(location, zoom) {
    var clamp = !this.options.wraparound;
    var locationObject = Location.create(location);
    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.layerToLocation = function layerToLocation(point, zoom) {
    var clamp = !this.options.wraparound;
    var pointObject = Point6.create(point);
    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.locationToView = function locationToView(location) {
    var locationObject = Location.create(location);
    var origin = this.locationToLayer(this._viewOrigin);
    var point = this.locationToLayer(locationObject);
    return point.translateWith(origin.scale(-1));
  };
  Map3.prototype.viewToLocation = function viewToLocation(point, zoom) {
    var origin = this.locationToLayer(this._getOrigin(), zoom);
    var pointObject = Point6.create(point);
    var pointResult = pointObject.clone().translateWith(origin);
    return this.layerToLocation(pointResult, zoom);
  };
  Map3.prototype.eventOffset = function eventOffset(e39) {
    var x5;
    var y;
    var offset = elementOffset(this.element);
    if (e39.x && e39.x[LOCATION] || e39.y && e39.y[LOCATION]) {
      x5 = e39.x[LOCATION] - offset.left;
      y = e39.y[LOCATION] - offset.top;
    } else {
      var event = e39.originalEvent || e39;
      x5 = valueOrDefault(event.pageX, event.clientX) - offset.left;
      y = valueOrDefault(event.pageY, event.clientY) - offset.top;
    }
    var point = new geometry_exports.Point(x5, y);
    return point;
  };
  Map3.prototype.eventToView = function eventToView(e39) {
    var cursor = this.eventOffset(e39);
    return this.locationToView(this.viewToLocation(cursor));
  };
  Map3.prototype.eventToLayer = function eventToLayer(e39) {
    return this.locationToLayer(this.eventToLocation(e39));
  };
  Map3.prototype.eventToLocation = function eventToLocation(e39) {
    var cursor = this.eventOffset(e39);
    return this.viewToLocation(cursor);
  };
  Map3.prototype.viewSize = function viewSize() {
    var element = this.element;
    var scale = this._layerSize();
    var width = element.clientWidth;
    if (!this.options.wraparound) {
      width = min2(scale, width);
    }
    return {
      width,
      height: min2(scale, element.clientHeight)
    };
  };
  Map3.prototype.exportVisual = function exportVisual() {
    this._reset();
    return false;
  };
  Map3.prototype.hideTooltip = function hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Map3.prototype._setOrigin = function _setOrigin(origin, zoom) {
    var size = this.viewSize(), topLeft;
    var originLocation = this._origin = Location.create(origin);
    topLeft = this.locationToLayer(originLocation, zoom);
    topLeft.x += size.width / 2;
    topLeft.y += size.height / 2;
    this.options.center = this.layerToLocation(topLeft, zoom).toArray();
    this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
    return this;
  };
  Map3.prototype._getOrigin = function _getOrigin(invalidate) {
    var size = this.viewSize(), topLeft;
    if (invalidate || !this._origin) {
      topLeft = this.locationToLayer(this.center());
      topLeft.x -= size.width / 2;
      topLeft.y -= size.height / 2;
      this._origin = this.layerToLocation(topLeft);
    }
    return this._origin;
  };
  Map3.prototype._setExtent = function _setExtent(newExtent) {
    var this$1 = this;
    var raw = Extent.create(newExtent);
    var se = raw.se.clone();
    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {
      se.lng = 180 + (180 + se.lng);
    }
    var extent = new Extent(raw.nw, se);
    this.center(extent.center());
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    var zoom;
    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {
      var topLeft = this$1.locationToLayer(extent.nw, zoom);
      var bottomRight = this$1.locationToLayer(extent.se, zoom);
      var layerWidth = math5.abs(bottomRight.x - topLeft.x);
      var layerHeight = math5.abs(bottomRight.y - topLeft.y);
      if (layerWidth <= width && layerHeight <= height) {
        break;
      }
    }
    this.zoom(zoom);
  };
  Map3.prototype._getExtent = function _getExtent() {
    var nw = this._getOrigin();
    var bottomRight = this.locationToLayer(nw);
    var size = this.viewSize();
    bottomRight.x += size.width;
    bottomRight.y += size.height;
    var se = this.layerToLocation(bottomRight);
    return new Extent(nw, se);
  };
  Map3.prototype._zoomAround = function _zoomAround(pivot, level) {
    this._setOrigin(this.layerToLocation(pivot, level), level);
    this.zoom(level);
  };
  Map3.prototype._initControls = function _initControls() {
    var controls = this.options.controls;
    if (controls.attribution) {
      this._createAttribution(controls.attribution);
    }
    if (!this.support.mobileOS) {
      if (controls.navigator) {
        this._createNavigator(controls.navigator);
      }
      if (controls.zoom) {
        this._createZoomControl(controls.zoom);
      }
    }
  };
  Map3.prototype._createControlElement = function _createControlElement(options, defaultPosition) {
    var pos = options.position || defaultPosition;
    var posSelector = "." + renderPos(pos).replace(" ", ".");
    var wrap = this.element.querySelector(".k-map-controls" + posSelector) || [];
    if (wrap.length === 0) {
      var div$1 = document.createElement("div");
      addClass(div$1, "k-map-controls " + renderPos(pos));
      wrap = div$1;
      this.element.appendChild(wrap);
    }
    var div = document.createElement("div");
    wrap.appendChild(div);
    return div;
  };
  Map3.prototype._createAttribution = function _createAttribution(options) {
    var element = this._createControlElement(options, "bottomRight");
    this.attribution = new Attribution(element, options);
  };
  Map3.prototype._createNavigator = function _createNavigator(options) {
    var element = this._createControlElement(options, "topLeft");
    var navigator2 = this.navigator = new Navigator2(element, deepExtend({}, options, { icons: this.options.icons }));
    this._navigatorPan = this._navigatorPan.bind(this);
    navigator2.bind("pan", this._navigatorPan);
    this._navigatorCenter = this._navigatorCenter.bind(this);
    navigator2.bind("center", this._navigatorCenter);
  };
  Map3.prototype._navigatorPan = function _navigatorPan(e39) {
    var scroller = this.scroller;
    var x5 = scroller.scrollLeft + e39.x;
    var y = scroller.scrollTop - e39.y;
    var bounds = this._virtualSize;
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    x5 = limitValue(x5, bounds.x.min, bounds.x.max - width);
    y = limitValue(y, bounds.y.min, bounds.y.max - height);
    this.scroller.one("scroll", proxy(this._scrollEnd, this));
    this.scroller.scrollTo(-x5, -y);
  };
  Map3.prototype._navigatorCenter = function _navigatorCenter() {
    this.center(this.options.center);
  };
  Map3.prototype._createZoomControl = function _createZoomControl(options) {
    var element = this._createControlElement(options, "topLeft");
    var zoomControl = this.zoomControl = new ZoomControl(element, options, this.options.icons);
    this._zoomControlChange = this._zoomControlChange.bind(this);
    zoomControl.bind("change", this._zoomControlChange);
  };
  Map3.prototype._zoomControlChange = function _zoomControlChange(e39) {
    if (!this.trigger("zoomStart", { originalEvent: e39 })) {
      this.zoom(this.zoom() + e39.delta);
      this.trigger("zoomEnd", {
        originalEvent: e39
      });
    }
  };
  Map3.prototype._initScroller = function _initScroller() {
    var friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION2;
    var zoomable = this.options.zoomable !== false;
    var scroller = this.scroller = new Scroller(this.element.children[0], {
      friction,
      velocityMultiplier: VELOCITY_MULTIPLIER2,
      zoom: zoomable,
      mousewheelScrolling: false,
      supportDoubleTap: true
    });
    scroller.bind("scroll", proxy(this._scroll, this));
    scroller.bind("scrollEnd", proxy(this._scrollEnd, this));
    scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));
    scroller.userEvents.bind("gestureend", proxy(this._scale, this));
    scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));
    scroller.userEvents.bind("tap", proxy(this._tap, this));
    this.scrollElement = scroller.scrollElement;
  };
  Map3.prototype._initLayers = function _initLayers() {
    var this$1 = this;
    var defs = this.options.layers, layers = this.layers = [];
    for (var i36 = 0; i36 < defs.length; i36++) {
      var options = defs[i36];
      var layer = this$1._createLayer(options);
      layers.push(layer);
    }
  };
  Map3.prototype._createLayer = function _createLayer(options) {
    var type = options.type || "shape";
    var layerDefaults = this.options.layerDefaults[type];
    var layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options, { icons: this.options.icons }) : deepExtend({}, layerDefaults, options);
    var layerConstructor = layersMap[type];
    var layer = new layerConstructor(this, layerOptions);
    if (type === MARKER) {
      this.markers = layer;
    }
    return layer;
  };
  Map3.prototype._createTooltip = function _createTooltip() {
    return new Tooltip2(this.widgetService, this.options.tooltip);
  };
  Map3.prototype._initMarkers = function _initMarkers() {
    var markerLayers = (this.options.layers || []).filter(function(x5) {
      return x5 && x5.type === MARKER;
    });
    if (markerLayers.length > 0) {
      return;
    }
    this.markers = new MarkerLayer(this, deepExtend({}, this.options.markerDefaults, { icons: this.options.icons }));
    this.markers.add(this.options.markers);
  };
  Map3.prototype._scroll = function _scroll(e39) {
    var origin = this.locationToLayer(this._viewOrigin).round();
    var movable = e39.sender.movable;
    var offset = new geometry_exports.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);
    origin.x += offset.x;
    origin.y += offset.y;
    this._scrollOffset = offset;
    this._tooltip.offset = offset;
    this.hideTooltip();
    this._setOrigin(this.layerToLocation(origin));
    this.trigger("pan", {
      originalEvent: e39,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._scrollEnd = function _scrollEnd(e39) {
    if (!this._scrollOffset || !this._panComplete()) {
      return;
    }
    this._scrollOffset = null;
    this._panEndTimestamp = now();
    this.trigger("panEnd", {
      originalEvent: e39,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._panComplete = function _panComplete() {
    return now() - (this._panEndTimestamp || 0) > 50;
  };
  Map3.prototype._scaleStart = function _scaleStart(e39) {
    if (this.trigger("zoomStart", { originalEvent: e39 })) {
      var touch = e39.touches[1];
      if (touch) {
        touch.cancel();
      }
    }
  };
  Map3.prototype._scale = function _scale(e39) {
    var scale = this.scroller.movable.scale;
    var zoom = this._scaleToZoom(scale);
    var gestureCenter = new geometry_exports.Point(e39.center.x, e39.center.y);
    var centerLocation = this.viewToLocation(gestureCenter, zoom);
    var centerPoint = this.locationToLayer(centerLocation, zoom);
    var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);
    this._zoomAround(originPoint, zoom);
    this.trigger("zoomEnd", {
      originalEvent: e39
    });
  };
  Map3.prototype._scaleToZoom = function _scaleToZoom(scaleDelta) {
    var scale = this._layerSize() * scaleDelta;
    var tiles = scale / this.options.minSize;
    var zoom = math5.log(tiles) / math5.log(2);
    return math5.round(zoom);
  };
  Map3.prototype._reset = function _reset() {
    if (this.attribution) {
      this.attribution.filter(this.center(), this.zoom());
    }
    this._viewOrigin = this._getOrigin(true);
    this._resetScroller();
    this.hideTooltip();
    this.trigger("beforeReset");
    this.trigger("reset");
  };
  Map3.prototype._resetScroller = function _resetScroller() {
    var scroller = this.scroller;
    var x5 = scroller.dimensions.x;
    var y = scroller.dimensions.y;
    var scale = this._layerSize();
    var nw = this.extent().nw;
    var topLeft = this.locationToLayer(nw).round();
    scroller.movable.round = true;
    scroller.reset();
    scroller.userEvents.cancel();
    var zoom = this.zoom();
    scroller.dimensions.forcedMinScale = pow2(2, this.options.minZoom - zoom);
    scroller.dimensions.maxScale = pow2(2, this.options.maxZoom - zoom);
    var xBounds = {
      min: -topLeft.x,
      max: scale - topLeft.x
    };
    var yBounds = {
      min: -topLeft.y,
      max: scale - topLeft.y
    };
    if (this.options.wraparound) {
      xBounds.max = 20 * scale;
      xBounds.min = -xBounds.max;
    }
    if (this.options.pannable === false) {
      var viewSize = this.viewSize();
      xBounds.min = yBounds.min = 0;
      xBounds.max = viewSize.width;
      yBounds.max = viewSize.height;
    }
    x5.makeVirtual();
    y.makeVirtual();
    x5.virtualSize(xBounds.min, xBounds.max);
    y.virtualSize(yBounds.min, yBounds.max);
    this._virtualSize = {
      x: xBounds,
      y: yBounds
    };
  };
  Map3.prototype._renderLayers = function _renderLayers() {
  };
  Map3.prototype._layerSize = function _layerSize(zoom) {
    var newZoom = valueOrDefault(zoom, this.options.zoom);
    return this.options.minSize * pow2(2, newZoom);
  };
  Map3.prototype._tap = function _tap(e39) {
    if (!this._panComplete()) {
      return;
    }
    var cursor = this.eventOffset(e39);
    this.hideTooltip();
    this.trigger("click", {
      originalEvent: e39,
      location: this.viewToLocation(cursor)
    });
  };
  Map3.prototype._doubleTap = function _doubleTap(e39) {
    var options = this.options;
    if (options.zoomable !== false) {
      if (!this.trigger("zoomStart", { originalEvent: e39 })) {
        var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;
        var cursor = this.eventOffset(e39);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e39
        });
      }
    }
  };
  Map3.prototype._mousewheel = function _mousewheel(e39) {
    var delta = mousewheelDelta(e39) > 0 ? -1 : 1;
    var options = this.options;
    var fromZoom = this.zoom();
    var toZoom = limitValue(fromZoom + delta, options.minZoom, options.maxZoom);
    if (options.zoomable !== false && toZoom !== fromZoom) {
      if (!this.trigger("zoomStart", { originalEvent: e39 })) {
        var cursor = this.eventOffset(e39);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e39
        });
      }
    }
  };
  Map3.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point) {
    var offset = elementOffset(this.element);
    return {
      left: round(point.x + offset.left),
      top: round(point.y + offset.top)
    };
  };
  return Map3;
}(observable_default);
setDefaultOptions(Map2, {
  name: "Map",
  controls: {
    attribution: true,
    navigator: {
      panStep: 100
    },
    zoom: true
  },
  layers: [],
  layerDefaults: {
    shape: {
      style: {
        fill: {
          color: "#fff"
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    bubble: {
      style: {
        fill: {
          color: "#fff",
          opacity: 0.5
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    marker: {
      shape: "pinTarget",
      tooltip: {
        position: "top"
      }
    }
  },
  center: [
    0,
    0
  ],
  icons: {
    type: "font",
    svgIcons: {}
  },
  zoom: 3,
  minSize: 256,
  minZoom: 1,
  maxZoom: 19,
  markers: [],
  markerDefaults: {
    shape: "pinTarget",
    tooltip: {
      position: "top"
    }
  },
  wraparound: true,
  // If set to true, GeoJSON layer "Point" features will be rendered as markers.
  // Otherwise, the points will be rendered as circles.
  // Defaults to `true` for KUI/jQuery, `false` everywhere else.
  renderPointsAsMarkers: false
});
setDefaultEvents(Map2, [
  "beforeReset",
  "click",
  "markerActivate",
  "markerClick",
  "markerCreated",
  // Events for implementing custom tooltips.
  "markerMouseEnter",
  "markerMouseLeave",
  "pan",
  "panEnd",
  "reset",
  "shapeClick",
  "shapeCreated",
  "shapeFeatureCreated",
  "shapeMouseEnter",
  "shapeMouseLeave",
  "zoomEnd",
  "zoomStart"
]);

// node_modules/@progress/kendo-charts/dist/es/sankey/calculation.js
var max2 = function(array, mapFn) {
  return Math.max.apply(null, array.map(mapFn));
};
var min3 = function(array, mapFn) {
  return Math.min.apply(null, array.map(mapFn));
};
var sum = function(array, mapFn) {
  return array.map(mapFn).reduce(function(acc, curr) {
    return acc + curr;
  }, 0);
};
var sortAsc = function(a38, b2) {
  return a38.y0 === b2.y0 ? a38.index - b2.index : a38.y0 + a38.y1 - b2.y0 - b2.y1;
};
var sortSource = function(a38, b2) {
  return sortAsc(a38.source, b2.source);
};
var sortTarget = function(a38, b2) {
  return sortAsc(a38.target, b2.target);
};
var value = function(node) {
  return node.value;
};
function sortLinks(nodes) {
  nodes.forEach(function(node) {
    node.targetLinks.forEach(function(link) {
      link.source.sourceLinks.sort(sortTarget);
    });
    node.sourceLinks.forEach(function(link) {
      link.target.targetLinks.sort(sortSource);
    });
  });
}
var calcLayer = function(node, maxDepth) {
  if (node.align === "left") {
    return node.depth;
  }
  if (node.align === "right") {
    return maxDepth - node.height;
  }
  return node.sourceLinks.length ? node.depth : maxDepth;
};
var Sankey = function Sankey2(options) {
  var ref2 = options.nodesOptions;
  var offset = ref2.offset;
  if (offset === void 0) offset = {};
  var align = ref2.align;
  this.data = {
    nodes: options.nodes.map(function(node) {
      return deepExtend({}, { offset, align }, node);
    }),
    links: options.links.map(function(link) {
      return deepExtend({}, link);
    })
  };
  this.width = options.width;
  this.height = options.height;
  this.offsetX = options.offsetX || 0;
  this.offsetY = options.offsetY || 0;
  this.nodeWidth = options.nodesOptions.width;
  this.nodePadding = options.nodesOptions.padding;
  this.reverse = options.reverse;
  this.targetColumnIndex = options.targetColumnIndex;
  this.loops = options.loops;
  this.autoLayout = options.autoLayout;
};
Sankey.prototype.calculate = function calculate() {
  var ref2 = this.data;
  var nodes = ref2.nodes;
  var links = ref2.links;
  this.connectLinksToNodes(nodes, links);
  this.calculateNodeValues(nodes);
  var circularLinks = this.calculateNodeHeights(nodes);
  if (circularLinks) {
    return { nodes: [], links: [], columns: [], circularLinks };
  }
  this.calculateNodeDepths(nodes);
  var columns = this.calculateNodeColumns(nodes);
  this.calculateNodeBreadths(columns);
  this.applyNodesOffset(nodes);
  this.calculateLinkBreadths(nodes);
  return Object.assign({}, this.data, { columns });
};
Sankey.prototype.connectLinksToNodes = function connectLinksToNodes(nodes, links) {
  var nodesMap = /* @__PURE__ */ new Map();
  nodes.forEach(function(node, i36) {
    node.index = i36;
    node.sourceLinks = [];
    node.targetLinks = [];
    node.id = node.id !== void 0 ? node.id : node.label.text;
    nodesMap.set(node.id, node);
  });
  links.forEach(function(link) {
    link.source = nodesMap.get(link.sourceId);
    link.target = nodesMap.get(link.targetId);
    link.source.sourceLinks.push(link);
    link.target.targetLinks.push(link);
  });
};
Sankey.prototype.calculateNodeValues = function calculateNodeValues(nodes) {
  nodes.forEach(function(node) {
    node.value = Math.max(
      sum(node.sourceLinks, value),
      sum(node.targetLinks, value)
    );
  });
};
Sankey.prototype.calculateNodeDepths = function calculateNodeDepths(nodes) {
  var current4 = new Set(nodes);
  var next = /* @__PURE__ */ new Set();
  var currDepth = 0;
  while (current4.size) {
    var currentNodes = Array.from(current4);
    for (var n20 = 0; n20 < currentNodes.length; n20++) {
      var node = currentNodes[n20];
      node.depth = currDepth;
      for (var l8 = 0; l8 < node.sourceLinks.length; l8++) {
        var link = node.sourceLinks[l8];
        next.add(link.target);
      }
    }
    currDepth++;
    current4 = next;
    next = /* @__PURE__ */ new Set();
  }
};
Sankey.prototype.calculateNodeHeights = function calculateNodeHeights(nodes) {
  var nodesLength = nodes.length;
  var current4 = new Set(nodes);
  var next = /* @__PURE__ */ new Set();
  var currentHeight = 0;
  var eachNode = function(node) {
    node.height = currentHeight;
    node.targetLinks.forEach(function(link) {
      next.add(link.source);
    });
  };
  while (current4.size) {
    current4.forEach(eachNode);
    currentHeight++;
    if (currentHeight > nodesLength) {
      return true;
    }
    current4 = next;
    next = /* @__PURE__ */ new Set();
  }
  return false;
};
Sankey.prototype.calculateNodeColumns = function calculateNodeColumns(nodes) {
  var this$1 = this;
  var maxDepth = max2(nodes, function(d6) {
    return d6.depth;
  });
  var columnWidth = (this.width - this.offsetX - this.nodeWidth) / maxDepth;
  var columns = new Array(maxDepth + 1);
  for (var i36 = 0; i36 < nodes.length; i36++) {
    var node = nodes[i36];
    var layer = Math.max(0, Math.min(maxDepth, calcLayer(node, maxDepth)));
    node.x0 = this$1.offsetX + layer * columnWidth;
    node.x1 = node.x0 + this$1.nodeWidth;
    node.layer = layer;
    columns[layer] = columns[layer] || [];
    columns[layer].push(node);
  }
  return columns;
};
Sankey.prototype.calculateNodeBreadths = function calculateNodeBreadths(columns) {
  var this$1 = this;
  var kSize = min3(columns, function(c10) {
    return (this$1.height - this$1.offsetY - (c10.length - 1) * this$1.nodePadding) / sum(c10, value);
  });
  columns.forEach(function(nodes) {
    var y = this$1.offsetY;
    nodes.forEach(function(node) {
      node.y0 = y;
      node.y1 = y + node.value * kSize;
      y = node.y1 + this$1.nodePadding;
      node.sourceLinks.forEach(function(link) {
        link.width = link.value * kSize;
      });
    });
    y = (this$1.height - y + this$1.nodePadding) / (nodes.length + 1);
    nodes.forEach(function(node, i37) {
      node.y0 += y * (i37 + 1);
      node.y1 += y * (i37 + 1);
    });
  });
  if (this.autoLayout !== false) {
    var loops = this.loops !== void 0 ? this.loops : columns.length - 1;
    var targetColumnIndex = this.targetColumnIndex || 1;
    for (var i36 = 0; i36 < loops; i36++) {
      if (!this$1.reverse) {
        this$1.uncurlLinksToLeft(columns, targetColumnIndex);
        this$1.uncurlLinksToRight(columns, targetColumnIndex);
      } else {
        this$1.uncurlLinksToRight(columns, targetColumnIndex);
        this$1.uncurlLinksToLeft(columns, targetColumnIndex);
      }
    }
  }
  columns.forEach(sortLinks);
};
Sankey.prototype.applyNodesOffset = function applyNodesOffset(nodes) {
  nodes.forEach(function(node) {
    var offsetX = (node.offset ? node.offset.left : 0) || 0;
    var offsetY = (node.offset ? node.offset.top : 0) || 0;
    node.x0 += offsetX;
    node.x1 += offsetX;
    node.y0 += offsetY;
    node.y1 += offsetY;
  });
};
Sankey.prototype.calculateLinkBreadths = function calculateLinkBreadths(nodes) {
  nodes.forEach(function(node) {
    var sourceLinks = node.sourceLinks;
    var targetLinks = node.targetLinks;
    var y = node.y0;
    var y1 = y;
    sourceLinks.forEach(function(link) {
      link.x0 = link.source.x1;
      link.y0 = y + link.width / 2;
      y += link.width;
    });
    targetLinks.forEach(function(link) {
      link.x1 = link.target.x0;
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    });
  });
};
Sankey.prototype.uncurlLinksToRight = function uncurlLinksToRight(columns, targetColumnIndex) {
  var this$1 = this;
  var n20 = columns.length;
  for (var i36 = targetColumnIndex; i36 < n20; i36++) {
    var column = columns[i36];
    column.forEach(function(target) {
      var y = 0;
      var sum2 = 0;
      target.targetLinks.forEach(function(link) {
        var kValue = link.value * (target.layer - link.source.layer);
        y += this$1.targetTopPos(link.source, target) * kValue;
        sum2 += kValue;
      });
      var dy = y === 0 ? 0 : y / sum2 - target.y0;
      target.y0 += dy;
      target.y1 += dy;
      sortLinks([target]);
    });
    column.sort(sortAsc);
    this$1.arrangeNodesVertically(column);
  }
};
Sankey.prototype.uncurlLinksToLeft = function uncurlLinksToLeft(columns, targetColumnIndex) {
  var this$1 = this;
  var l8 = columns.length;
  var startIndex = l8 - 1 - targetColumnIndex;
  for (var i36 = startIndex; i36 >= 0; i36--) {
    var column = columns[i36];
    var loop = function(j3) {
      var source = column[j3];
      var y = 0;
      var sum2 = 0;
      source.sourceLinks.forEach(function(link) {
        var kValue = link.value * (link.target.layer - source.layer);
        y += this$1.sourceTopPos(source, link.target) * kValue;
        sum2 += kValue;
      });
      var dy = y === 0 ? 0 : y / sum2 - source.y0;
      source.y0 += dy;
      source.y1 += dy;
      sortLinks([source]);
    };
    for (var j2 = 0; j2 < column.length; j2++) loop(j2);
    column.sort(sortAsc);
    this$1.arrangeNodesVertically(column);
  }
};
Sankey.prototype.arrangeNodesVertically = function arrangeNodesVertically(nodes) {
  var startIndex = 0;
  var endIndex = nodes.length - 1;
  this.arrangeUp(nodes, this.height, endIndex);
  this.arrangeDown(nodes, this.offsetY, startIndex);
};
Sankey.prototype.arrangeDown = function arrangeDown(nodes, yPos, index) {
  var this$1 = this;
  var currentY = yPos;
  for (var i36 = index; i36 < nodes.length; i36++) {
    var node = nodes[i36];
    var dy = Math.max(0, currentY - node.y0);
    node.y0 += dy;
    node.y1 += dy;
    currentY = node.y1 + this$1.nodePadding;
  }
};
Sankey.prototype.arrangeUp = function arrangeUp(nodes, yPos, index) {
  var this$1 = this;
  var currentY = yPos;
  for (var i36 = index; i36 >= 0; --i36) {
    var node = nodes[i36];
    var dy = Math.max(0, node.y1 - currentY);
    node.y0 -= dy;
    node.y1 -= dy;
    currentY = node.y0 - this$1.nodePadding;
  }
};
Sankey.prototype.sourceTopPos = function sourceTopPos(source, target) {
  var this$1 = this;
  var y = target.y0 - (target.targetLinks.length - 1) * this.nodePadding / 2;
  for (var i36 = 0; i36 < target.targetLinks.length; i36++) {
    var link = target.targetLinks[i36];
    if (link.source === source) {
      break;
    }
    y += link.width + this$1.nodePadding;
  }
  for (var i$1 = 0; i$1 < source.sourceLinks.length; i$1++) {
    var link$1 = source.sourceLinks[i$1];
    if (link$1.target === target) {
      break;
    }
    y -= link$1.width;
  }
  return y;
};
Sankey.prototype.targetTopPos = function targetTopPos(source, target) {
  var this$1 = this;
  var y = source.y0 - (source.sourceLinks.length - 1) * this.nodePadding / 2;
  for (var i36 = 0; i36 < source.sourceLinks.length; i36++) {
    var link = source.sourceLinks[i36];
    if (link.target === target) {
      break;
    }
    y += link.width + this$1.nodePadding;
  }
  for (var i$1 = 0; i$1 < target.targetLinks.length; i$1++) {
    var link$1 = target.targetLinks[i$1];
    if (link$1.source === source) {
      break;
    }
    y -= link$1.width;
  }
  return y;
};
var calculateSankey = function(options) {
  return new Sankey(options).calculate();
};
var crossesValue = function(links) {
  var value2 = 0;
  var linksLength = links.length;
  for (var i36 = 0; i36 < linksLength; i36++) {
    var link = links[i36];
    for (var lNext = i36 + 1; lNext < linksLength; lNext++) {
      var nextLink = links[lNext];
      if (intersect(link, nextLink)) {
        value2 += Math.min(link.value, nextLink.value);
      }
    }
  }
  return value2;
};
function rotationDirection(p1x, p1y, p2x, p2y, p3x, p3y) {
  var expression1 = (p3y - p1y) * (p2x - p1x);
  var expression2 = (p2y - p1y) * (p3x - p1x);
  if (expression1 > expression2) {
    return 1;
  } else if (expression1 === expression2) {
    return 0;
  }
  return -1;
}
function intersect(link1, link2) {
  var f1 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x1, link2.y1);
  var f22 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x0, link2.y0);
  var f32 = rotationDirection(link1.x0, link1.y0, link2.x0, link2.y0, link2.x1, link2.y1);
  var f4 = rotationDirection(link1.x1, link1.y1, link2.x0, link2.y0, link2.x1, link2.y1);
  return f1 !== f22 && f32 !== f4;
}

// node_modules/@progress/kendo-charts/dist/es/sankey/element.js
var SankeyElement = function(Class) {
  function SankeyElement2(options) {
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.createVisual();
  }
  if (Class) SankeyElement2.__proto__ = Class;
  SankeyElement2.prototype = Object.create(Class && Class.prototype);
  SankeyElement2.prototype.constructor = SankeyElement2;
  SankeyElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
  };
  SankeyElement2.prototype.exportVisual = function exportVisual() {
    return this.visual;
  };
  SankeyElement2.prototype.createElement = function createElement93() {
    var this$1 = this;
    var customVisual = this.options.visual;
    var visual;
    if (customVisual) {
      visual = customVisual({
        sender: this.getSender(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  SankeyElement2.prototype.getSender = function getSender() {
    return this;
  };
  return SankeyElement2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/sankey/node.js
var Node = function(SankeyElement2) {
  function Node2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Node2.__proto__ = SankeyElement2;
  Node2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Node2.prototype.constructor = Node2;
  Node2.prototype.getElement = function getElement() {
    return drawing_exports.Path.fromRect(this.getRect(), this.visualOptions());
  };
  Node2.prototype.getRect = function getRect() {
    var node = this.options.node;
    return new geometry_exports.Rect([node.x0, node.y0], [node.x1 - node.x0, node.y1 - node.y0]);
  };
  Node2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ node: options.node });
    }
  };
  Node2.prototype.visualOptions = function visualOptions() {
    var options = deepExtend({}, this.options, this.options.node);
    var ariaLabel = this.getLabelText(options);
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: { width: 0 },
      className: "k-sankey-node",
      role: "graphics-symbol",
      ariaRoleDescription: "Node",
      ariaLabel
    };
  };
  Node2.prototype.createFocusHighlight = function createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    this._highlight = drawing_exports.Path.fromRect(this.getRect(), {
      stroke: this.options.focusHighlight.border,
      visible: false
    });
    return this._highlight;
  };
  Node2.prototype.focus = function focus(options) {
    if (this._highlight) {
      var ref2 = options || {};
      var highlight = ref2.highlight;
      if (highlight === void 0) highlight = true;
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      var id = this.options.node.id;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  };
  Node2.prototype.blur = function blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  };
  return Node2;
}(SankeyElement);
var nodeColor = function(node, nodeColors, index) {
  return node.color || nodeColors[index % nodeColors.length];
};
var resolveNodeOptions = function(node, options, nodeColors, index) {
  var nodeOptions = deepExtend({}, options, options.node);
  return deepExtend(
    {},
    { color: nodeColor(node, nodeColors, index) },
    nodeOptions,
    { node },
    {
      visual: node.visual,
      opacity: node.opacity,
      offset: node.offset,
      color: node.color
    }
  );
};

// node_modules/@progress/kendo-charts/dist/es/sankey/link.js
var bezierPoint = function(p1, p22, p32, p42, t38) {
  var t1 = 1 - t38;
  var t1t1 = t1 * t1;
  var tt = t38 * t38;
  return p1 * t1t1 * t1 + 3 * p22 * t38 * t1t1 + 3 * p32 * tt * t1 + p42 * tt * t38;
};
function calculatePerpendicularLine(x1, y1, x22, y2, L) {
  var xM = (x1 + x22) / 2;
  var yM = (y1 + y2) / 2;
  var dx, dy;
  if (y1 === y2) {
    dx = 0;
    dy = L / 2;
  } else if (x1 === x22) {
    dx = L / 2;
    dy = 0;
  } else {
    var m11 = (y2 - y1) / (x22 - x1);
    var mPerp = -1 / m11;
    dx = L / 2 / Math.sqrt(1 + mPerp * mPerp);
    dy = mPerp * dx;
  }
  var P1 = { x: xM - dx, y: yM - dy };
  var P2 = { x: xM + dx, y: yM + dy };
  return { P1, P2 };
}
function findIntersection(a38, b2, L, p9, q2) {
  var midpoint = {
    x: (a38.x + b2.x) / 2,
    y: (a38.y + b2.y) / 2
  };
  var ab_dx = b2.x - a38.x;
  var ab_dy = b2.y - a38.y;
  var perp_dx = -ab_dy;
  var perp_dy = ab_dx;
  var magnitude = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
  perp_dx = perp_dx / magnitude * L;
  perp_dy = perp_dy / magnitude * L;
  var c1 = {
    x: midpoint.x + perp_dx,
    y: midpoint.y + perp_dy
  };
  var c22 = {
    x: midpoint.x - perp_dx,
    y: midpoint.y - perp_dy
  };
  var pq_dx = q2.x - p9.x;
  var pq_dy = q2.y - p9.y;
  var denominator = pq_dy * (c1.x - c22.x) - pq_dx * (c1.y - c22.y);
  if (Math.abs(denominator) < 1e-10) {
    return null;
  }
  var ua = (pq_dx * (c22.y - p9.y) - pq_dy * (c22.x - p9.x)) / denominator;
  var ub = ((c1.x - c22.x) * (c22.y - p9.y) - (c1.y - c22.y) * (c22.x - p9.x)) / denominator;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    var intersection2 = {
      x: c22.x + ua * (c1.x - c22.x)
      // y: c2.y + ua * (c1.y - c2.y)
    };
    return intersection2;
  }
  return null;
}
var calculateControlPointsOffsetX = function(link, rtl) {
  var halfWidth = link.width / 2;
  var x0 = rtl ? link.x1 : link.x0;
  var x1 = rtl ? link.x0 : link.x1;
  var y0 = rtl ? link.y1 : link.y0;
  var y1 = rtl ? link.y0 : link.y1;
  var xC = (x0 + x1) / 2;
  var middlePoint = [xC, bezierPoint(y0, y0, y1, y1, 0.5)];
  var tH = 0.4999;
  var pointH = [
    bezierPoint(x0, xC, xC, x1, tH),
    bezierPoint(y0, y0, y1, y1, tH)
  ];
  var line = calculatePerpendicularLine(middlePoint[0], middlePoint[1], pointH[0], pointH[1], link.width);
  var middlePointDown = [xC, bezierPoint(y0 + halfWidth, y0 + halfWidth, y1 + halfWidth, y1 + halfWidth, 0.5)];
  var P2 = line.P1.y > line.P2.y ? line.P1 : line.P2;
  var L = halfWidth;
  var LDir = (y0 > y1 ? 1 : -1) * L;
  var a38 = P2;
  var b2 = { x: middlePointDown[0], y: middlePointDown[1] };
  var p9 = { x: middlePointDown[0], y: middlePointDown[1] };
  var q2 = { x: Math.max(1, middlePointDown[0] + LDir), y: middlePointDown[1] };
  var Pmx = findIntersection(a38, b2, L, p9, q2) || { x: (middlePointDown[0] + P2.x) / 2 };
  var P1 = x0;
  var P4 = x1;
  var P22 = (Pmx.x - 0.125 * P1 - 0.125 * P4) / 0.75;
  return xC - P22;
};
var Link = function(SankeyElement2) {
  function Link2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Link2.__proto__ = SankeyElement2;
  Link2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Link2.prototype.constructor = Link2;
  Link2.prototype.getElement = function getElement() {
    var link = this.options.link;
    var x0 = link.x0;
    var x1 = link.x1;
    var y0 = link.y0;
    var y1 = link.y1;
    var xC = (x0 + x1) / 2;
    return new drawing_exports.Path(this.visualOptions()).moveTo(x0, y0).curveTo([xC, y0], [xC, y1], [x1, y1]);
  };
  Link2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ link: options.link });
    }
  };
  Link2.prototype.visualOptions = function visualOptions() {
    var options = this.options;
    var link = this.options.link;
    var ariaLabel = this.getLabelText(options);
    return {
      stroke: {
        width: options.link.width,
        color: link.color || options.color,
        opacity: defined(link.opacity) ? link.opacity : options.opacity
      },
      role: "graphics-symbol",
      ariaRoleDescription: "Link",
      ariaLabel
    };
  };
  Link2.prototype.createFocusHighlight = function createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    var ref2 = this.options;
    var link = ref2.link;
    var x0 = link.x0;
    var x1 = link.x1;
    var y0 = link.y0;
    var y1 = link.y1;
    var xC = (x0 + x1) / 2;
    var halfWidth = link.width / 2;
    var offset = calculateControlPointsOffsetX(link, this.options.rtl);
    this._highlight = new drawing_exports.Path({ stroke: this.options.focusHighlight.border, visible: false }).moveTo(x0, y0 + halfWidth).lineTo(x0, y0 - halfWidth).curveTo([xC + offset, y0 - halfWidth], [xC + offset, y1 - halfWidth], [x1, y1 - halfWidth]).lineTo(x1, y1 + halfWidth).curveTo([xC - offset, y1 + halfWidth], [xC - offset, y0 + halfWidth], [x0, y0 + halfWidth]);
  };
  Link2.prototype.focus = function focus(options) {
    if (this._highlight) {
      var ref2 = options || {};
      var highlight = ref2.highlight;
      if (highlight === void 0) highlight = true;
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      var id = this.options.link.sourceId + "->" + this.options.link.targetId;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  };
  Link2.prototype.blur = function blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  };
  return Link2;
}(SankeyElement);
var resolveLinkOptions = function(link, options, sourceNode, targetNode) {
  var linkOptions = deepExtend(
    {},
    options,
    {
      link,
      opacity: link.opacity,
      color: link.color,
      colorType: link.colorType,
      visual: link.visual,
      highlight: link.highlight
    }
  );
  if (linkOptions.colorType === "source") {
    linkOptions.color = sourceNode.options.fill.color;
  } else if (linkOptions.colorType === "target") {
    linkOptions.color = targetNode.options.fill.color;
  }
  return linkOptions;
};

// node_modules/@progress/kendo-charts/dist/es/sankey/label.js
var INSIDE3 = "inside";
var BEFORE = "before";
var AFTER = "after";
var Label = function(SankeyElement2) {
  function Label2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Label2.__proto__ = SankeyElement2;
  Label2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Label2.prototype.constructor = Label2;
  Label2.prototype.getElement = function getElement() {
    var options = deepExtend({}, this.options, this.options.node.label);
    var node = options.node;
    var diagramMinX = options.diagramMinX;
    var diagramMaxX = options.diagramMaxX;
    var text = options.text;
    var offset = options.offset;
    var rtl = options.rtl;
    var position = options.position;
    if (rtl && position !== INSIDE3) {
      position = position === BEFORE ? AFTER : BEFORE;
    }
    if (!options.visible || !text) {
      return null;
    }
    var nodeBox = new box_default(node.x0, node.y0, node.x1, node.y1);
    var visualOptions = this.visualOptions();
    if (rtl && !visualOptions.align) {
      visualOptions.align = "right";
    }
    var textbox = new text_box_default(text, visualOptions);
    textbox.reflow(new box_default());
    var textSizeBox = textbox.box;
    var textY = nodeBox.center().y - textSizeBox.height() / 2;
    var labelAfterLastNode = node.x1 + textSizeBox.width() > diagramMaxX;
    var labelBeforeFirstNode = node.x0 - textSizeBox.width() < diagramMinX;
    var side = position === BEFORE || position === INSIDE3 && labelAfterLastNode ? BEFORE : AFTER;
    if (rtl) {
      side = position === AFTER || position === INSIDE3 && labelBeforeFirstNode ? AFTER : BEFORE;
    }
    var textOrigin = [side === BEFORE ? node.x0 - textSizeBox.width() : node.x1, textY];
    var textRect = new box_default(textOrigin[0], textOrigin[1], textOrigin[0] + textSizeBox.width(), textOrigin[1] + textSizeBox.height());
    textRect.translate(offset.left || 0, offset.top || 0);
    textbox.reflow(textRect);
    textbox.renderVisual();
    return textbox.visual;
  };
  Label2.prototype.visualOptions = function visualOptions() {
    var options = deepExtend({}, this.options, this.options.node.label);
    return {
      color: options.color,
      font: options.font,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      align: options.align,
      paintOrder: options.paintOrder,
      stroke: options.stroke
    };
  };
  return Label2;
}(SankeyElement);
setDefaultOptions(Label, {
  position: INSIDE3
  // inside, before, after
});
var resolveLabelOptions = function(node, options, rtl, diagramMinX, diagramMaxX) {
  return deepExtend(
    {},
    options,
    {
      node,
      diagramMinX,
      diagramMaxX,
      rtl,
      visual: node.label.visual,
      visible: node.label.visible,
      margin: node.label.margin,
      padding: node.label.padding,
      border: node.label.border,
      align: node.label.align,
      offset: node.label.offset
    }
  );
};

// node_modules/@progress/kendo-charts/dist/es/sankey/title.js
var Title2 = function(SankeyElement2) {
  function Title3() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Title3.__proto__ = SankeyElement2;
  Title3.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Title3.prototype.constructor = Title3;
  Title3.prototype.getElement = function getElement() {
    var options = this.options;
    var drawingRect = options.drawingRect;
    var text = options.text;
    if (options.visible === false || !text) {
      return null;
    }
    var title3 = title_default.buildTitle(text, options);
    title3.reflow(drawingRect);
    title3.renderVisual();
    return title3.visual;
  };
  Title3.prototype.createElement = function createElement93() {
    return this.getElement();
  };
  return Title3;
}(SankeyElement);
setDefaultOptions(Title2, {
  align: CENTER,
  // 'left', 'right', 'center'
  border: {
    width: 0
  },
  margin: getSpacing(5),
  padding: getSpacing(5)
});

// node_modules/@progress/kendo-charts/dist/es/sankey/legend.js
var sortData = function(a38, b2) {
  if (a38.node.x0 - b2.node.x0 !== 0) {
    return a38.node.x0 - b2.node.x0;
  }
  return a38.node.y0 - b2.node.y0;
};
var sortDataRTL = function(a38, b2) {
  if (a38.node.x1 - b2.node.x1 !== 0) {
    return a38.node.x1 - b2.node.x1;
  }
  return b2.node.y0 - a38.node.y0;
};
var sort = function(rtl) {
  return rtl ? sortDataRTL : sortData;
};
var Legend2 = function(SankeyElement2) {
  function Legend3() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Legend3.__proto__ = SankeyElement2;
  Legend3.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Legend3.prototype.constructor = Legend3;
  Legend3.prototype.getElement = function getElement() {
    var options = this.options;
    var drawingRect = options.drawingRect;
    var rtl = options.rtl;
    var nodes = options.nodes;
    if (nodes === void 0) nodes = [];
    var item = options.item;
    var position = options.position;
    if (options.visible === false || !nodes.length) {
      return null;
    }
    var data = nodes.map(function(node) {
      return {
        text: node.label && node.label.text || "",
        area: {
          background: item.areaBackground !== void 0 ? item.areaBackground : node.color,
          opacity: item.areaOpacity !== void 0 ? item.areaOpacity : node.opacity
        },
        node
      };
    });
    data.sort(sort(rtl));
    var reverse = rtl && position !== LEFT && position !== RIGHT;
    var legend2 = new legend_default(Object.assign({}, options, { data, reverse }), { rtl });
    legend2.reflow(drawingRect);
    legend2.renderVisual();
    return legend2.visual;
  };
  Legend3.prototype.createElement = function createElement93() {
    return this.getElement();
  };
  return Legend3;
}(SankeyElement);
setDefaultOptions(Legend2, {
  markers: { visible: false },
  item: {
    type: AREA,
    cursor: POINTER,
    opacity: 1
  },
  position: BOTTOM,
  align: CENTER,
  accessibility: {
    role: "presentation",
    ariaLabel: null,
    ariaRoleDescription: null
  },
  border: {
    width: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/sankey.js
var LINK = "link";
var NODE = "node";
var toRtl = function(sankey) {
  var nodes = sankey.nodes;
  var links = sankey.links;
  var startX = Math.min.apply(Math, nodes.map(function(node) {
    return node.x0;
  }));
  var endX = Math.max.apply(Math, nodes.map(function(node) {
    return node.x1;
  }));
  var width = endX - startX;
  nodes.forEach(function(node) {
    var x0 = width - (node.x1 - 2 * startX);
    var x1 = width - (node.x0 - 2 * startX);
    node.x0 = x0;
    node.x1 = x1;
  });
  links.forEach(function(link) {
    var x0 = width - (link.x1 - 2 * startX);
    var x1 = width - (link.x0 - 2 * startX);
    link.x1 = x0;
    link.x0 = x1;
  });
};
var Sankey3 = function(Observable2) {
  function Sankey4(element, options, theme) {
    Observable2.call(this);
    this._initTheme(theme);
    this._setOptions(options);
    this._initElement(element);
    this._initSurface();
    if (options && options.data) {
      this._redraw();
      this._initResizeObserver();
      this._initNavigation(element);
    }
  }
  if (Observable2) Sankey4.__proto__ = Observable2;
  Sankey4.prototype = Object.create(Observable2 && Observable2.prototype);
  Sankey4.prototype.constructor = Sankey4;
  Sankey4.prototype.destroy = function destroy() {
    this.unbind();
    this._destroySurface();
    this._destroyResizeObserver();
    if (this.element) {
      this.element.removeEventListener("keydown", this._keydownHandler);
      this.element.removeEventListener("focus", this._focusHandler);
      this.element.removeEventListener("mousedown", this._onDownHandler);
      this.element.removeEventListener("touchstart", this._onDownHandler);
      this.element.removeEventListener("pointerdown", this._onDownHandler);
    }
    this._focusState = null;
    this.element = null;
  };
  Sankey4.prototype._initElement = function _initElement(element) {
    this.element = element;
    addClass(element, ["k-chart", "k-sankey"]);
    element.setAttribute("role", "graphics-document");
    var ref2 = this.options;
    var title3 = ref2.title;
    if (title3.text) {
      element.setAttribute("aria-label", title3.text);
    }
    if (title3.description) {
      element.setAttribute("aria-roledescription", title3.description);
    }
  };
  Sankey4.prototype._initSurface = function _initSurface() {
    if (!this.surface) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Sankey4.prototype._initNavigation = function _initNavigation(element) {
    element.tabIndex = element.getAttribute("tabindex") || 0;
    if (this.options.disableKeyboardNavigation) {
      return;
    }
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._onDownHandler = this._onDown.bind(this);
    element.addEventListener("keydown", this._keydownHandler);
    element.addEventListener("focus", this._focusHandler);
    element.addEventListener("blur", this._blurHandler);
    element.addEventListener("mousedown", this._onDownHandler);
    element.addEventListener("touchstart", this._onDownHandler);
    element.addEventListener("pointerdown", this._onDownHandler);
    this._focusState = {
      node: this.firstFocusableNode(),
      link: null
    };
  };
  Sankey4.prototype.firstFocusableNode = function firstFocusableNode() {
    return this.columns[0][0];
  };
  Sankey4.prototype._initResizeObserver = function _initResizeObserver() {
    var this$1 = this;
    var observer = new ResizeObserver(function(entries) {
      entries.forEach(function(entry) {
        var ref2 = entry.contentRect;
        var width = ref2.width;
        var height = ref2.height;
        if (entry.target !== this$1.element || this$1.size && this$1.size.width === width && this$1.size.height === height) {
          return;
        }
        this$1.size = { width, height };
        this$1.surface.setSize(this$1.size);
        this$1.resize = true;
        this$1._redraw();
      });
    });
    this._resizeObserver = observer;
    observer.observe(this.element);
  };
  Sankey4.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      mouseenter: this._mouseenter.bind(this),
      mouseleave: this._mouseleave.bind(this),
      mousemove: this._mousemove.bind(this),
      click: this._click.bind(this)
    });
  };
  Sankey4.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
  };
  Sankey4.prototype.setLinksOpacity = function setLinksOpacity(opacity) {
    var this$1 = this;
    this.linksVisuals.forEach(function(link) {
      this$1.setOpacity(link, opacity, link.linkOptions.opacity);
    });
  };
  Sankey4.prototype.setLinksInactivityOpacity = function setLinksInactivityOpacity(inactiveOpacity) {
    var this$1 = this;
    this.linksVisuals.forEach(function(link) {
      this$1.setOpacity(link, inactiveOpacity, link.linkOptions.highlight.inactiveOpacity);
    });
  };
  Sankey4.prototype.setOpacity = function setOpacity(link, opacity, linkValue) {
    link.options.set("stroke", Object.assign(
      {},
      link.options.stroke,
      { opacity: defined(linkValue) ? linkValue : opacity }
    ));
  };
  Sankey4.prototype.trigger = function trigger2(name2, ev) {
    var dataItem = ev.element.dataItem;
    var targetType = ev.element.type;
    var event = Object.assign(
      {},
      ev,
      {
        type: name2,
        targetType,
        dataItem
      }
    );
    return Observable2.prototype.trigger.call(this, name2, event);
  };
  Sankey4.prototype._mouseenter = function _mouseenter(ev) {
    var element = ev.element;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    if (isLink && this.trigger("linkEnter", ev) || isNode && this.trigger("nodeEnter", ev)) {
      return;
    }
    var ref2 = this.options.links;
    var highlight = ref2.highlight;
    if (isLink) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      this.setOpacity(element, highlight.opacity, element.linkOptions.highlight.opacity);
    } else if (isNode) {
      this.highlightLinks(element, highlight);
    } else if (isLegendItem) {
      var nodeVisual = this.nodesVisuals.get(element.chartElement.options.node.id);
      this.highlightLinks(nodeVisual, highlight);
    }
  };
  Sankey4.prototype._mouseleave = function _mouseleave(ev) {
    var this$1 = this;
    var element = ev.element;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    var target = ev.originalEvent.relatedTarget;
    if (isLink && target && target.nodeName === "text") {
      return;
    }
    if (isLink || isNode) {
      if (this.tooltipTimeOut) {
        clearTimeout(this.tooltipTimeOut);
        this.tooltipTimeOut = null;
      }
      this.tooltipShown = false;
      this.trigger("tooltipHide", ev);
    }
    if (isLink && this.trigger("linkLeave", ev) || isNode && this.trigger("nodeLeave", ev)) {
      return;
    }
    if (isLink || isNode || isLegendItem) {
      this.linksVisuals.forEach(function(link) {
        this$1.setOpacity(link, this$1.options.links.opacity, link.linkOptions.opacity);
      });
    }
  };
  Sankey4.prototype._mousemove = function _mousemove(ev) {
    var this$1 = this;
    var ref2 = this.options.tooltip;
    var followPointer = ref2.followPointer;
    var delay = ref2.delay;
    var element = ev.element;
    var tooltipElType = element.type;
    if (tooltipElType !== LINK && tooltipElType !== NODE || this.tooltipShown && !followPointer) {
      return;
    }
    var mouseEvent = ev.originalEvent;
    var rect = this.element.getBoundingClientRect();
    var isLeft = mouseEvent.clientX - rect.left < rect.width / 2;
    var isTop = mouseEvent.clientY - rect.top < rect.height / 2;
    ev.tooltipData = {
      popupOffset: {
        left: mouseEvent.pageX,
        top: mouseEvent.pageY
      },
      popupAlign: {
        horizontal: isLeft ? "left" : "right",
        vertical: isTop ? "top" : "bottom"
      }
    };
    if (tooltipElType === NODE) {
      var ref$1 = element.dataItem;
      var sourceLinks = ref$1.sourceLinks;
      var targetLinks = ref$1.targetLinks;
      var links = targetLinks.length ? targetLinks : sourceLinks;
      ev.nodeValue = links.reduce(function(acc, link) {
        return acc + link.value;
      }, 0);
    }
    if (this.tooltipTimeOut) {
      clearTimeout(this.tooltipTimeOut);
      this.tooltipTimeOut = null;
    }
    var nextDelay = followPointer && this.tooltipShown ? 0 : delay;
    this.tooltipTimeOut = setTimeout(function() {
      this$1.trigger("tooltipShow", ev);
      this$1.tooltipShown = true;
      this$1.tooltipTimeOut = null;
    }, nextDelay);
  };
  Sankey4.prototype._click = function _click(ev) {
    var element = ev.element;
    var dataItem = element.dataItem;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var focusState = this._focusState || {};
    if (isNode) {
      var focusedNodeClicked = !focusState.link && this.sameNode(focusState.node, dataItem);
      if (!focusedNodeClicked) {
        this._focusState = { node: dataItem, link: null };
        this._focusNode({ highlight: false });
      }
      this.trigger("nodeClick", ev);
    } else if (isLink) {
      var link = {
        sourceId: dataItem.source.id,
        targetId: dataItem.target.id,
        value: dataItem.value
      };
      var focusedLinkClicked = this.sameLink(focusState.link, link);
      if (!focusedLinkClicked) {
        this._focusState = { node: dataItem.source, link };
        this._focusLink({ highlight: false });
      }
      this.trigger("linkClick", ev);
    }
  };
  Sankey4.prototype.sameNode = function sameNode(node1, node2) {
    return node1 && node2 && node1.id === node2.id;
  };
  Sankey4.prototype.sameLink = function sameLink(link1, link2) {
    return link1 && link2 && link1.sourceId === link2.sourceId && link1.targetId === link2.targetId;
  };
  Sankey4.prototype._focusNode = function _focusNode(options) {
    this._cleanFocusHighlight();
    var nodeData = this._focusState.node;
    var node = this.models.map.get(nodeData.id);
    node.focus(options);
  };
  Sankey4.prototype._focusLink = function _focusLink(options) {
    this._cleanFocusHighlight();
    var linkData = this._focusState.link;
    var link = this.models.map.get(linkData.sourceId + "-" + linkData.targetId);
    link.focus(options);
  };
  Sankey4.prototype._focusNextNode = function _focusNextNode(direction) {
    if (direction === void 0) direction = 1;
    var current4 = this._focusState.node;
    var columnIndex = this.columns.findIndex(function(column) {
      return column.find(function(n20) {
        return n20.id === current4.id;
      });
    });
    var columnNodes = this.columns[columnIndex];
    var nodeIndex = columnNodes.findIndex(function(n20) {
      return n20.id === current4.id;
    });
    var nextNode = columnNodes[nodeIndex + direction];
    if (nextNode) {
      this._focusState.node = nextNode;
      this._focusNode();
    }
  };
  Sankey4.prototype._focusNextLink = function _focusNextLink(direction) {
    if (direction === void 0) direction = 1;
    var node = this._focusState.node;
    var link = this._focusState.link;
    var sourceLinkIndex = node.sourceLinks.findIndex(function(l8) {
      return l8.sourceId === link.sourceId && l8.targetId === link.targetId;
    });
    var targetLinkIndex = node.targetLinks.findIndex(function(l8) {
      return l8.sourceId === link.sourceId && l8.targetId === link.targetId;
    });
    if (sourceLinkIndex !== -1) {
      var nextLink = node.sourceLinks[sourceLinkIndex + direction];
      if (nextLink) {
        this._focusState.link = nextLink;
        this._focusLink();
      }
    } else if (targetLinkIndex !== -1) {
      var nextLink$1 = node.targetLinks[targetLinkIndex + direction];
      if (nextLink$1) {
        this._focusState.link = nextLink$1;
        this._focusLink();
      }
    }
  };
  Sankey4.prototype._focusSourceNode = function _focusSourceNode() {
    var linkData = this._focusState.link;
    var sourceNode = this.models.map.get(linkData.sourceId);
    this._focusState = { node: sourceNode.options.node, link: null };
    this._focusNode();
  };
  Sankey4.prototype._focusTargetNode = function _focusTargetNode() {
    var linkData = this._focusState.link;
    var targetNode = this.models.map.get(linkData.targetId);
    this._focusState = { node: targetNode.options.node, link: null };
    this._focusNode();
  };
  Sankey4.prototype._focusSourceLink = function _focusSourceLink() {
    var nodeData = this._focusState.node;
    var sourceLinks = nodeData.sourceLinks;
    var linkData = sourceLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  };
  Sankey4.prototype._focusTargetLink = function _focusTargetLink() {
    var nodeData = this._focusState.node;
    var targetLinks = nodeData.targetLinks;
    var linkData = targetLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  };
  Sankey4.prototype._focus = function _focus() {
    if (!this._skipFocusHighlight) {
      if (this._focusState.link) {
        this._focusLink();
      } else {
        this._focusNode();
      }
    }
    this._skipFocusHighlight = false;
  };
  Sankey4.prototype._blur = function _blur() {
    this._cleanFocusHighlight();
  };
  Sankey4.prototype._onDown = function _onDown() {
    if (!this._hasFocus()) {
      this._skipFocusHighlight = true;
    }
  };
  Sankey4.prototype._hasFocus = function _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  };
  Sankey4.prototype._cleanFocusHighlight = function _cleanFocusHighlight() {
    this.models.nodes.forEach(function(node) {
      return node.blur();
    });
    this.models.links.forEach(function(link) {
      return link.blur();
    });
  };
  Sankey4.prototype._keydown = function _keydown(ev) {
    var handler = this["on" + ev.key];
    var rtl = this.options.rtl;
    if (rtl && ev.key === "ArrowLeft") {
      handler = this.onArrowRight;
    } else if (rtl && ev.key === "ArrowRight") {
      handler = this.onArrowLeft;
    }
    if (handler) {
      handler.call(this, ev);
    }
  };
  Sankey4.prototype.onEscape = function onEscape(ev) {
    ev.preventDefault();
    this._focusState = { node: this.firstFocusableNode(), link: null };
    this._focusNode();
  };
  Sankey4.prototype.onArrowDown = function onArrowDown(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(1);
    } else {
      this._focusNextNode(1);
    }
  };
  Sankey4.prototype.onArrowUp = function onArrowUp(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(-1);
    } else {
      this._focusNextNode(-1);
    }
  };
  Sankey4.prototype.onArrowLeft = function onArrowLeft(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusSourceNode();
    } else {
      this._focusTargetLink();
    }
  };
  Sankey4.prototype.onArrowRight = function onArrowRight(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusTargetNode();
    } else {
      this._focusSourceLink();
    }
  };
  Sankey4.prototype.highlightLinks = function highlightLinks(node, highlight) {
    var this$1 = this;
    if (node) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      node.links.forEach(function(link) {
        this$1.setOpacity(link, highlight.opacity, link.linkOptions.highlight.opacity);
      });
    }
  };
  Sankey4.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Sankey4.prototype._destroyResizeObserver = function _destroyResizeObserver() {
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
  };
  Sankey4.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
  };
  Sankey4.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Sankey4.prototype.setOptions = function setOptions(options, theme) {
    this._setOptions(options);
    this._initTheme(theme);
    this._initSurface();
    this._redraw();
  };
  Sankey4.prototype._redraw = function _redraw() {
    this.surface.clear();
    var ref2 = this._getSize();
    var width = ref2.width;
    var height = ref2.height;
    this.size = { width, height };
    this.surface.setSize(this.size);
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Sankey4.prototype._getSize = function _getSize() {
    return this.element.getBoundingClientRect();
  };
  Sankey4.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Sankey4.prototype.titleBox = function titleBox(title3, drawingRect) {
    if (!title3 || title3.visible === false || !title3.text) {
      return null;
    }
    var titleElement = new Title2(Object.assign({}, { drawingRect }, title3));
    var titleVisual = titleElement.exportVisual();
    return titleVisual.chartElement.box;
  };
  Sankey4.prototype.legendBox = function legendBox(options, nodes, drawingRect) {
    if (!options || options.visible === false) {
      return null;
    }
    var legend2 = new Legend2(Object.assign({}, { nodes }, options, { drawingRect }));
    var legendVisual = legend2.exportVisual();
    return legendVisual.chartElement.box;
  };
  Sankey4.prototype.calculateSankey = function calculateSankey$1(calcOptions, sankeyOptions) {
    var title3 = sankeyOptions.title;
    var legend2 = sankeyOptions.legend;
    var data = sankeyOptions.data;
    var nodes = sankeyOptions.nodes;
    var labels = sankeyOptions.labels;
    var nodeColors = sankeyOptions.nodeColors;
    var disableAutoLayout = sankeyOptions.disableAutoLayout;
    var disableKeyboardNavigation = sankeyOptions.disableKeyboardNavigation;
    var rtl = sankeyOptions.rtl;
    var autoLayout = !disableAutoLayout;
    var focusHighlightWidth = ((nodes.focusHighlight || {}).border || {}).width || 0;
    var padding = disableKeyboardNavigation ? 0 : focusHighlightWidth / 2;
    var sankeyBox = new box_default(0, 0, calcOptions.width, calcOptions.height);
    sankeyBox.unpad(padding);
    var titleBox = this.titleBox(title3, sankeyBox);
    var legendArea = sankeyBox.clone();
    if (titleBox) {
      var titleHeight = titleBox.height();
      if (title3.position === TOP) {
        sankeyBox.unpad({ top: titleHeight });
        legendArea = new box_default(0, titleHeight, calcOptions.width, calcOptions.height);
      } else {
        sankeyBox.shrink(0, titleHeight);
        legendArea = new box_default(0, 0, calcOptions.width, calcOptions.height - titleHeight);
      }
    }
    var legendBox = this.legendBox(legend2, data.nodes, legendArea);
    var legendPosition = legend2 && legend2.position || Legend2.prototype.options.position;
    if (legendBox) {
      if (legendPosition === LEFT) {
        sankeyBox.unpad({ left: legendBox.width() });
      }
      if (legendPosition === RIGHT) {
        sankeyBox.shrink(legendBox.width(), 0);
      }
      if (legendPosition === TOP) {
        sankeyBox.unpad({ top: legendBox.height() });
      }
      if (legendPosition === BOTTOM) {
        sankeyBox.shrink(0, legendBox.height());
      }
    }
    var ref2 = calculateSankey(Object.assign({}, calcOptions, { offsetX: 0, offsetY: 0, width: sankeyBox.width(), height: sankeyBox.height() }));
    var calculatedNodes = ref2.nodes;
    var circularLinks = ref2.circularLinks;
    if (circularLinks) {
      console.warn("Circular links detected. Kendo Sankey diagram does not support circular links.");
      return { sankey: { nodes: [], links: [], columns: [[]], circularLinks }, legendBox, titleBox };
    }
    var box = new box_default();
    var diagramMinX = calculatedNodes.reduce(function(acc, node) {
      return Math.min(acc, node.x0);
    }, Infinity);
    var diagramMaxX = calculatedNodes.reduce(function(acc, node) {
      return Math.max(acc, node.x1);
    }, 0);
    calculatedNodes.forEach(function(nodeEl, i36) {
      if (rtl) {
        var x0 = nodeEl.x0;
        var x1 = nodeEl.x1;
        nodeEl.x0 = diagramMaxX - x1;
        nodeEl.x1 = diagramMaxX - x0;
      }
      var nodeOps = resolveNodeOptions(nodeEl, nodes, nodeColors, i36);
      var nodeInstance = new Node(nodeOps);
      box.wrap(rectToBox(nodeInstance.exportVisual().rawBBox()));
      var labelInstance = new Label(resolveLabelOptions(nodeEl, labels, rtl, diagramMinX, diagramMaxX));
      var labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        box.wrap(rectToBox(labelVisual.rawBBox()));
      }
    });
    var offsetX = sankeyBox.x1;
    var offsetY = sankeyBox.y1;
    var width = sankeyBox.width() + offsetX;
    var height = sankeyBox.height() + offsetY;
    width -= box.x2 > sankeyBox.width() ? box.x2 - sankeyBox.width() : 0;
    height -= box.y2 > sankeyBox.height() ? box.y2 - sankeyBox.height() : 0;
    offsetX += box.x1 < 0 ? -box.x1 : 0;
    offsetY += box.y1 < 0 ? -box.y1 : 0;
    if (autoLayout === false) {
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })),
        legendBox,
        titleBox
      };
    }
    if (this.resize && autoLayout && this.permutation) {
      this.resize = false;
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation)),
        legendBox,
        titleBox
      };
    }
    var startColumn = 1;
    var loops = 2;
    var columnsLength = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })).columns.length;
    var results = [];
    var permutation = function(targetColumnIndex, reverse) {
      var currPerm = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, loops, targetColumnIndex, reverse }));
      var crosses = crossesValue(currPerm.links);
      results.push({
        crosses,
        reverse,
        targetColumnIndex
      });
      return crosses === 0;
    };
    for (var index = startColumn; index <= columnsLength - 1; index++) {
      if (permutation(index, false) || permutation(index, true)) {
        break;
      }
    }
    var minCrosses = Math.min.apply(null, results.map(function(r27) {
      return r27.crosses;
    }));
    var bestResult = results.find(function(r27) {
      return r27.crosses === minCrosses;
    });
    this.permutation = { targetColumnIndex: bestResult.targetColumnIndex, reverse: bestResult.reverse };
    var result = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation));
    return {
      sankey: result,
      legendBox,
      titleBox
    };
  };
  Sankey4.prototype._render = function _render(options, context) {
    var sankeyOptions = options || this.options;
    var sankeyContext = context || this;
    var labelOptions = sankeyOptions.labels;
    var nodesOptions = sankeyOptions.nodes;
    var linkOptions = sankeyOptions.links;
    var nodeColors = sankeyOptions.nodeColors;
    var title3 = sankeyOptions.title;
    var legend2 = sankeyOptions.legend;
    var rtl = sankeyOptions.rtl;
    var disableKeyboardNavigation = sankeyOptions.disableKeyboardNavigation;
    var data = sankeyOptions.data;
    var ref2 = sankeyContext.size;
    var width = ref2.width;
    var height = ref2.height;
    var calcOptions = Object.assign({}, data, { width, height, nodesOptions, title: title3, legend: legend2 });
    var ref$1 = this.calculateSankey(calcOptions, sankeyOptions);
    var sankey = ref$1.sankey;
    var titleBox = ref$1.titleBox;
    var legendBox = ref$1.legendBox;
    if (rtl) {
      toRtl(sankey);
    }
    var nodes = sankey.nodes;
    var links = sankey.links;
    var columns = sankey.columns;
    sankeyContext.columns = columns.map(function(column) {
      var newColumn = column.slice();
      newColumn.sort(function(a38, b2) {
        return a38.y0 - b2.y0;
      });
      return newColumn;
    });
    var visual = new drawing_exports.Group({
      clip: drawing_exports.Path.fromRect(new geometry_exports.Rect([0, 0], [width, height]))
    });
    if (titleBox) {
      var titleElement = new Title2(Object.assign({}, title3, { drawingRect: titleBox }));
      var titleVisual = titleElement.exportVisual();
      visual.append(titleVisual);
    }
    if (sankey.circularLinks) {
      return visual;
    }
    var visualNodes = /* @__PURE__ */ new Map();
    sankeyContext.nodesVisuals = visualNodes;
    var models = {
      nodes: [],
      links: [],
      map: /* @__PURE__ */ new Map()
    };
    sankeyContext.models = models;
    var focusHighlights = [];
    nodes.forEach(function(node, i36) {
      var nodeOps = resolveNodeOptions(node, nodesOptions, nodeColors, i36);
      nodeOps.root = function() {
        return sankeyContext.element;
      };
      nodeOps.navigatable = disableKeyboardNavigation !== true;
      var nodeInstance = new Node(nodeOps);
      var nodeVisual = nodeInstance.exportVisual();
      nodeVisual.links = [];
      nodeVisual.type = NODE;
      node.color = nodeOps.color;
      node.opacity = nodeOps.opacity;
      nodeVisual.dataItem = Object.assign(
        {},
        data.nodes[i36],
        {
          color: nodeOps.color,
          opacity: nodeOps.opacity,
          sourceLinks: node.sourceLinks.map(function(link) {
            return { sourceId: link.sourceId, targetId: link.targetId, value: link.value };
          }),
          targetLinks: node.targetLinks.map(function(link) {
            return { sourceId: link.sourceId, targetId: link.targetId, value: link.value };
          })
        }
      );
      visualNodes.set(node.id, nodeVisual);
      models.nodes.push(nodeInstance);
      models.map.set(node.id, nodeInstance);
      visual.append(nodeVisual);
      nodeInstance.createFocusHighlight();
      if (nodeInstance._highlight) {
        focusHighlights.push(nodeInstance._highlight);
      }
    });
    var sortedLinks = links.slice().sort(function(a38, b2) {
      return b2.value - a38.value;
    });
    var linksVisuals = [];
    sankeyContext.linksVisuals = linksVisuals;
    sortedLinks.forEach(function(link) {
      var source = link.source;
      var target = link.target;
      var sourceNode = visualNodes.get(source.id);
      var targetNode = visualNodes.get(target.id);
      var resolvedOptions = resolveLinkOptions(link, linkOptions, sourceNode, targetNode);
      resolvedOptions.root = function() {
        return sankeyContext.element;
      };
      resolvedOptions.navigatable = disableKeyboardNavigation !== true;
      resolvedOptions.rtl = rtl;
      var linkInstance = new Link(resolvedOptions);
      var linkVisual = linkInstance.exportVisual();
      linkVisual.type = LINK;
      linkVisual.dataItem = {
        source: Object.assign({}, sourceNode.dataItem),
        target: Object.assign({}, targetNode.dataItem),
        value: link.value
      };
      linkVisual.linkOptions = resolvedOptions;
      linksVisuals.push(linkVisual);
      sourceNode.links.push(linkVisual);
      targetNode.links.push(linkVisual);
      models.links.push(linkInstance);
      models.map.set(source.id + "-" + target.id, linkInstance);
      linkInstance.createFocusHighlight();
      if (linkInstance._highlight) {
        focusHighlights.push(linkInstance._highlight);
      }
      visual.append(linkVisual);
    });
    var diagramMinX = nodes.reduce(function(acc, node) {
      return Math.min(acc, node.x0);
    }, Infinity);
    var diagramMaxX = nodes.reduce(function(acc, node) {
      return Math.max(acc, node.x1);
    }, 0);
    nodes.forEach(function(node) {
      var textOps = resolveLabelOptions(node, labelOptions, rtl, diagramMinX, diagramMaxX);
      var labelInstance = new Label(textOps);
      var labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        visual.append(labelVisual);
      }
    });
    if (legendBox) {
      var legendElement = new Legend2(Object.assign({}, legend2, { rtl, drawingRect: legendBox, nodes }));
      var legendVisual = legendElement.exportVisual();
      visual.append(legendVisual);
    }
    if (focusHighlights.length !== 0) {
      var focusHighlight = new drawing_exports.Group();
      focusHighlight.append.apply(focusHighlight, focusHighlights);
      visual.append(focusHighlight);
    }
    return visual;
  };
  Sankey4.prototype.exportVisual = function exportVisual(exportOptions) {
    var options = exportOptions && exportOptions.options ? deepExtend({}, this.options, exportOptions.options) : this.options;
    var context = {
      size: {
        width: defined(exportOptions && exportOptions.width) ? exportOptions.width : this.size.width,
        height: defined(exportOptions && exportOptions.height) ? exportOptions.height : this.size.height
      }
    };
    return this._render(options, context);
  };
  Sankey4.prototype._setOptions = function _setOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  return Sankey4;
}(observable_default);
var highlightOptions = {
  opacity: 1,
  width: 2,
  color: BLACK
};
setDefaultOptions(Sankey3, {
  title: {
    position: TOP
    // 'top', 'bottom'
  },
  labels: {
    visible: true,
    margin: {
      left: 8,
      right: 8
    },
    padding: 0,
    border: {
      width: 0
    },
    paintOrder: "stroke",
    stroke: {
      lineJoin: "round",
      width: 1
    },
    offset: { left: 0, top: 0 }
  },
  nodes: {
    width: 24,
    padding: 16,
    opacity: 1,
    align: "stretch",
    // 'left', 'right', 'stretch'
    offset: { left: 0, top: 0 },
    focusHighlight: {
      border: Object.assign({}, highlightOptions)
    },
    labels: {
      ariaTemplate: function(ref2) {
        var node = ref2.node;
        return node.label.text;
      }
    }
  },
  links: {
    colorType: "static",
    // 'source', 'target', 'static'
    opacity: 0.4,
    highlight: {
      opacity: 0.8,
      inactiveOpacity: 0.2
    },
    focusHighlight: {
      border: Object.assign({}, highlightOptions)
    },
    labels: {
      ariaTemplate: function(ref2) {
        var link = ref2.link;
        return link.source.label.text + " to " + link.target.label.text;
      }
    }
  },
  tooltip: {
    followPointer: false,
    delay: 200
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/utils.js
var createSankeyData = function(data, dimensions, measure) {
  var nodes = /* @__PURE__ */ new Set();
  var links = /* @__PURE__ */ new Map();
  var linksMap = /* @__PURE__ */ new Map();
  data.forEach(function(row) {
    dimensions.forEach(function(dimension) {
      nodes.add(dimension.value(row));
    });
    for (var i36 = 0; i36 < dimensions.length - 1; i36++) {
      var source = dimensions[i36].value(row);
      var target = dimensions[i36 + 1].value(row);
      var key = source + "_" + target;
      var value2 = measure.value(row);
      var existingValue = links.get(key);
      if (existingValue !== void 0) {
        links.set(key, existingValue + value2);
      } else {
        links.set(key, value2);
        linksMap.set(key, { source, target });
      }
    }
  });
  var nodesId = /* @__PURE__ */ new Map();
  var nodesArray = Array.from(nodes).map(function(node, index) {
    nodesId.set(node, index);
    return { id: index, label: { text: String(node) } };
  });
  var linksArray = Array.from(links).map(function(ref2) {
    var key = ref2[0];
    var value2 = ref2[1];
    var ref$1 = linksMap.get(key);
    var source = ref$1.source;
    var target = ref$1.target;
    return {
      sourceId: nodesId.get(source),
      targetId: nodesId.get(target),
      value: value2
    };
  });
  return { nodes: nodesArray, links: linksArray };
};

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/get-wizard-data-from-data-rows.js
function getWizardDataFromDataRows(dataRows) {
  var result = [];
  dataRows.forEach(function(item) {
    var dataItem = item.dataItem;
    var dataColumns = item.dataColumns;
    var row = [];
    dataColumns.forEach(function(column) {
      row.push({
        field: column.title || column.field,
        value: getter(column.field)(dataItem)
      });
    });
    result.push(row);
  });
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/state.js
var ActionTypes = Object.freeze({
  seriesType: 0,
  stacked: 1,
  categoryAxisX: 2,
  valueAxisY: 3,
  seriesChange: 4,
  areaMarginLeft: 5,
  areaMarginRight: 6,
  areaMarginTop: 7,
  areaMarginBottom: 8,
  areaBackground: 9,
  titleText: 10,
  titleFontName: 11,
  titleFontSize: 12,
  titleColor: 13,
  subtitleText: 14,
  subtitleFontName: 15,
  subtitleFontSize: 16,
  subtitleColor: 17,
  seriesColor: 18,
  seriesLabel: 19,
  legendVisible: 20,
  legendFontName: 21,
  legendFontSize: 22,
  legendColor: 23,
  legendPosition: 24,
  categoryAxisTitleText: 25,
  categoryAxisTitleFontName: 26,
  categoryAxisTitleFontSize: 27,
  categoryAxisTitleColor: 28,
  categoryAxisLabelsFontName: 29,
  categoryAxisLabelsFontSize: 30,
  categoryAxisLabelsColor: 31,
  categoryAxisLabelsRotation: 32,
  categoryAxisReverseOrder: 33,
  valueAxisTitleText: 34,
  valueAxisTitleFontName: 35,
  valueAxisTitleFontSize: 36,
  valueAxisTitleColor: 37,
  valueAxisLabelsFormat: 38,
  valueAxisLabelsFontName: 39,
  valueAxisLabelsFontSize: 40,
  valueAxisLabelsColor: 41,
  valueAxisLabelsRotation: 42
});
var fontSizes = [
  { text: "10", value: "10px" },
  { text: "12", value: "12px" },
  { text: "14", value: "14px" },
  { text: "16", value: "16px" },
  { text: "20", value: "20px" },
  { text: "28", value: "28px" },
  { text: "42", value: "42px" },
  { text: "56", value: "56px" }
];
var titleSizeDefault = "20px";
var subtitleSizeDefault = "16px";
var labelSizeDefault = "12px";
var axisTitleSizeDefault = "16px";
var fontNames = [
  {
    text: "Arial",
    value: "Arial, Helvetica, sans-serif",
    style: { fontFamily: "Arial, Helvetica, sans-serif" }
  },
  {
    text: "Courier New",
    value: "'Courier New', Courier, monospace",
    style: { fontFamily: "'Courier New', Courier, monospace" }
  },
  {
    text: "Georgia",
    value: "Georgia, serif",
    style: { fontFamily: "Georgia, serif" }
  },
  {
    text: "Impact",
    value: "Impact, Charcoal, sans-serif",
    style: { fontFamily: "Impact, Charcoal, sans-serif" }
  },
  {
    text: "Lucida Console",
    value: "'Lucida Console', Monaco, monospace",
    style: { fontFamily: "'Lucida Console', Monaco, monospace" }
  },
  {
    text: "Tahoma",
    value: "Tahoma, Geneva, sans-serif",
    style: { fontFamily: "Tahoma, Geneva, sans-serif" }
  },
  {
    text: "Times New Roman",
    value: "'Times New Roman', Times,serif",
    style: { fontFamily: "'Times New Roman', Times,serif" }
  },
  {
    text: "Trebuchet MS",
    value: "'Trebuchet MS', Helvetica, sans-serif",
    style: { fontFamily: "'Trebuchet MS', Helvetica, sans-serif" }
  },
  {
    text: "Verdana",
    value: "Verdana, Geneva, sans-serif",
    style: { fontFamily: "Verdana, Geneva, sans-serif" }
  }
];
var fontNameDefault = fontNames[0].value;
var columnType = "column";
var barType = "bar";
var lineType = "line";
var pieType = "pie";
var scatterType = "scatter";
var categoricalTypes = [columnType, barType, lineType, scatterType];
var scatterSeries = {
  type: lineType,
  width: 0
};
function isCategorical(type) {
  return type && categoricalTypes.includes(type);
}
var categoryTypes = ["string", "date", "number"];
var valueTypes = ["number"];
var axesDefinitions = {
  bar: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  column: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  line: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  pie: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes, count: 1 }
  ],
  scatter: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ]
};
function getFont(font, size) {
  return ((size || "") + " " + (font || "")).trim();
}
function parseFont(font) {
  var spaceIndex = (font || "").indexOf(" ");
  var size = font && font.substring(0, spaceIndex);
  var name2 = font && font.substring(spaceIndex + 1);
  return { size, name: name2 };
}
var updateFontName = function(fontName, defaultSize, currentFont) {
  var ref2 = parseFont(currentFont);
  var size = ref2.size;
  return fontName ? getFont(fontName, size || defaultSize) : "";
};
var updateFontSize = function(fontSize, defaultFontName, currentFont) {
  var ref2 = parseFont(currentFont);
  var name2 = ref2.name;
  return fontSize ? getFont(name2 || defaultFontName, fontSize) : "";
};
var hasValue3 = function(value2) {
  return value2 !== void 0 && value2 !== null;
};
var recordWithValues = function(data) {
  var result = structuredClone(data[0]);
  result.forEach(function(item, i36) {
    if (!hasValue3(item.value)) {
      for (var index = 0; index < data.length; index++) {
        var value2 = data[index][i36].value;
        if (hasValue3(value2)) {
          item.value = value2;
          break;
        }
      }
    }
  });
  return result;
};
var getCategoryColumnIndex = function(data, categoryDef) {
  var candidates = [];
  var sampleRecord = recordWithValues(data);
  categoryDef.types.forEach(function(type) {
    sampleRecord.forEach(function(item, i36) {
      if (typeof item.value === type) {
        candidates.push(i36);
      }
    });
  });
  var result = candidates.findIndex(function(index) {
    var values5 = data.map(function(record) {
      return record[index].value;
    });
    return new Set(values5).size === values5.length;
  });
  return Math.max(result, 0);
};
var getValueColumnIndexes = function(data, valuesDef) {
  var candidates = [];
  var sampleRecord = recordWithValues(data);
  valuesDef.forEach(function(def) {
    def.types.forEach(function(type) {
      sampleRecord.forEach(function(item, i36) {
        if (typeof item.value === type) {
          candidates.push(i36);
        }
      });
    });
  });
  return candidates;
};
var emptyState = function() {
  return structuredClone({
    columns: [],
    data: [],
    series: [],
    initialSeries: [],
    categoryAxis: [{ categories: [], labels: { visible: true, rotation: "auto" }, title: { text: "" } }],
    valueAxis: [{ labels: { visible: true, rotation: "auto" } }],
    area: {
      margin: {
        left: void 0,
        right: void 0,
        top: void 0,
        bottom: void 0
      }
    },
    title: { text: "" },
    subtitle: { text: "" },
    stack: false
  });
};
var categoryValueChartState = function(data, seriesType, options) {
  var state = emptyState();
  state.seriesType = seriesType;
  state.data = data || [];
  state.legend = { visible: true, position: "bottom" };
  var chartDef = axesDefinitions[seriesType];
  if (!chartDef || !data.length) {
    return state;
  }
  var firstRecord = data[0].slice();
  state.columns = data[0].map(function(i36) {
    return String(i36.field);
  });
  var categoryDef = chartDef.find(function(def) {
    return def.axisType === "category";
  });
  var catIndex = -1;
  if (categoryDef) {
    catIndex = options && options.categoryAxis ? state.columns.indexOf(options.categoryAxis) : getCategoryColumnIndex(data, categoryDef);
  }
  var valuesDef = chartDef.filter(function(def) {
    return def.axisType === "value";
  });
  var valuesIndexes = getValueColumnIndexes(data, valuesDef);
  if (valuesIndexes.includes(catIndex)) {
    if (valuesIndexes.length > 1) {
      valuesIndexes = valuesIndexes.filter(function(index) {
        return index !== catIndex;
      });
    } else {
      catIndex = -1;
    }
  }
  var series = [];
  valuesIndexes.forEach(function(index) {
    var valuesColumn = firstRecord[index];
    var valuesResult = [];
    data.forEach(function(record) {
      valuesResult.push(record[index].value);
    });
    series.push(Object.assign(
      {},
      {
        name: valuesColumn.field,
        type: seriesType,
        data: valuesResult,
        stack: false,
        labels: { visible: false }
      },
      seriesType === scatterType ? scatterSeries : {}
    ));
  });
  var categories = catIndex > -1 ? data.map(
    function(item) {
      return String(
        hasValue3(item[catIndex].value) ? item[catIndex].value : " "
      );
    }
  ) : [];
  if (series.length) {
    state.series = series.map(function(s10, i36) {
      return Object.assign({}, s10, { id: i36 });
    });
    state.initialSeries = structuredClone(state.series);
  }
  state.categoryAxis = [
    { categories, labels: { visible: true, rotation: "auto" } }
  ];
  state.categoryField = state.columns[catIndex];
  return state;
};
var pieChartState = function(data, seriesType, options) {
  var state = emptyState();
  state.seriesType = seriesType;
  state.data = data || [];
  var chartDef = axesDefinitions[seriesType];
  if (!chartDef || !data.length) {
    return state;
  }
  var categoriesAxis = data[0].map(function(i36) {
    return i36.field;
  });
  var categoryDef = chartDef.find(function(def) {
    return def.axisType === "category";
  });
  var catIndex = -1;
  if (categoryDef) {
    catIndex = options && options.categoryAxis ? categoriesAxis.indexOf(options.categoryAxis) : getCategoryColumnIndex(data, categoryDef);
  }
  var valuesDef = chartDef.filter(function(def) {
    return def.axisType === "value";
  });
  var valuesIndexes = [];
  if (options && options.valueAxis) {
    valuesIndexes = [categoriesAxis.indexOf(options.valueAxis)];
  } else {
    valuesIndexes = getValueColumnIndexes(data, valuesDef);
  }
  if (valuesIndexes.includes(catIndex) && valuesIndexes.length > 1) {
    valuesIndexes = valuesIndexes.filter(function(index) {
      return index !== catIndex;
    });
  }
  if (typeof valuesDef[0].count === "number") {
    valuesIndexes = valuesIndexes.slice(0, valuesDef[0].count);
  }
  var categories = catIndex > -1 ? data.map(function(item) {
    return String(item[catIndex].value);
  }) : [];
  var flatData = [];
  data.forEach(function(item) {
    var record = {};
    valuesIndexes.forEach(function(index) {
      var col = item[index];
      record[col.field] = col.value || 0;
      record[item[catIndex].field] = item[catIndex].value || " ";
    });
    flatData.push(record);
  });
  state.columns = categoriesAxis;
  state.categoryAxis = [{ categories, title: { text: "" } }];
  state.series = [
    {
      id: 0,
      data: flatData,
      type: seriesType,
      name: categoriesAxis[catIndex],
      labels: { visible: true },
      categoryField: categoriesAxis[catIndex],
      field: categoriesAxis[valuesIndexes[0]]
    }
  ];
  state.categoryField = categoriesAxis[catIndex];
  state.valueField = categoriesAxis[valuesIndexes[0]];
  state.initialSeries = structuredClone(state.series);
  return state;
};
function createInitialState(data, seriesType, defaultState) {
  var state = createState(
    data,
    defaultState && defaultState.seriesType || seriesType
  );
  return typeof (defaultState && defaultState.stack) !== "undefined" ? updateState(state, ActionTypes.stacked, defaultState.stack) : state;
}
function createState(data, seriesType) {
  return (isCategorical(seriesType) ? categoryValueChartState : pieChartState)(
    data,
    seriesType
  );
}
function mergeStates(source, target) {
  var newState = structuredClone(target);
  newState.legend = source.legend;
  newState.area = source.area;
  newState.title = source.title;
  newState.subtitle = source.subtitle;
  if (newState.series.length === source.series.length) {
    for (var i36 = 0; i36 < newState.series.length; i36++) {
      newState.series[i36].color = source.series[i36].color;
      newState.series[i36].labels = source.series[i36].labels;
    }
  }
  if (source.series.every(function(s10) {
    return s10.labels && s10.labels.visible;
  }) && isCategorical(newState.seriesType) && isCategorical(source.seriesType)) {
    newState.series.forEach(function(s10) {
      s10.labels = s10.labels || {};
      s10.labels.visible = true;
    });
  }
  return newState;
}
function updateState(currentState, action, value2) {
  var state = Object.assign({}, currentState);
  switch (action) {
    case ActionTypes.seriesType:
      return createState(state.data, value2);
    case ActionTypes.stacked:
      state.series = state.series.map(function(s10) {
        return Object.assign({}, s10, { stack: value2 });
      });
      state.stack = value2;
      return state;
    case ActionTypes.categoryAxisX: {
      if (state.seriesType && isCategorical(state.seriesType)) {
        var newState = categoryValueChartState(
          state.data,
          state.seriesType,
          { categoryAxis: value2 }
        );
        return mergeStates(state, newState);
      } else if (state.seriesType === pieType) {
        var newState$1 = pieChartState(state.data, state.seriesType, {
          categoryAxis: value2
        });
        return mergeStates(state, newState$1);
      }
      return state;
    }
    case ActionTypes.valueAxisY: {
      if (state.seriesType === pieType) {
        var newState$2 = pieChartState(state.data, state.seriesType, {
          categoryAxis: state.categoryField,
          valueAxis: value2
        });
        return mergeStates(state, newState$2);
      }
      return state;
    }
    case ActionTypes.seriesChange:
      state.series = value2;
      return state;
    case ActionTypes.areaMarginLeft:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { left: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginRight:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { right: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginTop:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { top: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginBottom:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { bottom: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaBackground:
      state.area = Object.assign({}, state.area, { background: value2 });
      return state;
    case ActionTypes.titleText:
      state.title = Object.assign({}, state.title, { text: value2 });
      return state;
    case ActionTypes.titleFontName: {
      state.title = Object.assign(
        {},
        state.title,
        { font: updateFontName(
          value2,
          titleSizeDefault,
          state.title && state.title.font
        ) }
      );
      return state;
    }
    case ActionTypes.titleFontSize:
      state.title = Object.assign(
        {},
        state.title,
        { font: updateFontSize(
          value2,
          fontNameDefault,
          state.title && state.title.font
        ) }
      );
      return state;
    case ActionTypes.titleColor:
      state.title = Object.assign({}, state.title, { color: value2 });
      return state;
    case ActionTypes.subtitleText:
      state.subtitle = Object.assign({}, state.subtitle, { text: value2 });
      return state;
    case ActionTypes.subtitleFontName:
      state.subtitle = Object.assign(
        {},
        state.subtitle,
        { font: updateFontName(
          value2,
          subtitleSizeDefault,
          state.subtitle && state.subtitle.font
        ) }
      );
      return state;
    case ActionTypes.subtitleFontSize:
      state.subtitle = Object.assign(
        {},
        state.subtitle,
        { font: updateFontSize(
          value2,
          fontNameDefault,
          state.subtitle && state.subtitle.font
        ) }
      );
      return state;
    case ActionTypes.subtitleColor:
      state.subtitle = Object.assign({}, state.subtitle, { color: value2 });
      return state;
    case ActionTypes.seriesColor:
      state.series = state.series.map(function(s10) {
        return Object.assign(
          {},
          s10,
          { color: value2.seriesName === s10.name ? value2.color : s10.color }
        );
      });
      return state;
    case ActionTypes.seriesLabel:
      state.series = state.series.map(function(s10) {
        if (value2.all || value2.seriesName === s10.name) {
          return Object.assign({}, s10, { labels: { visible: value2.visible } });
        }
        return s10;
      });
      return state;
    case ActionTypes.legendVisible:
      state.legend = Object.assign({}, state.legend, { visible: value2 });
      return state;
    case ActionTypes.legendFontName: {
      var legend2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend2,
        { labels: Object.assign(
          {},
          legend2.labels,
          { font: updateFontName(
            value2,
            labelSizeDefault,
            legend2.labels && legend2.labels.font
          ) }
        ) }
      );
      return state;
    }
    case ActionTypes.legendFontSize: {
      var legend$1 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend$1,
        { labels: Object.assign(
          {},
          legend$1.labels,
          { font: updateFontSize(
            value2,
            fontNameDefault,
            legend$1.labels && legend$1.labels.font
          ) }
        ) }
      );
      return state;
    }
    case ActionTypes.legendColor: {
      var legend$2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend$2,
        { labels: Object.assign({}, legend$2.labels, { color: value2 }) }
      );
      return state;
    }
    case ActionTypes.legendPosition:
      state.legend = Object.assign({}, state.legend, { position: value2 });
      return state;
    case ActionTypes.categoryAxisTitleText:
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { title: Object.assign({}, axis.title, { text: value2 }) });
      });
      return state;
    case ActionTypes.categoryAxisTitleFontName: {
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontName(value2, axisTitleSizeDefault, axis.title && axis.title.font) }) });
      });
      return state;
    }
    case ActionTypes.categoryAxisTitleFontSize:
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontSize(value2, fontNameDefault, axis.title && axis.title.font) }) });
      });
      return state;
    case ActionTypes.categoryAxisTitleColor:
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { title: Object.assign({}, axis.title, { color: value2 }) });
      });
      return state;
    case ActionTypes.categoryAxisLabelsFontName: {
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontName(value2, labelSizeDefault, axis.labels && axis.labels.font) }) });
      });
      return state;
    }
    case ActionTypes.categoryAxisLabelsFontSize:
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontSize(value2, fontNameDefault, axis.labels && axis.labels.font) }) });
      });
      return state;
    case ActionTypes.categoryAxisLabelsColor:
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { color: value2 }) });
      });
      return state;
    case ActionTypes.categoryAxisLabelsRotation: {
      var rotation = hasValue3(value2) ? value2 : "auto";
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { rotation }) });
      });
      return state;
    }
    case ActionTypes.categoryAxisReverseOrder:
      state.categoryAxis = (state.categoryAxis || []).map(function(axis) {
        return Object.assign({}, axis, { reverse: value2 });
      });
      return state;
    case ActionTypes.valueAxisTitleText: {
      if (!state.valueAxis || state.valueAxis.length === 0) {
        state.valueAxis = [{ title: { text: value2 } }];
      } else {
        state.valueAxis = (state.valueAxis || []).map(function(axis) {
          return Object.assign({}, axis, { title: Object.assign({}, axis.title, { text: value2 }) });
        });
      }
      return state;
    }
    case ActionTypes.valueAxisTitleFontName: {
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontName(value2, axisTitleSizeDefault, axis.title && axis.title.font) }) });
      });
      return state;
    }
    case ActionTypes.valueAxisTitleFontSize:
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontSize(value2, fontNameDefault, axis.title && axis.title.font) }) });
      });
      return state;
    case ActionTypes.valueAxisTitleColor:
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { title: Object.assign({}, axis.title, { color: value2 }) });
      });
      return state;
    case ActionTypes.valueAxisLabelsFormat:
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { format: value2 }) });
      });
      return state;
    case ActionTypes.valueAxisLabelsFontName: {
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontName(value2, labelSizeDefault, axis.labels && axis.labels.font) }) });
      });
      return state;
    }
    case ActionTypes.valueAxisLabelsFontSize:
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontSize(value2, fontNameDefault, axis.labels && axis.labels.font) }) });
      });
      return state;
    case ActionTypes.valueAxisLabelsColor:
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { color: value2 }) });
      });
      return state;
    case ActionTypes.valueAxisLabelsRotation: {
      var rotation$1 = hasValue3(value2) ? value2 : "auto";
      state.valueAxis = (state.valueAxis || []).map(function(axis) {
        return Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { rotation: rotation$1 }) });
      });
      return state;
    }
    default:
      return state;
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/messages.js
var messages = Object.freeze({
  windowTitle: "Chart Preview",
  exportButton: "Export",
  exportPDFButton: "PDF File",
  exportSVGButton: "SVG File",
  exportPNGButton: "PNG File",
  tabChart: "Chart",
  tabData: "Data",
  tabFormat: "Format",
  barChart: "Bar Chart",
  barChartBar: "Bar",
  barChartStackedBar: "Stacked Bar",
  barChart100StackedBar: "100% Stacked Bar",
  pieChart: "Pie Chart",
  pieChartPie: "Pie",
  columnChart: "Column Chart",
  columnChartColumn: "Column",
  columnChartStackedColumn: "Stacked Column",
  columnChart100StackedColumn: "100% Stacked Column",
  lineChart: "Line Chart",
  lineChartLine: "Line",
  lineChartStackedLine: "Stacked Line",
  lineChart100StackedLine: "100% Stacked Line",
  scatterChart: "Scatter Chart",
  scatterChartScatter: "Scatter",
  configuration: "Configuration",
  configurationCategoryAxis: "Category Axis",
  configurationXAxis: "X Axis",
  configurationValueAxis: "Value Axis",
  configurationSeries: "Series",
  configurationSeriesAdd: "Add",
  formatChartArea: "Chart Area",
  formatChartAreaMargins: "Margins",
  formatChartAreaMarginsAuto: "Auto",
  formatChartAreaMarginsLeft: "Left",
  formatChartAreaMarginsRight: "Right",
  formatChartAreaMarginsTop: "Top",
  formatChartAreaMarginsBottom: "Bottom",
  formatChartAreaBackground: "Background",
  formatChartAreaBackgroundColor: "Color",
  formatTitle: "Title",
  formatTitleApplyTo: "Apply to",
  formatTitleChartTitle: "Chart Title",
  formatTitleChartSubtitle: "Chart Subtitle",
  formatTitleLabel: "Title",
  formatTitleFont: "Font",
  formatTitleFontPlaceholder: "(inherited font)",
  formatTitleSize: "Size",
  formatTitleSizePlaceholder: "px",
  formatTitleColor: "Color",
  formatSeries: "Series",
  formatSeriesApplyTo: "Apply to",
  formatSeriesAllSeries: "All Series",
  formatSeriesColor: "Color",
  formatSeriesShowLabels: "Show Labels",
  formatLegend: "Legend",
  formatLegendShowLegend: "Show Legend",
  formatLegendFont: "Font",
  formatLegendFontPlaceholder: "(inherited font)",
  formatLegendSize: "Size",
  formatLegendSizePlaceholder: "px",
  formatLegendColor: "Color",
  formatLegendPosition: "Position",
  formatLegendPositionTop: "Top",
  formatLegendPositionBottom: "Bottom",
  formatLegendPositionLeft: "Left",
  formatLegendPositionRight: "Right",
  formatCategoryAxis: "Category Axis",
  formatXAxis: "X Axis",
  formatCategoryAxisTitle: "Title",
  formatCategoryAxisTitlePlaceholder: "Axis Title",
  formatCategoryAxisTitleFont: "Font",
  formatCategoryAxisTitleFontPlaceholder: "(inherited font)",
  formatCategoryAxisTitleSize: "Size",
  formatCategoryAxisTitleSizePlaceholder: "px",
  formatCategoryAxisTitleColor: "Color",
  formatCategoryAxisLabels: "Labels",
  formatCategoryAxisLabelsFont: "Font",
  formatCategoryAxisLabelsFontPlaceholder: "(inherited font)",
  formatCategoryAxisLabelsSize: "Size",
  formatCategoryAxisLabelsSizePlaceholder: "px",
  formatCategoryAxisLabelsColor: "Color",
  formatCategoryAxisLabelsRotation: "Rotation",
  formatCategoryAxisLabelsRotationAuto: "Auto",
  formatCategoryAxisLabelsReverseOrder: "Reverse Order",
  formatValueAxis: "Value Axis",
  formatYAxis: "Y Axis",
  formatValueAxisTitle: "Title",
  formatValueAxisTitlePlaceholder: "Axis Title",
  formatValueAxisTitleFont: "Font",
  formatValueAxisTitleFontPlaceholder: "(inherited font)",
  formatValueAxisTitleSize: "Size",
  formatValueAxisTitleSizePlaceholder: "px",
  formatValueAxisTitleColor: "Color",
  formatValueAxisLabels: "Labels",
  formatValueAxisLabelsFormat: "Label Format",
  formatValueAxisLabelsFormatText: "Text",
  formatValueAxisLabelsFormatNumber: "Number",
  formatValueAxisLabelsFormatCurrency: "Currency",
  formatValueAxisLabelsFormatPercent: "Percent",
  formatValueAxisLabelsFont: "Font",
  formatValueAxisLabelsFontPlaceholder: "(inherited font)",
  formatValueAxisLabelsSize: "Size",
  formatValueAxisLabelsSizePlaceholder: "px",
  formatValueAxisLabelsColor: "Color",
  formatValueAxisLabelsRotation: "Rotation",
  formatValueAxisLabelsRotationAuto: "Auto"
});

// node_modules/@progress/kendo-charts/dist/es/chart-wizard.js
var ChartWizardCommon = Object.freeze({
  getWizardDataFromDataRows,
  ActionTypes,
  createInitialState,
  createState,
  fontNames,
  fontSizes,
  isCategorical,
  mergeStates,
  parseFont,
  updateState,
  messages
});

// node_modules/@progress/kendo-charts/dist/es/chart/theme/base-theme.js
var BAR_GAP = 1.5;
var BAR_SPACING = 0.4;
var BLACK2 = "#000";
var SANS = "Arial, Helvetica, sans-serif";
var SANS11 = "11px " + SANS;
var SANS12 = "12px " + SANS;
var SANS16 = "16px " + SANS;
var TRANSPARENT = "transparent";
var WHITE2 = "#fff";
var lineSeriesLegendItem = {
  type: LINE
};
var areaSeriesLegendItem = {
  type: AREA
};
var areaNoMarkersSeriesLegendItem = Object.assign(
  {},
  areaSeriesLegendItem,
  {
    markers: {
      visible: false
    },
    highlight: {
      visible: false
    }
  }
);
var notes = function() {
  return {
    icon: {
      border: {
        width: 1
      }
    },
    label: {
      font: SANS12,
      padding: 3
    },
    line: {
      length: 10,
      width: 2
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    visible: true
  };
};
var axisDefaults = function() {
  return {
    labels: {
      font: SANS12
    },
    notes: notes(),
    title: {
      font: SANS16,
      margin: 5
    }
  };
};
var areaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.4
  };
};
var rangeAreaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.4
  };
};
var barSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var boxPlotSeries = function() {
  return {
    outliersField: "",
    meanField: "",
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      whiskers: {
        width: 3
      },
      mean: {
        width: 2
      },
      median: {
        width: 2
      }
    },
    mean: {
      width: 2
    },
    median: {
      width: 2
    },
    spacing: 0.3,
    whiskers: {
      width: 2
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var bubbleSeries = function() {
  return {
    border: {
      width: 0
    },
    labels: {
      background: TRANSPARENT
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    opacity: 0.6
  };
};
var bulletSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    target: {
      color: "#ff0000"
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var candlestickSeries = function() {
  return {
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      line: {
        width: 2
      }
    },
    line: {
      color: BLACK2,
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: 0.3
  };
};
var columnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var radarColumnSeries = function() {
  return {
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var polarScatterSeries = function() {
  return {
    legendItem: lineSeriesLegendItem
  };
};
var scatterSeries2 = function() {
  return {
    legendItem: lineSeriesLegendItem
  };
};
var donutSeries = function() {
  return {
    margin: 1,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var lineSeries = function() {
  return {
    width: 2,
    legendItem: lineSeriesLegendItem
  };
};
var ohlcSeries = function() {
  return {
    gap: 1,
    highlight: {
      line: {
        opacity: 1,
        width: 3
      }
    },
    line: {
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: 0.3
  };
};
var radarAreaSeries = function() {
  return {
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.5
  };
};
var radarLineSeries = function() {
  return {
    markers: {
      visible: false
    },
    legendItem: lineSeriesLegendItem,
    width: 2
  };
};
var rangeBarSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var rangeColumnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var scatterLineSeries = function() {
  return {
    width: 1,
    legendItem: lineSeriesLegendItem
  };
};
var waterfallSeries = function() {
  return {
    gap: 0.5,
    line: {
      color: BLACK2,
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: BAR_SPACING
  };
};
var pieSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var funnelSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var pyramidSeries = funnelSeries;
var heatmapSeries = function() {
  return {
    labels: {
      color: "",
      background: TRANSPARENT,
      visible: true
    },
    highlight: {
      border: {
        width: 0
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var trendlineSeriesDefaults = function(options) {
  return Object.assign({
    color: INHERIT,
    trendline: {},
    markers: {
      visible: false
    },
    width: 1,
    dashType: "longDash",
    legendItem: lineSeriesLegendItem
  }, options);
};
var seriesDefaults = function(options) {
  return {
    visible: true,
    labels: {
      font: SANS11
    },
    overlay: options.gradients ? {} : {
      gradient: "none"
    },
    area: areaSeries(),
    rangeArea: rangeAreaSeries(),
    verticalRangeArea: rangeAreaSeries(),
    bar: barSeries(),
    boxPlot: boxPlotSeries(),
    bubble: bubbleSeries(),
    bullet: bulletSeries(),
    candlestick: candlestickSeries(),
    column: columnSeries(),
    heatmap: heatmapSeries(),
    pie: pieSeries(),
    donut: donutSeries(),
    funnel: funnelSeries(),
    pyramid: pyramidSeries(),
    horizontalWaterfall: waterfallSeries(),
    line: lineSeries(),
    notes: notes(),
    ohlc: ohlcSeries(),
    radarArea: radarAreaSeries(),
    radarLine: radarLineSeries(),
    radarColumn: radarColumnSeries(),
    polarArea: radarAreaSeries(),
    polarLine: radarLineSeries(),
    polarScatter: polarScatterSeries(),
    rangeBar: rangeBarSeries(),
    rangeColumn: rangeColumnSeries(),
    scatter: scatterSeries2(),
    scatterLine: scatterLineSeries(),
    verticalArea: areaSeries(),
    verticalBoxPlot: boxPlotSeries(),
    verticalBullet: bulletSeries(),
    verticalLine: lineSeries(),
    waterfall: waterfallSeries(),
    linearTrendline: trendlineSeriesDefaults(),
    exponentialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    logarithmicTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    polynomialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    powerTrendline: trendlineSeriesDefaults({ style: "smooth" }),
    movingAverageTrendline: trendlineSeriesDefaults()
  };
};
var title = function() {
  return {
    font: SANS16
  };
};
var subtitle = function() {
  return {
    font: SANS12
  };
};
var legend = function() {
  return {
    labels: {
      font: SANS12
    }
  };
};
var baseTheme = function(options) {
  if (options === void 0) options = {};
  return {
    axisDefaults: axisDefaults(),
    categoryAxis: {
      majorGridLines: {
        visible: true
      }
    },
    navigator: {
      pane: {
        height: 90,
        margin: {
          top: 10
        }
      }
    },
    seriesDefaults: seriesDefaults(options),
    title: title(),
    subtitle: subtitle(),
    legend: legend()
  };
};

// node_modules/@progress/kendo-charts/dist/es/chart/theme/load-theme.js
var SERIES_COLORS = 30;
var seriesVar = "--kendo-chart-series-";
var elementStyles2 = function(element) {
  return element.ownerDocument.defaultView.getComputedStyle(element);
};
var cache = {};
var toColor = function(colorMix, element) {
  if (cache[colorMix]) {
    return cache[colorMix];
  }
  var curColor = element.style.color;
  element.style.color = colorMix;
  var color = elementStyles2(element).color;
  element.style.color = curColor;
  cache[colorMix] = color;
  return color;
};
var getProp = function(element, prop) {
  var value2 = elementStyles2(element).getPropertyValue(prop);
  if (/^color-mix/i.test(value2)) {
    value2 = toColor(value2, element);
  }
  return value2;
};
var getNumberProp = function(element, prop) {
  return parseFloat(elementStyles2(element).getPropertyValue(prop));
};
var getFont2 = function(element, weightProp, sizeProp, familyProp) {
  var styles = elementStyles2(element);
  return [styles.getPropertyValue(weightProp), styles.getPropertyValue(sizeProp), styles.getPropertyValue(familyProp) || styles.fontFamily].join(" ");
};
var getSeriesColors = function(element) {
  var styles = elementStyles2(element);
  var result = [];
  var count = 1;
  var color = styles.getPropertyValue("" + seriesVar + count);
  while (color || count <= SERIES_COLORS) {
    result.push(color);
    count++;
    color = styles.getPropertyValue("" + seriesVar + count);
  }
  return result;
};
var defaultFont = function(element) {
  return getFont2(element, "--kendo-font-weight", "--kendo-chart-font-size", "--kendo-font-family");
};
var paneTitleFont = function(element) {
  return getFont2(element, "--kendo-chart-pane-title-font-weight", "--kendo-chart-pane-title-font-size", "--kendo-font-family");
};
var normalTextColor = function(element) {
  return getProp(element, "--kendo-chart-text");
};
var title2 = function(element) {
  return {
    color: normalTextColor(element),
    font: getFont2(element, "--kendo-font-weight", "--kendo-chart-title-font-size", "--kendo-font-family")
  };
};
var sankeyLegend = function(element) {
  var textColorNormal = normalTextColor(element);
  return {
    labels: {
      color: textColorNormal,
      font: defaultFont(element)
    },
    title: {
      color: textColorNormal
    }
  };
};
var chartLegend = function(element) {
  var inactiveColor = getProp(element, "--kendo-chart-inactive");
  return Object.assign(
    {},
    { inactiveItems: {
      labels: {
        color: inactiveColor
      },
      markers: {
        color: inactiveColor
      }
    } },
    sankeyLegend(element)
  );
};
var sankeyTheme = function(element) {
  return {
    labels: {
      color: normalTextColor(element),
      font: defaultFont(element),
      stroke: {
        color: getProp(element, "--kendo-chart-bg")
      }
    },
    links: {
      color: getProp(element, "--kendo-color-subtle")
    },
    nodeColors: getSeriesColors(element),
    title: title2(element),
    legend: sankeyLegend(element)
  };
};
var notes2 = function(element) {
  return {
    icon: {
      background: getProp(element, "--kendo-chart-notes-bg"),
      border: {
        color: getProp(element, "--kendo-chart-notes-border")
      }
    },
    line: {
      color: getProp(element, "--kendo-chart-notes-lines")
    },
    label: {
      font: defaultFont(element)
    }
  };
};
var chartTheme = function(element) {
  var majorLines = getProp(element, "--kendo-chart-major-lines");
  var normalTextColor2 = getProp(element, "--kendo-chart-text");
  var axisLabelFont = getFont2(element, "--kendo-font-weight", "--kendo-chart-label-font-size", "--kendo-font-family");
  var chartBg = getProp(element, "--kendo-chart-bg");
  var notesProps = notes2(element);
  var areaOpacity = getNumberProp(element, "--kendo-chart-area-opacity");
  var surfaceColor = getProp(element, "--kendo-color-surface");
  var primaryBg = getProp(element, "--kendo-chart-primary-bg");
  var boxPlot = function() {
    return {
      downColor: majorLines,
      mean: {
        color: surfaceColor
      },
      median: {
        color: surfaceColor
      },
      whiskers: {
        color: primaryBg
      }
    };
  };
  var waterfall = function() {
    return {
      line: {
        color: majorLines
      }
    };
  };
  var area = function() {
    return {
      opacity: areaOpacity,
      highlight: {
        inactiveOpacity: getNumberProp(element, "--kendo-chart-area-inactive-opacity")
      }
    };
  };
  var line = function() {
    return {
      highlight: {
        inactiveOpacity: getNumberProp(element, "--kendo-chart-line-inactive-opacity")
      }
    };
  };
  var bullet = function() {
    return {
      target: {
        color: normalTextColor2
      }
    };
  };
  return {
    axisDefaults: {
      crosshair: {
        color: getProp(element, "--kendo-chart-crosshair-bg")
      },
      labels: {
        color: normalTextColor2,
        font: axisLabelFont
      },
      line: {
        color: majorLines
      },
      majorGridLines: {
        color: majorLines
      },
      minorGridLines: {
        color: getProp(element, "--kendo-chart-minor-lines")
      },
      notes: structuredClone(notesProps),
      title: {
        color: normalTextColor2,
        font: defaultFont(element)
      }
    },
    chartArea: {
      background: chartBg
    },
    legend: chartLegend(element),
    seriesColors: getSeriesColors(element),
    seriesDefaults: {
      area: area(),
      verticalArea: area(),
      radarArea: area(),
      boxPlot: boxPlot(),
      verticalBoxPlot: boxPlot(),
      bullet: bullet(),
      verticalBullet: bullet(),
      horizontalWaterfall: waterfall(),
      waterfall: waterfall(),
      line: line(),
      verticalLine: line(),
      candlestick: {
        downColor: normalTextColor2,
        line: {
          color: normalTextColor2
        }
      },
      errorBars: {
        color: getProp(element, "--kendo-chart-error-bars-bg")
      },
      icon: {
        border: {
          color: majorLines
        }
      },
      labels: {
        background: chartBg,
        color: normalTextColor2,
        font: axisLabelFont,
        opacity: areaOpacity
      },
      notes: structuredClone(notesProps)
    },
    subtitle: {
      color: normalTextColor2,
      font: paneTitleFont(element)
    },
    title: title2(element),
    paneDefaults: {
      title: {
        font: paneTitleFont(element)
      }
    }
  };
};

// node_modules/@progress/kendo-react-charts/utils/index.mjs
function i3(e39, t38) {
  let r27 = e39;
  for (; r27 && r27 !== t38; )
    r27 = r27.parentNode;
  return !!r27;
}
function l3(e39, t38, r27, o33) {
  const n20 = e39[t38];
  if (n20 && Array.isArray(n20)) {
    for (const a38 of n20)
      if (!a38.type || a38.type !== o33)
        return new Error(`${r27} children should be Array of type ${o33.displayName}.`);
  }
  return null;
}
var u2 = (e39) => e39 === void 0 ? false : !e39;

// node_modules/@progress/kendo-react-charts/events/base-event.mjs
var e2 = class {
  /**
   * @hidden
   */
  constructor(t38) {
    this.target = t38;
  }
};

// node_modules/@progress/kendo-react-charts/events/axis-label-click-event.mjs
var x = class extends e2 {
  /**
   * @hidden
   */
  constructor(t38, s10) {
    super(s10), this.axis = t38.axis, this.dataItem = t38.dataItem, this.index = t38.index, this.text = t38.text, this.value = t38.value;
  }
};

// node_modules/@progress/kendo-react-charts/events/preventable-event.mjs
var n2 = class extends e2 {
  constructor() {
    super(...arguments), this.prevented = false;
  }
  /* eslint-disable max-len */
  /**
   * Prevents the default action for a specified event. In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};

// node_modules/@progress/kendo-react-charts/events/drag-event.mjs
var r = class extends n2 {
  /**
   * @hidden
   */
  constructor(e39, t38) {
    super(t38), this.axisRanges = e39.axisRanges, this.nativeEvent = e39.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/drag-end-event.mjs
var i4 = class extends e2 {
  /**
   * @hidden
   */
  constructor(s10, t38) {
    super(t38), this.axisRanges = s10.axisRanges, this.nativeEvent = s10.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/drag-start-event.mjs
var r2 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.axisRanges = t38.axisRanges, this.nativeEvent = t38.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/drilldown-event.mjs
var n3 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.value = t38.value, this.point = t38.point, this.series = t38.series, this.currentState = t38.currentState, this.nextState = t38.nextState;
  }
};

// node_modules/@progress/kendo-react-charts/events/legend-item-hover-event.mjs
var i5 = class extends n2 {
  /**
   * @hidden
   */
  constructor(e39, t38) {
    super(t38), this.series = e39.series, this.seriesIndex = e39.seriesIndex, this.pointIndex = e39.pointIndex, this.text = e39.text;
  }
  /**
   * If called, the series highlight is not shown as a result of hovering over the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};

// node_modules/@progress/kendo-react-charts/events/legend-item-click-event.mjs
var i6 = class extends n2 {
  /**
   * @hidden
   */
  constructor(e39, t38) {
    super(t38), this.series = e39.series, this.seriesIndex = e39.seriesIndex, this.pointIndex = e39.pointIndex, this.text = e39.text;
  }
  /**
   * If called, the series visibility is not toggled as a result of clicking the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};

// node_modules/@progress/kendo-react-charts/events/legend-item-leave-event.mjs
var i7 = class extends n2 {
  /**
   * @hidden
   */
  constructor(e39, t38) {
    super(t38), this.series = e39.series, this.seriesIndex = e39.seriesIndex, this.pointIndex = e39.pointIndex, this.text = e39.text;
  }
  /**
   * @hidden
   */
  preventDefault() {
    super.preventDefault();
  }
};

// node_modules/@progress/kendo-react-charts/events/navigator-filter-event.mjs
var i8 = class extends e2 {
  /**
   * Constructs the event arguments from a raw object.
   */
  constructor(t38, o33) {
    super(o33), this.from = t38.from, this.to = t38.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/note-click-event.mjs
var r3 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t38, s10) {
    super(s10), this.category = t38.category, this.dataItem = t38.dataItem, this.series = t38.series, this.value = t38.value, this.visual = t38.visual;
  }
};

// node_modules/@progress/kendo-react-charts/events/note-hover-event.mjs
var i9 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t38, s10) {
    super(s10), this.category = t38.category, this.dataItem = t38.dataItem, this.series = t38.series, this.value = t38.value, this.visual = t38.visual;
  }
};

// node_modules/@progress/kendo-react-charts/events/plot-area-click-event.mjs
var a = class extends e2 {
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.category = t38.category, this.nativeEvent = t38.originalEvent, this.value = t38.value, this.x = t38.x, this.y = t38.y;
  }
};

// node_modules/@progress/kendo-react-charts/events/plot-area-hover-event.mjs
var a2 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.category = t38.category, this.nativeEvent = t38.originalEvent, this.value = t38.value, this.x = t38.x, this.y = t38.y;
  }
};

// node_modules/@progress/kendo-react-charts/events/render-event.mjs
var o = class extends e2 {
  /**
   * @hidden
   */
  constructor(s10, e39) {
    super(e39);
  }
};

// node_modules/@progress/kendo-react-charts/events/select-event.mjs
var i10 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t38, s10) {
    super(s10), this.axis = t38.axis, this.from = t38.from, this.to = t38.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/select-end-event.mjs
var i11 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t38, s10) {
    super(s10), this.axis = t38.axis, this.from = t38.from, this.to = t38.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/select-start-event.mjs
var i12 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t38, r27) {
    super(r27), this.axis = t38.axis, this.from = t38.from, this.to = t38.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/series-click-event.mjs
var r4 = class extends e2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.category = t38.category, this.dataItem = t38.dataItem, this.nativeEvent = t38.originalEvent, this.percentage = t38.percentage, this.point = t38.point, this.series = t38.series, this.stackValue = t38.stackValue, this.value = t38.value;
  }
};

// node_modules/@progress/kendo-react-charts/events/series-hover-event.mjs
var r5 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.category = t38.category, this.categoryPoints = t38.categoryPoints, this.dataItem = t38.dataItem, this.nativeEvent = t38.originalEvent, this.percentage = t38.percentage, this.point = t38.point, this.series = t38.series, this.stackValue = t38.stackValue, this.value = t38.value;
  }
};

// node_modules/@progress/kendo-react-charts/events/zoom-event.mjs
var i13 = class extends n2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.axisRanges = t38.axisRanges, this.delta = t38.delta, this.nativeEvent = t38.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/zoom-end-event.mjs
var i14 = class extends e2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(s10, t38) {
    super(t38), this.axisRanges = s10.axisRanges, this.nativeEvent = s10.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/zoom-start-event.mjs
var r6 = class extends n2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t38, e39) {
    super(e39), this.axisRanges = t38.axisRanges, this.nativeEvent = t38.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/chart-event-builder.mjs
var t = {
  axisLabelClick: x,
  drag: r,
  dragEnd: i4,
  dragStart: r2,
  drilldownEvent: n3,
  legendItemHover: i5,
  legendItemClick: i6,
  legendItemLeave: i7,
  navigatorFilter: i8,
  noteClick: r3,
  noteHover: i9,
  plotAreaClick: a,
  plotAreaHover: a2,
  render: o,
  select: i10,
  selectEnd: i11,
  selectStart: i12,
  seriesClick: r4,
  seriesHover: r5,
  zoom: i13,
  zoomEnd: i14,
  zoomStart: r6
};
function Q(e39, r27, o33) {
  if (t[e39])
    return new t[e39](r27, o33);
}

// node_modules/@progress/kendo-react-charts/events/dom-event.mjs
var o2 = class {
  /**
   * @hidden
   */
  constructor(t38, e39) {
    this.sender = t38, this.syntheticEvent = e39;
  }
};
function s(n20, t38) {
  return new o2(n20, t38);
}

// node_modules/@progress/kendo-react-charts/store/store.mjs
var l4 = 1e3 / 60;
var T = (i36) => {
  let o33, s10, t38 = [];
  const n20 = () => o33, c10 = (e39) => {
    o33 = i36(o33, e39), e && (window.clearTimeout(s10), s10 = window.setTimeout(() => t38.forEach((r27) => r27()), l4));
  }, a38 = (e39) => (t38.push(e39), () => t38 = t38.filter((r27) => r27 !== e39));
  return c10({}), { getState: n20, dispatch: c10, subscribe: a38 };
};

// node_modules/@progress/kendo-react-charts/store/reducer.mjs
var a3 = (t38, e39) => e39.chartCollectionIdxKey ? c.collectionConfigurationItem(t38, e39) : e39.chartKey ? c.configurationItem(t38, e39) : {};
var u3 = (t38, e39) => {
  if (e39.type)
    switch (e39.type) {
      case "set":
        return c.themeItem(t38, e39);
      case "push":
        return Object.assign(t38, e39.payload);
      default:
        return t38;
    }
  else
    return {};
};
var p2 = (t38, e39) => {
  if (e39.type)
    switch (e39.type) {
      case "add":
        return [...t38, e39.payload];
      case "remove":
        return t38.filter((r27) => r27 !== e39.payload);
      default:
        return t38;
    }
  else
    return [];
};
var c = {
  configurationItem(t38, e39) {
    return Object.assign(t38, {
      [e39.chartKey]: e39.payload
    });
  },
  collectionConfigurationItem(t38, e39) {
    let r27 = false;
    const [o33, n20] = e39.chartCollectionIdxKey.split("_"), i36 = t38[o33].map((l8, s10) => parseInt(n20, 10) === s10 ? (r27 = true, e39.payload) : l8);
    return r27 === false && i36.splice(parseInt(n20, 10), 0, e39.payload), Object.assign(t38, {
      [o33]: i36
    });
  },
  themeItem(t38, e39) {
    let r27 = {};
    const o33 = Object.assign(r27, t38), { field: n20, value: i36 } = e39.payload, l8 = n20.split(".");
    let s10 = l8.shift();
    for (; l8.length > 0; )
      r27 = r27[s10] = r27[s10] || {}, s10 = l8.shift();
    return r27[s10] = i36, o33;
  }
};

// node_modules/@progress/kendo-react-charts/tooltip/Series.mjs
var p3 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/tooltip/Point.mjs
var a4 = class {
  /**
   * @hidden
   */
  constructor(t38, h5) {
    this.value = t38.value, this.category = t38.category, this.categoryIndex = t38.categoryIx, this.series = t38.series, this.dataItem = t38.dataItem, this.percentage = t38.percentage, this.runningTotal = t38.runningTotal, this.total = t38.total, this.low = t38.low, this.high = t38.high, this.xLow = t38.xLow, this.xHigh = t38.xHigh, this.yLow = t38.yLow, this.yHigh = t38.yHigh, this.point = t38, this.format = ((t38.options || {}).tooltip || {}).format || h5;
  }
  get formattedValue() {
    return this.format ? this.point.formatValue(this.format) : String(this.value);
  }
};

// node_modules/@progress/kendo-react-charts/tooltip/SharedTooltipContent.mjs
var e3 = __toESM(require_react(), 1);
var u4 = "k-chart-shared-tooltip-marker";
var E = (l8) => {
  const { categoryText: r27, colorMarker: n20, colspan: a38, nameColumn: o33, points: c10 } = l8, m11 = (t38, s10) => e3.createElement("tr", { key: s10 }, n20 && e3.createElement("td", null, e3.createElement("span", { className: u4, style: { backgroundColor: t38.series.color } })), o33 && e3.createElement("td", null, t38.series.name), e3.createElement("td", { dangerouslySetInnerHTML: { __html: t38.formattedValue } }));
  return e3.createElement("table", null, e3.createElement("thead", null, e3.createElement("tr", null, e3.createElement("th", { colSpan: a38 }, r27))), e3.createElement("tbody", null, c10.map(m11)));
};

// node_modules/@progress/kendo-react-charts/tooltip/Popup.mjs
var r7 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/ChartContext.mjs
var t2 = __toESM(require_react(), 1);
var e4 = t2.createContext(null);
e4.displayName = "ChartContext";

// node_modules/@progress/kendo-react-charts/tooltip/Popup.mjs
var v3 = { horizontal: "fit", vertical: "fit" };
var d = "k-chart-tooltip";
var C = "k-chart-tooltip-wrapper";
var n4 = class n5 extends r7.Component {
  constructor(s10, o33) {
    super(s10, o33), this.context = null, this.element = null, this.onChartMouseLeave = (e39) => {
      const { syntheticEvent: t38 } = e39;
      return !!i3(t38.relatedTarget, this.element);
    }, this.onMouseLeave = (e39) => {
      const t38 = s(this, e39);
      this.context.childrenObserver.trigger("onMouseLeave", t38) && e39.preventDefault();
    }, this.popupRef = (e39) => {
      this.element = e39;
      const t38 = e39 && e39.closest(".k-animation-container");
      t38 && (t38.style.transition = "initial");
    }, this.chartObserver = new instance_observer_default(this, {
      onMouseLeave: "onChartMouseLeave"
    }), o33.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupShown: s10, popupAlign: o33, popupOffset: e39, popupStyles: t38, popupContent: a38, className: p9 } = this.props, c10 = [d, p9].join(" ").trim();
    return r7.createElement(
      te,
      {
        animate: false,
        popupAlign: o33,
        offset: e39,
        show: s10,
        collision: v3,
        className: C
      },
      r7.createElement("div", { className: c10, style: t38, onMouseLeave: this.onMouseLeave, ref: this.popupRef }, a38())
    );
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
};
n4.contextType = e4;
var i15 = n4;

// node_modules/@progress/kendo-react-charts/tooltip/Series.mjs
var T2 = "k-chart-shared-tooltip";
var x2 = "k-chart-tooltip-inverse";
var a5 = class a6 extends p3.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      popupShown: false
    }, this.chartObserver = null;
  }
  componentDidMount() {
    this.chartObserver = new instance_observer_default(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), this.context.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContext: t38, shared: o33, className: n20, ...r27 } = this.state, i36 = this.state.popupShown ? () => {
      const e39 = this.findRenderFunction();
      if (o33)
        return e39 !== null ? e39(t38) : p3.createElement(E, { ...t38 });
      const u7 = t38.point, l8 = this.findRenderFunctionByIndex(u7.series.index);
      return l8 !== null ? l8(t38) : e39 !== null ? e39(t38) : p3.createElement(
        "span",
        {
          dangerouslySetInnerHTML: {
            __html: t38.point.formattedValue
          }
        }
      );
    } : Function.prototype, s10 = n({
      [T2]: o33,
      [x2]: !!n20
    });
    return p3.createElement(i15, { ...r27, popupContent: i36, className: s10 });
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(t38) {
    const { anchor: o33, style: n20, shared: r27, className: i36, crosshair: s10 } = t38;
    let e39;
    s10 || (r27 ? e39 = this.createSharedTooltipContext(t38) : e39 = this.createTooltipContext(t38), this.setState({
      popupShown: true,
      popupAlign: o33.align,
      popupOffset: o33.point,
      popupContext: e39,
      popupStyles: n20,
      className: i36,
      shared: r27
    }));
  }
  onHideTooltip() {
    this.setState({
      popupShown: false,
      popupStyles: {},
      className: void 0
    });
  }
  createSharedTooltipContext(t38) {
    const { points: o33, categoryText: n20 } = t38, r27 = o33.filter((e39) => typeof e39.series.name != "undefined").length > 0, i36 = t38.series.length > 1;
    let s10 = 1;
    return r27 && s10++, i36 && s10++, {
      categoryText: n20,
      colorMarker: i36,
      colspan: s10,
      nameColumn: r27,
      points: t38.points.map((e39) => new a4(e39, t38.format))
    };
  }
  createTooltipContext(t38) {
    const { point: o33, format: n20 } = t38;
    return { point: new a4(o33, n20) };
  }
  findRenderFunctionByIndex(t38) {
    const o33 = this.context.optionsStore.getState().series;
    return o33 !== void 0 && Array.isArray(o33) && o33[t38] !== void 0 && o33[t38].hasOwnProperty("tooltip") && o33[t38].tooltip.hasOwnProperty("render") ? o33[t38].tooltip.render : null;
  }
  findRenderFunction() {
    const t38 = this.context.optionsStore.getState().tooltip;
    return t38 !== void 0 && t38.hasOwnProperty("render") ? t38.render : null;
  }
};
a5.contextType = e4;
var h2 = a5;

// node_modules/@progress/kendo-react-charts/tooltip/CrosshairContainer.mjs
var r9 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/Container.mjs
var e5 = (n20) => n20.children;
e5.displayName = "Container";

// node_modules/@progress/kendo-react-charts/tooltip/Crosshair.mjs
var r8 = __toESM(require_react(), 1);
var v4 = "k-chart-crosshair-tooltip";
var C2 = "k-chart-tooltip-inverse";
var n6 = class n7 extends r8.Component {
  constructor(t38, o33) {
    super(t38, o33), this.context = null, this.state = {
      popupShown: false
    }, this.chartObserver = new instance_observer_default(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), o33.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContend: t38, className: o33, ...e39 } = this.state, p9 = this.state.popupShown ? () => t38 : Function.prototype, s10 = n({
      [v4]: true,
      [C2]: !!o33
    });
    return r8.createElement(i15, { ...e39, popupContent: p9, className: s10 });
  }
  componentWillUnmount() {
    var t38;
    (t38 = this.context) == null || t38.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(t38) {
    const { anchor: o33, style: e39, className: p9, crosshair: s10, axisName: i36, axisIndex: c10, value: l8 } = t38, { name: h5, index: m11 } = this.props;
    s10 && i36 === h5 && c10 === m11 && this.setState({
      popupShown: true,
      popupAlign: o33.align,
      popupOffset: o33.point,
      popupContend: l8,
      popupStyles: e39,
      className: p9
    });
  }
  onHideTooltip() {
    this.setState({
      popupShown: false,
      popupStyles: {},
      className: void 0
    });
  }
};
n6.contextType = e4;
var a7 = n6;

// node_modules/@progress/kendo-react-charts/tooltip/CrosshairContainer.mjs
var l5 = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
function x3(n20) {
  const t38 = {};
  for (let o33 = 0; o33 < l5.length; o33++) {
    const s10 = m(n20, l5[o33]);
    for (let e39 = 0; e39 < s10.length; e39++) {
      const i36 = s10[e39];
      t38[i36.name + i36.index] = i36;
    }
  }
  return t38;
}
function m(n20, t38) {
  const o33 = [];
  if (n20[t38]) {
    const s10 = [].concat(n20[t38]);
    for (let e39 = 0; e39 < s10.length; e39++) {
      const i36 = (s10[e39].crosshair || {}).tooltip;
      i36 && i36.visible && o33.push({
        index: e39,
        name: t38
      });
    }
  }
  return o33;
}
var c2 = class c3 extends r9.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      tooltips: {}
    }, this.storeUnsubscriber = Function.prototype, this.subscriber = () => {
      var t38;
      this.setState({
        tooltips: x3((t38 = this.context) == null ? void 0 : t38.optionsStore.getState())
      });
    };
  }
  componentDidMount() {
    this.storeUnsubscriber = this.context.optionsStore.subscribe(this.subscriber);
  }
  render() {
    const { tooltips: t38 } = this.state, o33 = Object.keys(t38).map((s10) => r9.createElement(a7, { ...t38[s10], key: s10 }));
    return r9.createElement(e5, null, o33);
  }
  componentWillUnmount() {
    this.storeUnsubscriber();
  }
};
c2.contextType = e4;
var p4 = c2;

// node_modules/@progress/kendo-react-charts/package-metadata.mjs
var e6 = {
  name: "@progress/kendo-react-charts",
  productName: "KendoReact",
  productCode: "KENDOUIREACT",
  productCodes: ["KENDOUIREACT"],
  publishDate: 1741695588,
  version: "10.0.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};

// node_modules/@progress/kendo-react-charts/BaseChart.mjs
var d2 = class d3 extends l6.Component {
  constructor(t38) {
    super(t38), this.chartInstance = null, this.surface = null, this._element = null, this.optionsStore = {}, this.optionsUnsubscriber = Function.prototype, this.themeStore = {}, this.themeUnsubscriber = Function.prototype, this.observersStore = {}, this.suppressTransitions = false, this.showLicenseWatermark = false, this.onRender = (e39) => {
      this.chartInstance !== null && (this.surface = e39.sender.surface, this.trigger("render", e39));
    }, this.onDrilldown = (e39) => {
      var i36;
      const { series: s10 } = this.optionsStore.getState(), r27 = s10.find((n20) => n20.name === e39.series.name);
      if (r27.drilldownSeriesFactory) {
        const n20 = "onDrilldown";
        if (this.props.hasOwnProperty(n20)) {
          const o33 = { seriesName: r27.name, drilldownValue: e39.value }, h5 = [...((i36 = this.props.drilldownState) == null ? void 0 : i36.steps) || [], o33], c10 = this.props.getTarget(), p9 = {
            ...e39,
            currentState: this.props.drilldownState,
            nextState: { steps: h5 }
          }, a38 = new n3(p9, c10);
          this.props[n20].call(void 0, a38);
        }
      }
      return true;
    }, this.onLegendItemClick = (e39) => {
      if (this.chartInstance !== null)
        if (this.props.onLegendItemClick)
          this.trigger("legendItemClick", e39);
        else {
          const { series: s10 } = this.optionsStore.getState();
          if (!s10)
            return;
          let r27 = {};
          const { seriesIndex: i36, pointIndex: n20 } = e39, o33 = s10[i36];
          if (n20 === void 0)
            r27 = Object.assign({}, o33, { visible: u2(o33.visible) });
          else {
            const h5 = o33.pointVisibility = o33.pointVisibility || [];
            h5[n20] = u2(h5[n20]), r27 = Object.assign({}, o33);
          }
          this.optionsStore.dispatch({
            chartCollectionIdxKey: `series_${i36}`,
            payload: r27
          }), this.suppressTransitions = true;
        }
    }, this.onWindowResize = () => {
      this.chartInstance !== null && this.chartInstance.resize();
    }, this.onChartMouseLeave = (e39) => {
      const s10 = s(this, e39);
      this.triggerDomEvent("onMouseLeave", s10) ? e39.preventDefault() : this.chartInstance !== null && this.chartInstance.hideElements();
    }, this.onChildMouseLeave = (e39) => {
      const { syntheticEvent: s10 } = e39;
      return this.chartInstance && !i3(s10.relatedTarget, this.element) && this.chartInstance.hideElements(), false;
    }, this.showLicenseWatermark = !h(e6, { component: "Chart" }), this.optionsStore = T(a3), this.observersStore = T(p2), this.childrenObserver = new instance_observer_default(this, { onMouseLeave: "onChildMouseLeave" }), this.state = {
      optionsStore: this.optionsStore,
      observersStore: this.observersStore,
      childrenObserver: this.childrenObserver,
      drilldownState: { steps: [] }
    }, this.themeStore = T(u3), this.chartObserver = new instance_observer_default(this, {
      render: "onRender",
      legendItemClick: "onLegendItemClick",
      drilldown: "onDrilldown"
    });
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(t38, e39) {
    return {
      ...e39,
      drilldownState: t38.drilldownState || []
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    if (this._element) {
      let t38 = {};
      try {
        t38 = chartTheme(this._element);
      } catch {
      }
      const e39 = deepExtend(baseTheme(), t38);
      this.themeStore.dispatch({ type: "push", payload: e39 }), this.instantiateCoreChart();
    }
    this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this)), this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this)), window.addEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.optionsUnsubscriber(), this.themeUnsubscriber(), this.chartInstance !== null && (this.chartInstance.destroy(), this.chartInstance = null), window.removeEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentDidUpdate(t38) {
    const { dir: e39, children: s10, ...r27 } = this.props;
    if (this.chartInstance !== null) {
      const i36 = l(this), n20 = this.chartInstance.chartService, o33 = i36.locale !== n20._intlService.locale, h5 = Object.entries(t38).filter((c10) => c10[0] !== "dir" && c10[0] !== "children").some((c10) => {
        const [p9, a38] = c10;
        return !(r27.hasOwnProperty(p9) && r27[p9] === a38);
      });
      o33 && (this.chartInstance.chartService._intlService = i36, this.chartInstance.chartService.format._intlService = i36, h5 || this.chartInstance.noTransitionsRedraw()), h5 && this.refresh(), t38.dir !== e39 && this.chartInstance.setDirection(this.getDirection(e39));
    }
  }
  /**
   * @hidden
   */
  render() {
    const { style: t38 = {}, className: e39, wrapper: s10, children: r27 } = this.props, i36 = Object.assign({}, t38, { position: "relative" }), n20 = l6.createElement(
      s10,
      {
        className: e39,
        style: i36,
        key: "chartElement"
      },
      l6.createElement("div", { onMouseLeave: this.onChartMouseLeave, ref: (o33) => this._element = o33, className: "k-chart-surface" }, r27),
      l6.createElement(l6.Fragment, null, this.showLicenseWatermark && l6.createElement(l2, null))
    );
    return l6.createElement(e4.Provider, { value: this.state }, l6.createElement(h2, { key: "seriesTooltip" }), l6.createElement(p4, { key: "crosshairTooltips" }), n20);
  }
  /**
   * @hidden
   */
  getDirection(t38) {
    return (t38 !== void 0 ? t38 : e && window.getComputedStyle(this.element).direction || "ltr") === "rtl";
  }
  /**
   * @hidden
   */
  getChartOptions() {
    const {
      renderAs: t38,
      pannable: e39,
      zoomable: s10,
      paneDefaults: r27,
      panes: i36,
      transitions: n20,
      seriesColors: o33,
      seriesDefaults: h5,
      axisDefaults: c10,
      deriveOptionsFromParent: p9
    } = this.props;
    let a38 = {};
    return t38 !== void 0 && (a38.renderAs = t38), e39 !== void 0 && (a38.pannable = e39), s10 !== void 0 && (a38.zoomable = s10), r27 !== void 0 && (a38.paneDefaults = r27), i36 !== void 0 && (a38.panes = i36), n20 !== void 0 && (a38.transitions = n20), o33 !== void 0 && (a38.seriesColors = o33), h5 !== void 0 && (a38.seriesDefaults = h5), c10 !== void 0 && (a38.axisDefaults = c10), a38 = Object.assign(a38, this.optionsStore.getState()), p9 && (a38 = p9(a38)), a38;
  }
  /**
   * @hidden
   */
  refresh() {
    if (this.chartInstance !== null) {
      const t38 = this.themeStore.getState(), e39 = this.getChartOptions(), s10 = e39.transitions;
      this.suppressTransitions && (e39.transitions = false), this.props.onRefresh ? this.props.onRefresh.call(void 0, e39, t38, this.chartInstance) : this.chartInstance.setOptions(e39, t38), this.suppressTransitions && (e39.transitions = s10, this.suppressTransitions = false);
    }
  }
  /**
   * @hidden
   */
  instantiateCoreChart() {
    const { dir: t38, chartConstructor: e39 } = this.props, s10 = this.getChartOptions();
    this.chartInstance = new e39(this.element, s10, this.themeStore.getState(), {
      rtl: this.getDirection(t38),
      intlService: l(this),
      observer: this.chartObserver,
      sender: this
    });
  }
  /* Triggers public dom event handlers */
  /**
   * @hidden
   */
  trigger(t38, e39) {
    const s10 = this.props.getTarget(), r27 = Q(t38, e39, s10), i36 = "on" + t38.charAt(0).toUpperCase() + t38.slice(1), n20 = this.observersStore.getState();
    let o33 = false;
    for (let h5 = 0; h5 < n20.length; h5++)
      n20[h5].trigger(t38, e39) && (o33 = true);
    return o33 === false && r27 && this.props.hasOwnProperty(i36) ? (this.props[i36].call(void 0, r27), r27.isDefaultPrevented && r27.isDefaultPrevented()) : o33;
  }
  /* Used by (event)InstanceObserver to check the wrapper for supported events */
  /**
   * @hidden
   */
  requiresHandlers(t38) {
    for (let e39 = 0; e39 < t38.length; e39++) {
      const s10 = t38[e39], r27 = "on" + s10.charAt(0).toUpperCase() + s10.slice(1);
      if (this.props.hasOwnProperty(r27))
        return true;
    }
    return false;
  }
  /* Triggers private dom event handlers */
  /**
   * @hidden
   */
  triggerDomEvent(t38, e39) {
    const s10 = this.observersStore.getState();
    let r27 = false;
    for (let i36 = 0; i36 < s10.length; i36++)
      s10[i36].trigger(t38, e39) && (r27 = true);
    return r27;
  }
};
d2.propTypes = {
  dir: import_prop_types.default.string,
  renderAs: import_prop_types.default.oneOf(["svg", "canvas"])
}, d2.defaultProps = {
  renderAs: "svg"
};
var f = d2;
p(f);

// node_modules/@progress/kendo-react-charts/DonutCenter.mjs
var o3 = __toESM(require_react(), 1);
var c4 = class c5 extends o3.Component {
  constructor(e39, t38) {
    super(e39, t38), this.context = null, this.state = {
      donutCenterStyles: null
    }, this.chartObserver = new instance_observer_default(this, {
      render: "onRender"
    }), t38.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { render: e39 } = this.props, { donutCenterStyles: t38 } = this.state;
    let r27 = null;
    return e39 && t38 && (r27 = o3.createElement("div", { className: "k-chart-donut-center", style: t38 }, o3.createElement(e39, null))), r27;
  }
  onRender(e39) {
    var l8;
    const t38 = (l8 = this.context) == null ? void 0 : l8.optionsStore.getState().series, r27 = Array.isArray(t38) ? t38[0] : null, i36 = e39.sender._plotArea.charts;
    if (!r27 || r27.type !== "donut" || i36[0].points.length === 0)
      return;
    const s10 = i36[0].points[0].sector, n20 = s10.innerRadius, h5 = s10.center.y - n20, p9 = s10.center.x - n20, a38 = n20 * 2;
    this.setState({
      donutCenterStyles: {
        height: a38,
        left: p9,
        top: h5,
        width: a38
      }
    });
  }
};
c4.contextType = e4;
var d4 = c4;

// node_modules/@progress/kendo-react-charts/Chart.mjs
var f2 = class extends t3.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the Chart.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the Chart.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { donutCenterRender: r27, children: e39, className: a38, ...s10 } = this.props;
    return t3.createElement(
      f,
      {
        ...s10,
        ref: (n20) => this._baseChart = n20,
        chartConstructor: chart_default,
        getTarget: this.getTarget,
        wrapper: "div",
        className: n("k-chart k-widget", a38)
      },
      e39,
      t3.createElement(d4, { render: r27 })
    );
  }
};

// node_modules/@progress/kendo-react-charts/Sparkline.mjs
var a8 = __toESM(require_react(), 1);
var m2 = class extends a8.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.deriveOptionsFromParent = (t38) => {
      const { type: s10, data: e39 } = this.props, r27 = Object.assign({}, t38, { type: s10, data: e39 });
      return sparkline_default.normalizeOptions(r27);
    }, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the Sparkline.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the Sparkline.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { children: t38, type: s10, className: e39, ...r27 } = this.props;
    return a8.createElement(
      f,
      {
        ...r27,
        ref: (i36) => this._baseChart = i36,
        chartConstructor: sparkline_default,
        getTarget: this.getTarget,
        wrapper: "span",
        deriveOptionsFromParent: this.deriveOptionsFromParent,
        className: n("k-sparkline k-widget", e39)
      },
      t38
    );
  }
};

// node_modules/@progress/kendo-react-charts/StockChart.mjs
var s2 = __toESM(require_react(), 1);
var h3 = {
  autoBindElements: true,
  liveDrag: false,
  partialRedraw: true
};
var m3 = class extends s2.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.deriveOptionsFromParent = (t38) => {
      const r27 = Object.assign({}, t38.navigator || {}, h3);
      return Object.assign({}, t38, { navigator: r27 });
    }, this.onRefresh = (t38, r27, e39) => {
      this.props.partialRedraw ? (e39.applyOptions(t38), e39.bindCategories(), e39.navigator.redrawSlaves()) : e39.setOptions(t38, r27);
    }, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the StockChart.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the StockChart.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { children: t38, className: r27, ...e39 } = this.props;
    return s2.createElement(
      f,
      {
        ...e39,
        ref: (a38) => this._baseChart = a38,
        chartConstructor: stock_chart_default,
        getTarget: this.getTarget,
        wrapper: "div",
        deriveOptionsFromParent: this.deriveOptionsFromParent,
        onRefresh: this.onRefresh,
        className: n("k-stockchart k-widget", r27)
      },
      t38
    );
  }
};

// node_modules/@progress/kendo-react-charts/components/base/CollectionConfigurationComponent.mjs
var s3 = __toESM(require_react(), 1);
var p5 = class p6 extends s3.Component {
  constructor(r27, t38) {
    super(r27, t38), this.optionsStore = t38.optionsStore;
  }
  renderChildren(r27, t38) {
    const { children: o33 } = r27.props, { _chartKey: c10, _parentStore: e39 } = this.props, n20 = {
      ...r27.props,
      _chartCollectionIdxKey: `${c10}_${t38}`,
      _parentStore: e39
    };
    return s3.cloneElement(r27, n20, o33);
  }
  render() {
    const { _chartKey: r27, _parentStore: t38, children: o33 } = this.props;
    return (t38 || this.optionsStore).dispatch({
      chartKey: r27,
      payload: []
    }), s3.Children.map(o33, (e39, n20) => s3.isValidElement(e39) ? this.renderChildren(e39, n20) : e39);
  }
};
p5.contextType = e4;
var a9 = p5;

// node_modules/@progress/kendo-react-charts/components/base/ConfigurationComponent.mjs
var r10 = __toESM(require_react(), 1);
var s4 = class s5 extends r10.Component {
  constructor(t38, e39) {
    super(t38, e39), this.optionsStore = e39.optionsStore, this.childStore = T(a3);
  }
  render() {
    const { children: t38 } = this.props;
    return t38 !== void 0 ? r10.Children.map(t38, (e39) => r10.isValidElement(e39) ? this.renderChildren(e39) : e39) : null;
  }
  componentDidMount() {
    this.dispatch();
  }
  componentDidUpdate() {
    this.dispatch();
  }
  dispatch() {
    const { _chartKey: t38, _chartCollectionIdxKey: e39, _parentStore: o33, children: a38, ...n20 } = this.props;
    (o33 || this.optionsStore).dispatch({
      chartKey: t38,
      chartCollectionIdxKey: e39,
      payload: Object.assign({}, n20, this.childStore.getState())
    });
  }
  renderChildren(t38) {
    const { children: e39 } = t38.props, o33 = {
      ...t38.props,
      _parentStore: this.childStore
    };
    return r10.cloneElement(t38, o33, e39);
  }
};
s4.contextType = e4;
var i16 = s4;

// node_modules/@progress/kendo-react-charts/ChartBreadcrumb.mjs
var n9 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);

// node_modules/@progress/kendo-react-charts/events/drilldown-state-change-event.mjs
var n8 = class {
  /**
   * @hidden
   */
  constructor(t38) {
    this.currentState = t38.currentState, this.nextState = t38.nextState;
  }
};

// node_modules/@progress/kendo-react-charts/ChartBreadcrumb.mjs
var s6 = n9.forwardRef((t38, m11) => {
  const a38 = n9.useRef(null), u7 = n9.useRef(null), d6 = {
    valueField: i17.valueField,
    textField: i17.textField,
    iconField: i17.iconField,
    iconClassField: i17.iconClassField,
    ...t38
  };
  n9.useImperativeHandle(a38, () => ({
    element: u7.current,
    props: d6
  })), n9.useImperativeHandle(m11, () => a38.current);
  let l8 = [{
    id: "0",
    ...t38.rootItem || {
      text: "Home",
      icon: n9.createElement(
        M,
        {
          icon: homeIcon,
          style: { marginInlineEnd: "4px" }
        }
      )
    }
  }];
  t38.drilldownState && (l8 = [
    ...l8,
    ...t38.drilldownState.steps.map((o33, r27) => ({
      id: (r27 + 1).toString(),
      text: o33.drilldownValue
    }))
  ]);
  const b2 = { ...d6, data: l8 }, p9 = (o33) => {
    var c10;
    const r27 = "onDrilldownStateChange";
    if (t38.hasOwnProperty(r27)) {
      const f4 = l8.findIndex((g2) => g2.id === o33.id), F = { steps: (((c10 = t38.drilldownState) == null ? void 0 : c10.steps) || []).slice(0, f4) }, S2 = new n8({ currentState: t38.drilldownState, nextState: F });
      t38[r27].call(void 0, S2);
    }
  };
  return n9.createElement("div", null, n9.createElement(v2, { ...b2, onItemSelect: p9 }));
});
var x4 = {
  id: import_prop_types2.default.string,
  style: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  breadcrumbOrderedList: import_prop_types2.default.elementType,
  breadcrumbListItem: import_prop_types2.default.elementType,
  breadcrumbDelimiter: import_prop_types2.default.elementType,
  breadcrumbLink: import_prop_types2.default.elementType,
  dir: import_prop_types2.default.oneOf(["ltr", "rtl"]),
  disabled: import_prop_types2.default.bool,
  valueField: import_prop_types2.default.string,
  textField: import_prop_types2.default.string,
  iconField: import_prop_types2.default.string,
  iconClassField: import_prop_types2.default.string,
  onItemSelect: import_prop_types2.default.func,
  ariaLabel: import_prop_types2.default.string,
  onDrilldownStateChange: import_prop_types2.default.func,
  drilldownState: import_prop_types2.default.shape({
    steps: import_prop_types2.default.array
  }),
  rootItem: import_prop_types2.default.object
};
var i17 = {
  valueField: "id",
  textField: "text",
  iconField: "icon",
  iconClassField: "iconClass",
  data: []
};
s6.displayName = "KendoReactChartBreadcrumb";
s6.propTypes = x4;

// node_modules/@progress/kendo-react-charts/ChartNoDataOverlay.mjs
var e8 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/messages.mjs
var a10 = "charts.nodata";
var t4 = {
  [a10]: "No data available."
};

// node_modules/@progress/kendo-react-charts/ChartNoDataOverlay.mjs
var i18 = (a38) => {
  const o33 = i2();
  return e8.createElement("div", { className: n("k-chart-overlay", a38.className), style: { display: "none", ...a38.style } }, e8.createElement("div", { className: "k-no-data" }, a38.children === void 0 ? o33.toLanguageString(a10, t4[a10]) : a38.children));
};
i18.displayName = "ChartNoDataOverlay";

// node_modules/@progress/kendo-react-charts/methods/index.mjs
var e9 = (n20, a38) => {
  if (n20 && n20.chartInstance !== null)
    return n20.chartInstance.findAxisByName(a38);
};
var s7 = (n20, a38) => {
  if (n20 && n20.chartInstance !== null)
    return n20.chartInstance.findPaneByIndex(a38);
};
var i19 = (n20, a38) => {
  if (n20 && n20.chartInstance !== null)
    return n20.chartInstance.findPaneByName(a38);
};
var c6 = (n20, a38 = {}) => {
  if (n20 && n20.chartInstance !== null)
    return n20.chartInstance.exportVisual(a38);
};

// node_modules/@progress/kendo-react-charts/components/axis-defaults/Title.mjs
var e10 = __toESM(require_react(), 1);
var i20 = (t38) => e10.createElement(i16, { ...t38, _chartKey: "title" });
i20.displayName = "ChartAxisDefaultsTitle";

// node_modules/@progress/kendo-react-charts/components/axis-defaults/Labels.mjs
var e11 = __toESM(require_react(), 1);
var o4 = (a38) => e11.createElement(i16, { ...a38, _chartKey: "labels" });
o4.displayName = "ChartAxisDefaultsLabels";

// node_modules/@progress/kendo-react-charts/components/axis-defaults/Crosshair.mjs
var t5 = __toESM(require_react(), 1);
var s8 = (r27) => t5.createElement(i16, { visible: true, ...r27, _chartKey: "crosshair" });
s8.displayName = "ChartAxisDefaultsCrosshair";

// node_modules/@progress/kendo-react-charts/components/axis-defaults/CrosshairTooltip.mjs
var o5 = __toESM(require_react(), 1);
var i21 = (t38) => o5.createElement(i16, { visible: true, ...t38, _chartKey: "tooltip" });
i21.displayName = "ChartAxisDefaultsCrosshairTooltip";

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Crosshair.mjs
var o6 = __toESM(require_react(), 1);
var a11 = (r27) => o6.createElement(i16, { visible: true, ...r27, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/CrosshairTooltip.mjs
var t6 = __toESM(require_react(), 1);
var i22 = (o33) => t6.createElement(i16, { visible: true, ...o33, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Title.mjs
var e12 = __toESM(require_react(), 1);
var r11 = (t38) => e12.createElement(i16, { ...t38, _chartKey: "title" });
r11.displayName = "ChartCategoryAxisTitle";

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Labels.mjs
var t7 = __toESM(require_react(), 1);
var a12 = (e39) => t7.createElement(i16, { visible: true, ...e39, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Notes.mjs
var o7 = __toESM(require_react(), 1);
var a13 = (t38) => o7.createElement(i16, { ...t38, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/NotesIcon.mjs
var t8 = __toESM(require_react(), 1);
var n10 = (o33) => t8.createElement(i16, { ...o33, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/NotesLabel.mjs
var e13 = __toESM(require_react(), 1);
var a14 = (t38) => e13.createElement(i16, { ...t38, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/RangeLabels.mjs
var t9 = __toESM(require_react(), 1);
var o8 = (e39) => t9.createElement(i16, { visible: true, ...e39, _chartKey: "rangeLabels" });

// node_modules/@progress/kendo-react-charts/components/pane-defaults/Title.mjs
var e14 = __toESM(require_react(), 1);
var o9 = (t38) => e14.createElement(i16, { ...t38, _chartKey: "title" });
o9.displayName = "ChartPaneDefaultsTitle";

// node_modules/@progress/kendo-react-charts/components/legend/Item.mjs
var t10 = __toESM(require_react(), 1);
var o10 = (e39) => t10.createElement(i16, { ...e39, _chartKey: "item" });
o10.displayName = "ChartLegendItem";

// node_modules/@progress/kendo-react-charts/components/legend/Title.mjs
var t11 = __toESM(require_react(), 1);
var r12 = (e39) => t11.createElement(i16, { ...e39, _chartKey: "title" });
r12.displayName = "ChartLegendTitle";

// node_modules/@progress/kendo-react-charts/components/legend/InactiveItems.mjs
var t12 = __toESM(require_react(), 1);
var n11 = (e39) => t12.createElement(i16, { ...e39, _chartKey: "inactiveItems" });
n11.displayName = "ChartLegendInactiveItems";

// node_modules/@progress/kendo-react-charts/components/series-item/Tooltip.mjs
var o11 = __toESM(require_react(), 1);
var i23 = (t38) => o11.createElement(i16, { ...t38, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/series-item/Outliers.mjs
var e15 = __toESM(require_react(), 1);
var i24 = (t38) => e15.createElement(i16, { ...t38, _chartKey: "outliers" });

// node_modules/@progress/kendo-react-charts/components/series-item/Notes.mjs
var e16 = __toESM(require_react(), 1);
var n12 = (t38) => e16.createElement(i16, { ...t38, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/series-item/Markers.mjs
var e17 = __toESM(require_react(), 1);
var a15 = (r27) => e17.createElement(i16, { ...r27, _chartKey: "markers" });

// node_modules/@progress/kendo-react-charts/components/series-item/Labels.mjs
var t13 = __toESM(require_react(), 1);
var a16 = (e39) => t13.createElement(i16, { visible: true, ...e39, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/series-item/Highlight.mjs
var e18 = __toESM(require_react(), 1);
var i25 = (t38) => e18.createElement(i16, { ...t38, _chartKey: "highlight" });

// node_modules/@progress/kendo-react-charts/components/series-item/Extremes.mjs
var t14 = __toESM(require_react(), 1);
var m4 = (e39) => t14.createElement(i16, { ...e39, _chartKey: "extremes" });

// node_modules/@progress/kendo-react-charts/components/series-item/ErrorBars.mjs
var o12 = __toESM(require_react(), 1);
var a17 = (r27) => o12.createElement(i16, { ...r27, _chartKey: "errorBars" });

// node_modules/@progress/kendo-react-charts/components/series-item/LabelsFrom.mjs
var r13 = __toESM(require_react(), 1);
var m5 = (o33) => r13.createElement(i16, { ...o33, _chartKey: "from" });

// node_modules/@progress/kendo-react-charts/components/series-item/LabelsTo.mjs
var t15 = __toESM(require_react(), 1);
var a18 = (o33) => t15.createElement(i16, { ...o33, _chartKey: "to" });

// node_modules/@progress/kendo-react-charts/components/series-item/NotesLabel.mjs
var t16 = __toESM(require_react(), 1);
var a19 = (e39) => t16.createElement(i16, { ...e39, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/series-item/NotesIcon.mjs
var t17 = __toESM(require_react(), 1);
var n13 = (o33) => t17.createElement(i16, { ...o33, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Crosshair.mjs
var o13 = __toESM(require_react(), 1);
var a20 = (r27) => o13.createElement(i16, { visible: true, ...r27, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/CrosshairTooltip.mjs
var t18 = __toESM(require_react(), 1);
var i26 = (o33) => t18.createElement(i16, { visible: true, ...o33, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Title.mjs
var e19 = __toESM(require_react(), 1);
var i27 = (t38) => e19.createElement(i16, { ...t38, _chartKey: "title" });
i27.displayName = "ChartValueAxisTitle";

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Labels.mjs
var t19 = __toESM(require_react(), 1);
var a21 = (e39) => t19.createElement(i16, { visible: true, ...e39, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Notes.mjs
var o14 = __toESM(require_react(), 1);
var a22 = (t38) => o14.createElement(i16, { ...t38, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/NotesIcon.mjs
var t20 = __toESM(require_react(), 1);
var n14 = (o33) => t20.createElement(i16, { ...o33, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/NotesLabel.mjs
var t21 = __toESM(require_react(), 1);
var r14 = (e39) => t21.createElement(i16, { ...e39, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Crosshair.mjs
var o15 = __toESM(require_react(), 1);
var i28 = (r27) => o15.createElement(i16, { visible: true, ...r27, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/CrosshairTooltip.mjs
var t22 = __toESM(require_react(), 1);
var i29 = (o33) => t22.createElement(i16, { visible: true, ...o33, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Title.mjs
var e20 = __toESM(require_react(), 1);
var o16 = (t38) => e20.createElement(i16, { ...t38, _chartKey: "title" });
o16.displayName = "ChartXAxisTitle";

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Labels.mjs
var t23 = __toESM(require_react(), 1);
var a23 = (e39) => t23.createElement(i16, { visible: true, ...e39, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Notes.mjs
var o17 = __toESM(require_react(), 1);
var n15 = (t38) => o17.createElement(i16, { ...t38, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/NotesIcon.mjs
var t24 = __toESM(require_react(), 1);
var n16 = (o33) => t24.createElement(i16, { ...o33, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/NotesLabel.mjs
var e21 = __toESM(require_react(), 1);
var a24 = (t38) => e21.createElement(i16, { ...t38, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Crosshair.mjs
var o18 = __toESM(require_react(), 1);
var i30 = (r27) => o18.createElement(i16, { visible: true, ...r27, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/CrosshairTooltip.mjs
var t25 = __toESM(require_react(), 1);
var i31 = (o33) => t25.createElement(i16, { visible: true, ...o33, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Title.mjs
var e22 = __toESM(require_react(), 1);
var o19 = (t38) => e22.createElement(i16, { ...t38, _chartKey: "title" });
o19.displayName = "ChartYAxisTitle";

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Labels.mjs
var t26 = __toESM(require_react(), 1);
var a25 = (e39) => t26.createElement(i16, { visible: true, ...e39, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Notes.mjs
var o20 = __toESM(require_react(), 1);
var n17 = (t38) => o20.createElement(i16, { ...t38, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/NotesIcon.mjs
var t27 = __toESM(require_react(), 1);
var n18 = (o33) => t27.createElement(i16, { ...o33, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/NotesLabel.mjs
var e23 = __toESM(require_react(), 1);
var a26 = (t38) => e23.createElement(i16, { ...t38, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/navigator/CategoryAxis.mjs
var a27 = __toESM(require_react(), 1);
var r15 = (t38) => a27.createElement(i16, { ...t38, _chartKey: "categoryAxis" });
r15.displayName = "ChartNavigatorCategoryAxis";

// node_modules/@progress/kendo-react-charts/components/navigator/Hint.mjs
var o21 = __toESM(require_react(), 1);
var e24 = (t38) => o21.createElement(i16, { ...t38, _chartKey: "hint" });

// node_modules/@progress/kendo-react-charts/components/navigator/Pane.mjs
var t28 = __toESM(require_react(), 1);
var o22 = (a38) => t28.createElement(i16, { ...a38, _chartKey: "pane" });
o22.displayName = "ChartNavigatorPane";

// node_modules/@progress/kendo-react-charts/components/navigator/Select.mjs
var e25 = __toESM(require_react(), 1);
var a28 = (t38) => e25.createElement(i16, { ...t38, _chartKey: "select" });

// node_modules/@progress/kendo-react-charts/components/navigator/Series.mjs
var o23 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/navigator/SeriesItem.mjs
var e26 = __toESM(require_react(), 1);
var a29 = (t38) => e26.createElement(i16, { ...t38 });
a29.displayName = "ChartNavigatorSeriesItem";

// node_modules/@progress/kendo-react-charts/components/navigator/Series.mjs
var m6 = (r27) => o23.createElement(a9, { ...r27, _chartKey: "series" });
m6.propTypes = {
  children: function(r27, e39, t38) {
    return l3(r27, e39, t38, a29);
  }
};

// node_modules/@progress/kendo-react-charts/components/ChartArea.mjs
var a30 = __toESM(require_react(), 1);
var e27 = (r27) => a30.createElement(i16, { ...r27, _chartKey: "chartArea" });
e27.displayName = "ChartArea";

// node_modules/@progress/kendo-react-charts/components/AxisDefaults.mjs
var e28 = __toESM(require_react(), 1);
var r16 = (t38) => e28.createElement(i16, { ...t38, _chartKey: "axisDefaults" });

// node_modules/@progress/kendo-react-charts/components/CategoryAxis.mjs
var a31 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/CategoryAxisItem.mjs
var e29 = __toESM(require_react(), 1);
var r17 = (t38) => e29.createElement(i16, { ...t38 });
r17.displayName = "ChartCategoryAxisItem";

// node_modules/@progress/kendo-react-charts/components/CategoryAxis.mjs
var t29 = (r27) => a31.createElement(a9, { ...r27, _chartKey: "categoryAxis" });
t29.propTypes = {
  children: function(r27, o33, e39) {
    return l3(r27, o33, e39, r17);
  }
};
t29.displayName = "ChartCategoryAxis";

// node_modules/@progress/kendo-react-charts/components/Legend.mjs
var t30 = __toESM(require_react(), 1);
var o24 = (e39) => t30.createElement(i16, { visible: true, ...e39, _chartKey: "legend" });
o24.displayName = "ChartLegend";

// node_modules/@progress/kendo-react-charts/components/Navigator.mjs
var o25 = __toESM(require_react(), 1);
var r18 = (t38) => o25.createElement(i16, { visible: true, position: "bottom", ...t38, _chartKey: "navigator" });
r18.displayName = "ChartNavigator";

// node_modules/@progress/kendo-react-charts/components/Pane.mjs
var a32 = __toESM(require_react(), 1);
var o26 = (t38) => a32.createElement(i16, { ...t38 });
o26.displayName = "ChartPane";

// node_modules/@progress/kendo-react-charts/components/PaneDefaults.mjs
var e30 = __toESM(require_react(), 1);
var o27 = (a38) => e30.createElement(i16, { ...a38, _chartKey: "paneDefaults" });
o27.displayName = "ChartPaneDefaults";

// node_modules/@progress/kendo-react-charts/components/Panes.mjs
var e31 = __toESM(require_react(), 1);
var m7 = (r27) => e31.createElement(a9, { ...r27, _chartKey: "panes" });
m7.propTypes = {
  children: function(r27, o33, t38) {
    return l3(r27, o33, t38, o26);
  }
};

// node_modules/@progress/kendo-react-charts/components/PlotArea.mjs
var o28 = __toESM(require_react(), 1);
var a33 = (t38) => o28.createElement(i16, { ...t38, _chartKey: "plotArea" });

// node_modules/@progress/kendo-react-charts/components/Series.mjs
var i32 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/SeriesItem.mjs
var r19 = __toESM(require_react(), 1);
var c7 = (t38) => {
  let l8 = (e39) => r19.createElement(r19.Fragment, null);
  t38.drilldownSeriesFactory && (l8 = t38.drilldownSeriesFactory);
  const n20 = (e39) => {
    var a38, o33;
    return e39 && ((o33 = (a38 = e39.drilldownState) == null ? void 0 : a38.steps) == null ? void 0 : o33.find(({ seriesName: i36 }) => i36 === t38.name));
  };
  return r19.createElement(e4.Consumer, null, (e39) => n20(e39) ? r19.createElement(
    l8,
    {
      _chartCollectionIdxKey: t38._chartCollectionIdxKey,
      drilldownValue: n20(e39).drilldownValue
    }
  ) : r19.createElement(i16, { ...t38 }));
};
c7.displayName = "ChartSeriesItem";

// node_modules/@progress/kendo-react-charts/components/Series.mjs
var r20 = (e39) => i32.createElement(a9, { ...e39, _chartKey: "series" });
r20.propTypes = {
  children: function(e39, t38, o33) {
    return l3(e39, t38, o33, c7);
  }
};
r20.displayName = "ChartSeries";

// node_modules/@progress/kendo-react-charts/components/SeriesDefaults.mjs
var t31 = __toESM(require_react(), 1);
var a34 = (e39) => t31.createElement(i16, { ...e39, _chartKey: "seriesDefaults" });

// node_modules/@progress/kendo-react-charts/components/Subtitle.mjs
var e32 = __toESM(require_react(), 1);
var r21 = (t38) => e32.createElement(i16, { ...t38, _chartKey: "subtitle" });
r21.displayName = "ChartSubtitle";

// node_modules/@progress/kendo-react-charts/components/Title.mjs
var e33 = __toESM(require_react(), 1);
var r22 = (t38) => e33.createElement(i16, { ...t38, _chartKey: "title" });
r22.displayName = "ChartTitle";

// node_modules/@progress/kendo-react-charts/components/Tooltip.mjs
var o29 = __toESM(require_react(), 1);
var r23 = (t38) => o29.createElement(i16, { visible: true, ...t38, _chartKey: "tooltip" });
r23.displayName = "ChartTooltip";

// node_modules/@progress/kendo-react-charts/components/ValueAxis.mjs
var a35 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/ValueAxisItem.mjs
var e34 = __toESM(require_react(), 1);
var o30 = (t38) => e34.createElement(i16, { ...t38 });
o30.displayName = "ChartValueAxisItem";

// node_modules/@progress/kendo-react-charts/components/ValueAxis.mjs
var r24 = (e39) => a35.createElement(a9, { ...e39, _chartKey: "valueAxis" });
r24.propTypes = {
  children: function(e39, t38, o33) {
    return l3(e39, t38, o33, o30);
  }
};
r24.displayName = "ChartValueAxis";

// node_modules/@progress/kendo-react-charts/components/XAxis.mjs
var i33 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/XAxisItem.mjs
var e35 = __toESM(require_react(), 1);
var m8 = (t38) => e35.createElement(i16, { ...t38 });
m8.displayName = "ChartXAxisItem";

// node_modules/@progress/kendo-react-charts/components/XAxis.mjs
var r25 = (t38) => i33.createElement(a9, { ...t38, _chartKey: "xAxis" });
r25.prototype = {
  children: function(t38, o33, e39) {
    return l3(t38, o33, e39, m8);
  }
};
r25.displayName = "ChartXAxis";

// node_modules/@progress/kendo-react-charts/components/YAxis.mjs
var i34 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/YAxisItem.mjs
var e36 = __toESM(require_react(), 1);
var m9 = (t38) => e36.createElement(i16, { ...t38 });
m9.displayName = "ChartYAxisItem";

// node_modules/@progress/kendo-react-charts/components/YAxis.mjs
var t32 = (r27) => i34.createElement(a9, { ...r27, _chartKey: "yAxis" });
t32.propTypes = {
  children: function(r27, o33, e39) {
    return l3(r27, o33, e39, m9);
  }
};
t32.displayName = "ChartYAxis";

// node_modules/@progress/kendo-react-charts/components/Zoomable.mjs
var t33 = __toESM(require_react(), 1);
var a36 = (o33) => t33.createElement(i16, { ...o33, _chartKey: "zoomable" });

// node_modules/@progress/kendo-react-charts/sankey/Sankey.mjs
var e38 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/sankey/propTypes.mjs
var import_prop_types3 = __toESM(require_prop_types(), 1);
var r26 = import_prop_types3.default.exact({
  left: import_prop_types3.default.number,
  top: import_prop_types3.default.number
});
var i35 = {
  left: import_prop_types3.default.number,
  right: import_prop_types3.default.number
};
var l7 = {
  ...i35,
  top: import_prop_types3.default.number,
  bottom: import_prop_types3.default.number
};
var t34 = import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.exact(l7)]);
var n19 = t34;
var o31 = import_prop_types3.default.exact({
  width: import_prop_types3.default.number,
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  dashType: import_prop_types3.default.string
});
var s9 = {
  visible: import_prop_types3.default.bool,
  font: import_prop_types3.default.string,
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  align: import_prop_types3.default.oneOf(["left", "right", "center"]),
  position: import_prop_types3.default.oneOf(["inside", "before", "after"]),
  padding: n19,
  margin: import_prop_types3.default.exact(i35),
  border: o31,
  offset: r26
};
var a37 = {
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  offset: r26,
  padding: import_prop_types3.default.number,
  width: import_prop_types3.default.number,
  focusHighlight: import_prop_types3.default.exact({
    border: o31
  })
};
var c8 = {
  colorType: import_prop_types3.default.oneOf(["static", "source", "target"]),
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  highlight: import_prop_types3.default.exact({
    opacity: import_prop_types3.default.number,
    inactiveOpacity: import_prop_types3.default.number
  }),
  focusHighlight: import_prop_types3.default.exact({
    border: o31
  })
};
var b = import_prop_types3.default.exact({
  text: import_prop_types3.default.string,
  ...s9
});
var p7 = import_prop_types3.default.exact({
  id: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]).isRequired,
  label: b.isRequired,
  ...a37
});
var u6 = import_prop_types3.default.exact({
  sourceId: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]).isRequired,
  targetId: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]).isRequired,
  value: import_prop_types3.default.number.isRequired,
  ...c8
});
var f3 = {
  data: import_prop_types3.default.exact({
    nodes: import_prop_types3.default.arrayOf(p7.isRequired).isRequired,
    links: import_prop_types3.default.arrayOf(u6.isRequired).isRequired
  }).isRequired,
  links: import_prop_types3.default.exact(c8),
  nodes: import_prop_types3.default.exact(a37),
  labels: import_prop_types3.default.exact(s9),
  legend: import_prop_types3.default.exact({
    align: import_prop_types3.default.oneOf(["start", "center", "end"]),
    background: import_prop_types3.default.string,
    border: o31,
    height: import_prop_types3.default.number,
    labels: import_prop_types3.default.object,
    margin: t34,
    offsetX: import_prop_types3.default.number,
    offsetY: import_prop_types3.default.number,
    orientation: import_prop_types3.default.oneOf(["vertical", "horizontal"]),
    padding: n19,
    position: import_prop_types3.default.oneOf(["top", "bottom", "left", "right", "custom"]),
    reverse: import_prop_types3.default.bool,
    visible: import_prop_types3.default.bool,
    width: import_prop_types3.default.number,
    item: import_prop_types3.default.object,
    title: import_prop_types3.default.object
  }),
  title: import_prop_types3.default.exact({
    align: import_prop_types3.default.oneOf(["center", "left", "right"]),
    background: import_prop_types3.default.string,
    border: o31,
    color: import_prop_types3.default.string,
    font: import_prop_types3.default.string,
    margin: t34,
    padding: n19,
    position: import_prop_types3.default.oneOf(["top", "bottom"]),
    text: import_prop_types3.default.string,
    visible: import_prop_types3.default.bool
  }),
  tooltip: import_prop_types3.default.exact({
    visible: import_prop_types3.default.bool,
    offset: import_prop_types3.default.number,
    followPointer: import_prop_types3.default.bool,
    delay: import_prop_types3.default.number,
    linkComponent: import_prop_types3.default.any,
    nodeComponent: import_prop_types3.default.any
  }),
  className: import_prop_types3.default.string,
  style: import_prop_types3.default.object,
  dir: import_prop_types3.default.string,
  disableAutoLayout: import_prop_types3.default.bool,
  disableKeyboardNavigation: import_prop_types3.default.bool,
  onNodeEnter: import_prop_types3.default.func,
  onNodeLeave: import_prop_types3.default.func,
  onLinkEnter: import_prop_types3.default.func,
  onLinkLeave: import_prop_types3.default.func,
  onNodeClick: import_prop_types3.default.func,
  onLinkClick: import_prop_types3.default.func
};

// node_modules/@progress/kendo-react-charts/sankey/SankeyTooltip.mjs
var t36 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/sankey/messages.mjs
var t35 = "sankey.tooltipUnitFormat";
var o32 = {
  [t35]: "({0} units)"
};

// node_modules/@progress/kendo-react-charts/sankey/SankeyTooltip.mjs
var R = (e39) => {
  const {
    Content: l8,
    dir: o33,
    offset: r27,
    event: { tooltipData: n20, dataItem: E2, nodeValue: y }
  } = e39, p9 = t36.useRef(null);
  return t36.useEffect(() => {
    const i36 = p9.current;
    if (!n20 || !i36)
      return;
    const f4 = { width: i36.offsetWidth, height: i36.offsetHeight }, a38 = { ...n20.popupOffset }, s10 = n20.popupAlign;
    a38.left += s10.horizontal === "left" ? r27 : -1 * r27, s10.horizontal === "right" && (a38.left -= f4.width), s10.vertical === "bottom" ? a38.top -= f4.height + r27 : a38.top += r27, i36.style.left = `${a38.left}px`, i36.style.top = `${a38.top}px`, i36.style.visibility = "";
  }, [n20]), t36.createElement(
    "div",
    {
      ref: p9,
      style: { visibility: "hidden" },
      dir: o33,
      className: "k-tooltip k-sankey-tooltip k-chart-tooltip k-chart-shared-tooltip"
    },
    t36.createElement("div", { className: "k-tooltip-content" }, t36.createElement(l8, { dir: o33, dataItem: E2, nodeValue: y }))
  );
};
var d5 = 3;
var z = `0 ${d5}px`;
var h4 = { display: "flex", alignItems: "center" };
var m10 = (e39) => t36.createElement(
  "div",
  {
    style: {
      width: 15,
      height: 15,
      backgroundColor: e39.color,
      display: "inline-flex",
      marginLeft: d5
    }
  }
);
var c9 = (e39) => t36.createElement("span", { style: { margin: z } }, e39.children);
var g = (e39) => i().format(
  i2().toLanguageString(t35, o32[t35]),
  [e39 || 0]
);
var S = (e39) => {
  const { color: l8, label: o33 } = e39.dataItem;
  return t36.createElement("div", { style: h4, className: "k-tooltip-content" }, t36.createElement(m10, { color: l8 }), t36.createElement(c9, null, o33.text), t36.createElement(c9, null, g(e39.nodeValue)));
};
var $ = (e39) => {
  const { source: l8, target: o33, value: r27 } = e39.dataItem, n20 = e39.dir === "rtl" ? arrowLeftIcon : arrowRightIcon;
  return t36.createElement("div", { style: h4 }, t36.createElement(m10, { color: l8.color }), t36.createElement(c9, null, l8.label.text), t36.createElement(v, { icon: n20, name: n20.name }), t36.createElement(m10, { color: o33.color }), t36.createElement(c9, null, o33.label.text), t36.createElement(c9, null, g(r27)));
};

// node_modules/@progress/kendo-react-charts/sankey/Sankey.mjs
var O = 12;
var p8 = {
  offset: O,
  visible: true
};
var j = ["nodeEnter", "nodeLeave", "linkEnter", "linkLeave", "nodeClick", "linkClick"];
var q = (n20, u7) => {
  n20 && (n20.unbind(), j.forEach((s10) => {
    u7[s10] && n20.bind(s10, u7[s10]);
  }));
};
var P = e38.forwardRef((n20, u7) => {
  const s10 = !h(e6, { component: "Sankey" }), l8 = e38.useRef(null), o33 = e38.useRef(null), c10 = u(l8, n20.dir, [n20.dir, l8.current]), k = e38.useRef(null), {
    data: m11,
    links: y,
    nodes: v5,
    labels: E2,
    title: C3,
    legend: b2,
    tooltip: d6 = p8,
    disableAutoLayout: g2,
    disableKeyboardNavigation: L
  } = n20, T3 = e38.useRef();
  T3.current = n20;
  const [R2, h5] = e38.useState(null), N = e38.useCallback(
    (r27) => {
      const {
        visible: a38,
        offset: t38 = O,
        nodeComponent: f4 = S,
        linkComponent: w = $
      } = { ...p8, ...d6 };
      if (a38) {
        const x5 = {
          event: r27,
          offset: t38,
          dir: c10,
          Content: r27.targetType === "node" ? f4 : w
        };
        h5(x5);
      }
    },
    [d6, c10]
  ), S2 = e38.useCallback(() => {
    h5(null);
  }, []), i36 = e38.useCallback((r27, a38) => {
    const t38 = T3.current[r27];
    if (t38) {
      const f4 = {
        ...a38,
        nativeEvent: a38.originalEvent,
        target: k.current
      };
      t38.call(void 0, f4);
    }
  }, []);
  return e38.useEffect(() => {
    const r27 = {
      data: m11,
      links: y,
      nodes: v5,
      labels: E2,
      title: C3,
      legend: b2,
      disableAutoLayout: g2,
      disableKeyboardNavigation: L,
      rtl: c10 === "rtl",
      tooltip: { ...p8, ...d6 }
    };
    if (o33.current)
      o33.current.setOptions(r27);
    else if (e && l8.current) {
      const a38 = sankeyTheme(l8.current);
      o33.current = new Sankey3(l8.current, r27, a38), q(o33.current, {
        nodeEnter: (t38) => {
          i36("onNodeEnter", t38);
        },
        nodeLeave: (t38) => {
          i36("onNodeLeave", t38);
        },
        linkEnter: (t38) => {
          i36("onLinkEnter", t38);
        },
        linkLeave: (t38) => {
          i36("onLinkLeave", t38);
        },
        nodeClick: (t38) => {
          i36("onNodeClick", t38);
        },
        linkClick: (t38) => {
          i36("onLinkClick", t38);
        }
      }), o33.current.bind("tooltipShow", N), o33.current.bind("tooltipHide", S2);
    }
    return () => {
      o33.current && (o33.current.destroy(), o33.current = null);
    };
  }, [
    m11,
    y,
    v5,
    E2,
    C3,
    b2,
    g2,
    L,
    c10,
    d6,
    S2,
    N,
    i36
  ]), e38.useImperativeHandle(
    k,
    () => ({
      get element() {
        return l8.current;
      },
      exportVisual: (r27) => o33.current.exportVisual(r27),
      props: n20
    }),
    []
  ), e38.useImperativeHandle(u7, () => k.current), e38.createElement(e38.Fragment, null, e38.createElement("div", { ref: l8, className: n20.className, style: n20.style, dir: c10 }), R2 && e38.createElement(R, { ...R2 }), s10 && e38.createElement(l2, null));
});
P.propTypes = f3;
P.displayName = "KendoReactSankey";

// node_modules/@progress/kendo-react-charts/sankey/utils.mjs
var t37 = createSankeyData;
export {
  x as AxisLabelClickEvent,
  f2 as Chart,
  e27 as ChartArea,
  r16 as ChartAxisDefaults,
  s8 as ChartAxisDefaultsCrosshair,
  i21 as ChartAxisDefaultsCrosshairTooltip,
  o4 as ChartAxisDefaultsLabels,
  i20 as ChartAxisDefaultsTitle,
  s6 as ChartBreadcrumb,
  t29 as ChartCategoryAxis,
  a11 as ChartCategoryAxisCrosshair,
  i22 as ChartCategoryAxisCrosshairTooltip,
  r17 as ChartCategoryAxisItem,
  a12 as ChartCategoryAxisLabels,
  a13 as ChartCategoryAxisNotes,
  n10 as ChartCategoryAxisNotesIcon,
  a14 as ChartCategoryAxisNotesLabel,
  o8 as ChartCategoryAxisRangeLabels,
  r11 as ChartCategoryAxisTitle,
  o24 as ChartLegend,
  n11 as ChartLegendInactiveItems,
  o10 as ChartLegendItem,
  r12 as ChartLegendTitle,
  r18 as ChartNavigator,
  r15 as ChartNavigatorCategoryAxis,
  e24 as ChartNavigatorHint,
  o22 as ChartNavigatorPane,
  a28 as ChartNavigatorSelect,
  m6 as ChartNavigatorSeries,
  a29 as ChartNavigatorSeriesItem,
  i18 as ChartNoDataOverlay,
  o26 as ChartPane,
  o27 as ChartPaneDefaults,
  o9 as ChartPaneDefaultsTitle,
  m7 as ChartPanes,
  a33 as ChartPlotArea,
  r20 as ChartSeries,
  a34 as ChartSeriesDefaults,
  a17 as ChartSeriesErrorBars,
  m4 as ChartSeriesExtremes,
  i25 as ChartSeriesHighlight,
  c7 as ChartSeriesItem,
  i24 as ChartSeriesItemOutliers,
  i23 as ChartSeriesItemTooltip,
  a16 as ChartSeriesLabels,
  m5 as ChartSeriesLabelsFrom,
  a18 as ChartSeriesLabelsTo,
  a15 as ChartSeriesMarkers,
  n12 as ChartSeriesNotes,
  n13 as ChartSeriesNotesIcon,
  a19 as ChartSeriesNotesLabel,
  r21 as ChartSubtitle,
  r22 as ChartTitle,
  r23 as ChartTooltip,
  r24 as ChartValueAxis,
  a20 as ChartValueAxisCrosshair,
  i26 as ChartValueAxisCrosshairTooltip,
  o30 as ChartValueAxisItem,
  a21 as ChartValueAxisLabels,
  a22 as ChartValueAxisNotes,
  n14 as ChartValueAxisNotesIcon,
  r14 as ChartValueAxisNotesLabel,
  i27 as ChartValueAxisTitle,
  r25 as ChartXAxis,
  i28 as ChartXAxisCrosshair,
  i29 as ChartXAxisCrosshairTooltip,
  m8 as ChartXAxisItem,
  a23 as ChartXAxisLabels,
  n15 as ChartXAxisNotes,
  n16 as ChartXAxisNotesIcon,
  a24 as ChartXAxisNotesLabel,
  o16 as ChartXAxisTitle,
  t32 as ChartYAxis,
  i30 as ChartYAxisCrosshair,
  i31 as ChartYAxisCrosshairTooltip,
  m9 as ChartYAxisItem,
  a25 as ChartYAxisLabels,
  n17 as ChartYAxisNotes,
  n18 as ChartYAxisNotesIcon,
  a26 as ChartYAxisNotesLabel,
  o19 as ChartYAxisTitle,
  a36 as ChartZoomable,
  a9 as CollectionConfigurationComponent,
  i16 as ConfigurationComponent,
  a7 as CrosshairTooltip,
  p4 as CrosshairTooltipContainer,
  d4 as DonutCenter,
  i4 as DragEndEvent,
  r as DragEvent,
  r2 as DragStartEvent,
  n3 as DrilldownEvent,
  n8 as DrilldownStateChangeEvent,
  i6 as LegendItemClickEvent,
  i5 as LegendItemHoverEvent,
  i8 as NavigatorFilterEvent,
  r3 as NoteClickEvent,
  i9 as NoteHoverEvent,
  a as PlotAreaClickEvent,
  a2 as PlotAreaHoverEvent,
  o as RenderEvent,
  P as Sankey,
  i11 as SelectEndEvent,
  i10 as SelectEvent,
  i12 as SelectStartEvent,
  r4 as SeriesClickEvent,
  r5 as SeriesHoverEvent,
  h2 as SeriesTooltip,
  E as SharedTooltipContent,
  m2 as Sparkline,
  m3 as StockChart,
  a4 as TooltipPoint,
  i15 as TooltipPopup,
  i14 as ZoomEndEvent,
  i13 as ZoomEvent,
  r6 as ZoomStartEvent,
  t37 as createSankeyData,
  c6 as exportVisual,
  e9 as findAxisByName,
  s7 as findPaneByIndex,
  i19 as findPaneByName
};
/*! Bundled license information:

@progress/kendo-react-charts/utils/index.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/base-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/axis-label-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/preventable-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drag-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drag-end-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drag-start-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drilldown-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/legend-item-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/legend-item-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/legend-item-leave-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/navigator-filter-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/note-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/note-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/plot-area-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/plot-area-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/render-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/select-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/select-end-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/select-start-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/series-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/series-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/zoom-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/zoom-end-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/zoom-start-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/chart-event-builder.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/dom-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/store/store.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/store/reducer.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Point.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/SharedTooltipContent.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/ChartContext.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Popup.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Series.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/Container.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/CrosshairContainer.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/package-metadata.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/BaseChart.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/DonutCenter.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/Chart.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/Sparkline.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/StockChart.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/base/CollectionConfigurationComponent.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/base/ConfigurationComponent.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drilldown-state-change-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/ChartBreadcrumb.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/messages.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/ChartNoDataOverlay.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/methods/index.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/RangeLabels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/pane-defaults/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/legend/Item.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/legend/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/legend/InactiveItems.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Tooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Outliers.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Markers.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Highlight.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Extremes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/ErrorBars.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/LabelsFrom.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/LabelsTo.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/CategoryAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Hint.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Pane.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Select.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/SeriesItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Series.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/ChartArea.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/AxisDefaults.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/CategoryAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/CategoryAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Legend.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Navigator.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Pane.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/PaneDefaults.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Panes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/PlotArea.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/SeriesItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Series.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/SeriesDefaults.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Subtitle.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Tooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/ValueAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/ValueAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/XAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/XAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/YAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/YAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Zoomable.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/propTypes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/messages.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/SankeyTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/Sankey.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/utils.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/index.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright © 2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)
*/
//# sourceMappingURL=@progress_kendo-react-charts.js.map
